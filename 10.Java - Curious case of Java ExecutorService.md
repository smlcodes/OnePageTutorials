### So here the Case.
1. I have list of 100 User Objects
2. I have FixedThreadPool of 10
3. I want to sumbit these 100 objects to 10 threads to Save in the Database & it returns same user Object with UserId, which is Stored in DB
4. I will collect each saved User object in Future.

### Expectation
I thought 10 Theards will exceute 100 User Objects parallally.

### Here the Problem
Also `Future.get()` is a blocking method, which means it will block the execution of current thread and next iteration of loop will not continue unless this future (on which the get is called) returns. This will happen in every iteration, which makes the code non parallel.

```java
class User{
    int uid; //It will be DB primaryKey, created by DB
    String name;
    String address;
}

    public List<User> saveUsers(List <User> users){
        List<User> savedUsers = new ArrayList<>();
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        for (User user : users) {
            Callable r = () -> userservice.saveAndReturn(user);
            Future<Void> future = executorService.submit(r);
            User saved = future.get(); //blocking
            savedUsers.add(saved);
        }
        return savedUsers;
        
    }
```

By some on Stackoverflow asked almost same
"The reason I ask this is because in the below code the main thread would submit a task to be executed in a different thread. After submitting the task in the queue, it blocks on Future.get() method for the task to return the value. I would rather have the task executed in the main thread rather than submitting to a different thread and waiting for the results. What is that I gained by executing the task in a new thread?

I am aware that you could wait for a limited time etc, but then what if I really care about the result? The problem gets worse if there are multiple tasks to be executed. It seems to me that we are just doing the work synchronously. I am aware of the Guava library which provides a non blocking listener interface"


