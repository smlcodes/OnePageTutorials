
# Problem with Future 
Java has a *Future* interface for this. A *Future* represents the result of an asynchronous operation. Long running methods, external service calls and database hits are the good candidates for asynchronous operations.
<img width="1496" alt="image" src="https://user-images.githubusercontent.com/20472904/203542995-5983d2f3-b5ae-4e19-bce5-02bf32574ca0.png">


It is interesting that this *get()* is a blocking call, waits if necessary for the computation to complete and then retrieves the result.

We can also set a timeLimit on how long this asynchronous task can take by passing time and timeUnit in the *get()* and it throws *TimeOutException* along with the *InterruptedException* and *ExecutionException*.

The Future interface also has methods called *isDone*() which is used to check the completion of the asynchronous operation, *isCancelled() *as the name suggests to check the task is cancelled, and *cancel() *which attempts to cancel the task and it fails if the task has already completed, cancelled or could not cancel the task.
<img width="1496" alt="image" src="https://user-images.githubusercontent.com/20472904/203542838-f9087e92-d39e-48c1-829b-9cccc369cf8e.png">

if we have List of objects, it will block at get() of 1st object & wait until its complete.
<img width="1496" alt="image" src="https://user-images.githubusercontent.com/20472904/203543328-f2de82fa-54fb-4bba-a7ff-333df990d416.png">


Let's say we have Order object, which will undergo multiple methods to get final Order object with all details.
<img width="1496" alt="image" src="https://user-images.githubusercontent.com/20472904/203543676-6029a02f-0ceb-4c7e-a38a-94ead13a6dfa.png">

if we have 100 Order objects, each Order object needs to go 5 stages, but if we use Future here, it will block at every get() call. and the call not async any more.
<img width="1496" alt="image" src="https://user-images.githubusercontent.com/20472904/203543783-41973c3f-67b4-449a-bd48-cf46f653e399.png">



### Limitations of Future interface

1.  *Futures* cannot be completed manually.
2.  There is no way to execute multiple *futures (*or results*) *in parallel and then combine the results together.
3.  There are no exception handling constructs for *Future*.
4.  *Future* doesn't have the mechanism to create multiple stages of processing that can be chained together. It needs to be done manually.
5.  *Future* doesn't have the mechanism to notify you of the completion of an API.

Fortunately, with the release of Java 8, `CompletableFuture` combats all of the above problems and provides a much better asynchronous programming approach in Java.



CompletableFuture
=================

While Future Interface was a great improvement over Threads when it came to asynchronous programming, it still had several limitations most notable of which was the blocking call.

When CompletableFuture was introduced, it overcame some of Future Interface's shortcomings and resolved several of its limitations. Namely:

1.  Non-blocking
2.  Ability to Programmatically completing a future
3.  Perform Error handling
4.  Ability to Chain several futures
5.  Ability to combine results of multiple futures (that run in parallel)

If we submit 100 Orders CompletableFuture in the Order process.It will do ...
1. It will get the 1st Order by one thread, run as async and pass result to next and next...
2. Parllarlly , another theread will process another Order...in parllel all orders will be executed. NON Blocking
<img width="1496" alt="image" src="https://user-images.githubusercontent.com/20472904/203544779-610d4f4f-acf3-4cee-afa4-06c90a159149.png">

They only diffrence with applyAsnc is we can pass another ExecutorSrvice to process that pertilar method call with another therad of that ExecutorService.
<img width="1496" alt="image" src="https://user-images.githubusercontent.com/20472904/203545484-7ea9629f-fa51-46e7-990e-d5ce04345d40.png">






# Ref. 

CompletetableFeature
https://www.youtube.com/watch?v=ImtZgX1nmr8&t=1033s


https://swathisprasad.medium.com/multi-threading-in-spring-boot-using-completablefuture-a7ca68a0fe48#:~:text=Multi%2Dthreading%20is%20similar%20to,blocking%20and%20multi%2Dthreaded%20code.

https://www.youtube.com/watch?v=3rJBLFA95Io

https://levelup.gitconnected.com/completablefuture-a-new-era-of-asynchronous-programming-86c2fe23e246
