<!-- Copy and paste the converted output. -->

<!-----

You have some errors, warnings, or alerts. If you are using reckless mode, turn it off to see inline alerts.
* ERRORs: 1
* WARNINGs: 0
* ALERTS: 118

Conversion time: 59.618 seconds.


Using this Markdown file:

1. Paste this output into your source file.
2. See the notes and action items below regarding this conversion run.
3. Check the rendered output (headings, lists, code blocks, tables) for proper
   formatting and use a linkchecker before you publish this page.

Conversion notes:

* Docs to Markdown version 1.0β33
* Sun Jul 10 2022 23:52:28 GMT-0700 (PDT)
* Source doc: Java Re-Write - Copy
* Tables are currently converted to HTML tables.

ERROR:
undefined internal link to this URL: "#heading=h.28h4qwu".link text: See above examples for more
?Did you generate a TOC?

* This document has images: check for >>>>>  gd2md-html alert:  inline image link in generated source and store images to your server. NOTE: Images in exported zip file from Google Docs may not appear in  the same order as they do in your doc. Please check the images!


WARNING:
You have 16 H1 headings. You may want to use the "H1 -> H2" option to demote all headings by one level.

----->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 1; WARNINGs: 1; ALERTS: 118.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>
<a href="#gdcalert6">alert6</a>
<a href="#gdcalert7">alert7</a>
<a href="#gdcalert8">alert8</a>
<a href="#gdcalert9">alert9</a>
<a href="#gdcalert10">alert10</a>
<a href="#gdcalert11">alert11</a>
<a href="#gdcalert12">alert12</a>
<a href="#gdcalert13">alert13</a>
<a href="#gdcalert14">alert14</a>
<a href="#gdcalert15">alert15</a>
<a href="#gdcalert16">alert16</a>
<a href="#gdcalert17">alert17</a>
<a href="#gdcalert18">alert18</a>
<a href="#gdcalert19">alert19</a>
<a href="#gdcalert20">alert20</a>
<a href="#gdcalert21">alert21</a>
<a href="#gdcalert22">alert22</a>
<a href="#gdcalert23">alert23</a>
<a href="#gdcalert24">alert24</a>
<a href="#gdcalert25">alert25</a>
<a href="#gdcalert26">alert26</a>
<a href="#gdcalert27">alert27</a>
<a href="#gdcalert28">alert28</a>
<a href="#gdcalert29">alert29</a>
<a href="#gdcalert30">alert30</a>
<a href="#gdcalert31">alert31</a>
<a href="#gdcalert32">alert32</a>
<a href="#gdcalert33">alert33</a>
<a href="#gdcalert34">alert34</a>
<a href="#gdcalert35">alert35</a>
<a href="#gdcalert36">alert36</a>
<a href="#gdcalert37">alert37</a>
<a href="#gdcalert38">alert38</a>
<a href="#gdcalert39">alert39</a>
<a href="#gdcalert40">alert40</a>
<a href="#gdcalert41">alert41</a>
<a href="#gdcalert42">alert42</a>
<a href="#gdcalert43">alert43</a>
<a href="#gdcalert44">alert44</a>
<a href="#gdcalert45">alert45</a>
<a href="#gdcalert46">alert46</a>
<a href="#gdcalert47">alert47</a>
<a href="#gdcalert48">alert48</a>
<a href="#gdcalert49">alert49</a>
<a href="#gdcalert50">alert50</a>
<a href="#gdcalert51">alert51</a>
<a href="#gdcalert52">alert52</a>
<a href="#gdcalert53">alert53</a>
<a href="#gdcalert54">alert54</a>
<a href="#gdcalert55">alert55</a>
<a href="#gdcalert56">alert56</a>
<a href="#gdcalert57">alert57</a>
<a href="#gdcalert58">alert58</a>
<a href="#gdcalert59">alert59</a>
<a href="#gdcalert60">alert60</a>
<a href="#gdcalert61">alert61</a>
<a href="#gdcalert62">alert62</a>
<a href="#gdcalert63">alert63</a>
<a href="#gdcalert64">alert64</a>
<a href="#gdcalert65">alert65</a>
<a href="#gdcalert66">alert66</a>
<a href="#gdcalert67">alert67</a>
<a href="#gdcalert68">alert68</a>
<a href="#gdcalert69">alert69</a>
<a href="#gdcalert70">alert70</a>
<a href="#gdcalert71">alert71</a>
<a href="#gdcalert72">alert72</a>
<a href="#gdcalert73">alert73</a>
<a href="#gdcalert74">alert74</a>
<a href="#gdcalert75">alert75</a>
<a href="#gdcalert76">alert76</a>
<a href="#gdcalert77">alert77</a>
<a href="#gdcalert78">alert78</a>
<a href="#gdcalert79">alert79</a>
<a href="#gdcalert80">alert80</a>
<a href="#gdcalert81">alert81</a>
<a href="#gdcalert82">alert82</a>
<a href="#gdcalert83">alert83</a>
<a href="#gdcalert84">alert84</a>
<a href="#gdcalert85">alert85</a>
<a href="#gdcalert86">alert86</a>
<a href="#gdcalert87">alert87</a>
<a href="#gdcalert88">alert88</a>
<a href="#gdcalert89">alert89</a>
<a href="#gdcalert90">alert90</a>
<a href="#gdcalert91">alert91</a>
<a href="#gdcalert92">alert92</a>
<a href="#gdcalert93">alert93</a>
<a href="#gdcalert94">alert94</a>
<a href="#gdcalert95">alert95</a>
<a href="#gdcalert96">alert96</a>
<a href="#gdcalert97">alert97</a>
<a href="#gdcalert98">alert98</a>
<a href="#gdcalert99">alert99</a>
<a href="#gdcalert100">alert100</a>
<a href="#gdcalert101">alert101</a>
<a href="#gdcalert102">alert102</a>
<a href="#gdcalert103">alert103</a>
<a href="#gdcalert104">alert104</a>
<a href="#gdcalert105">alert105</a>
<a href="#gdcalert106">alert106</a>
<a href="#gdcalert107">alert107</a>
<a href="#gdcalert108">alert108</a>
<a href="#gdcalert109">alert109</a>
<a href="#gdcalert110">alert110</a>
<a href="#gdcalert111">alert111</a>
<a href="#gdcalert112">alert112</a>
<a href="#gdcalert113">alert113</a>
<a href="#gdcalert114">alert114</a>
<a href="#gdcalert115">alert115</a>
<a href="#gdcalert116">alert116</a>
<a href="#gdcalert117">alert117</a>
<a href="#gdcalert118">alert118</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>




<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image1.png "image_tooltip")
 

<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image2.png "image_tooltip")



## So called TITLE

**Copyright © 2016 Smlcodes.com**

All rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, **without the prior written permission** of the publisher, except in the case of brief quotations embedded in critical articles or reviews.

**Every effort has been made in the preparation of this book to ensure the accuracy of the information presented**. However, the information contained in this book is sold without warranty, either express or implied. Neither the author, SmlCodes.com, nor its dealers or distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book.

**Smlcodes.com has endeavored to provide trademark information** about all the companies and products mentioned in this book by the appropriate use of capitals. However, SmlCodes.com Publishing cannot guarantee the accuracy of this information. 

If you discover any errors on our website or in this tutorial, please notify us at [support@smlcodes.com](mailto:support@smlcodes.com) or [smlcodes@gmail.com](mailto:smlcodes@gmail.com) 

**First published on** Aug 2016, Published by **SmlCodes.com  **


## Author Credits 

Name		: **Satya Kaveti**

Email		: [satyakaveti@gmail.com](mailto:satyakaveti@gmail.com) 

Website	: smlcodes.com, satyajohnny.blogspot.com

 


# Table of Content


[TOC]


Change Table Content --> Top --> REFERENCES (5<sup>th</sup> Tab) -->update content


# Syllabus 

1.**Language Fundamentals**



1. Introduction
2. Java – JDK, JRE and JVM
3. Identifiers
4. Keywords
5. Datatypes
6. Literals
7. Arrays
8. Types of Variables
9. Var – Arg Methods
10. Flow Control
11. Command Line Arguments & Main Method
12. Java Coding Standards

2.**Class** **Declaration and Access Control**



    1. Java Source File Structure
    2. Class Modifiers
    3. Member Modifiers
    4. Interface

3. **Java OOPS**



1. ** **Constructors
2.  Abstraction
3.  Encapsulation
4.  Inheritance
5.  Polymorphism
6.  Overloading vs Overriding
7.  Interface vs. Abstract Class
8.  Multiple Inheritance
9. Association, Aggregation and Composition

**4. Fundamental classes in java.lang.package**



1. Object Class
2. String class
3. StringBuffer Class
4. StringBuilder Class
5. Wrapper Classes
6. Math class

5. **Exception Handling**

6. **Collections**

7. **Threads and Concurrency**

8. **File I/O & Serialization**

9. **Garbage Collection**

**10. Reflection API**

11. **Networking**

**12. Java Features**


# 1.Language Fundamentals

Java is a platform independent programming language which is introduced by **James Gosling** and his team mates in the year 1991.

First they want to develop programming language for the **Setup boxes and small embedded systems** in the year of 1991.they named it as “**Green talk”,** because the file extension is ‘.**gt’**. After that they renamed as **“Oak”,** it’s a tree name**. **But they faced some trademark issues in 1995 they renamed it as “Java”

The first beta version of java released in 1995.


## Features of Java

**1.Simple – No Pointers Dude!**

Compare with previous Object oriented language C++ they removed many confusing and/or rarely-used features e.g., explicit pointers, operator overloading etc.So now no confusions, clean syntax makes java as **Simple**

 

**2.Object-oriented – All about java Basics**

Java based on OOP.below are concepts of OOPs are:



* Object
* Class
* Inheritance
* Polymorphism
* Abstraction
* Encapsulation

 

**3.Platform Independent – OS doesn’t matter!**

A platform is the hardware or software environment in which a program runs. There are two types of platforms software-based and hardware-based. Java provides software-based platform.

Java code can be run on multiple platforms e.g.Windows,Linux,Sun Solaris,Mac/OS etc. Java code is compiled by the compiler and converted into bytecode. This byte-code is a platform independent code because it can be run on multiple platforms



<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image3.png "image_tooltip")


 

**4.   Secured – U can Hack OS, but you can’t hack Java Byte code**

The Java platform is designed with security features built into the language and runtime system such as static type-checking at compile time and runtime checking (security manager), which let you creating applications that can’t be invaded from outside. You never hear about viruses attacking Java applications.

 

**5.   Robust – Strong, Error Free always**

Robust simply means strong. Java uses strong memory management. There are lack of pointers that avoids security problem. There is automatic garbage collection in java. There is exception handling and type checking mechanism in java. All these points makes java robust.

 

**6.    Architecture-neutral – 64-bit, 32-bit, xxx-bit doesn’t matter I will work**

The language like JAVA can run on any of the processor irrespective of their architecture and vendor

 

**7.   Portable**

We may carry the java bytecode to any platform.

 

**8.   High-performance**

Java is faster than traditional interpretation since byte code is “close” to native code still somewhat slower than a compiled language (e.g., C++)

 

**9.   Distributed**

We can create distributed applications in java. RMI and EJB are used for creating distributed applications. We may access files by calling the methods from any machine on the internet.

 

**10. Multi-threaded**

A thread is like a separate program, executing concurrently. We can write Java programs that deal with many tasks at once by defining multiple threads. The main advantage of multi-threading is that it shares the same memory. Threads are important for multi-media, Web applications etc.

 

**<span style="text-decoration:underline;">Class Path</span> :**

**CLASSPATH** is a parameter that tells the JVM where to look for classes and packages.

When you have set of jar files which are always required during your application runtime, then it’s probably best to add them in machine’s environment variable 'CLASSPATH'. 

During application runtime, application class loader will always scan the jar files and classes at specified paths in this variable.


## Java – JDK, JRE and JVM

**JVM Architecture**



<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image4.png "image_tooltip")


**ClassLoader**

**<span style="text-decoration:underline;">1.Loading: </span>**

When a Java program is converted into **.class **file by Java compiler which is collection of byte code. **ClassLoader** is responsible to load that class file from file system, network or any other location.

Our Java class is depends up on any other class let’s say JdbcDriver.class, it will search by following ClassLoaders



* **Bootstrap ClassLoader** - **JRE/lib/rt.jar**

First bootstrap class loader tries to find the class. It scans the **rt.jar** file in JRE **lib** folder



* **Extension ClassLoader** - **JRE/lib/ext** or any directory denoted by java.ext.dirs

If class is not found then extension class loader searches the class file in inside **jre\lib\ext**folder



* **Application ClassLoader** - **CLASSPATH environment variable, -classpath or -cp option**

Again if class is not found then application classloader searches all the Jar files and classes in `CLASSPATH` environment variable of system.

If class is found by any loader then class is loaded by class loader; else `ClassNotFoundException` is thrown 

**<span style="text-decoration:underline;">2.Linking: </span>**



* **Bytecode verifier** will verify whether the generated bytecode is proper or not.
* **Prepare(memory allocation)**: allocates memory **to static variables & methods**.

**<span style="text-decoration:underline;">3.Initialization</span>: **In prepare only memory is allocated, here all **static variable will be assigned** with the original values and the **static blocks will be executed**.

**Runtime area**

**Fields(Data members)** and **methods** are also known as **class members**



* **Method Are**a : all **Class level** Data members, Method definitions stored here
* **Heap** All **Objects** & instance variable Data stored Here.
* **Stacks** : All **Methods executions & Thread Executions** done here. store local variables, and intermediate results. Each thread has its own JVM stack, created simultaneously as the thread is created. So all such local variable are called **thread-local variables**.
* **PC register** store the physical memory address of the statements which is currently executing. In Java, each thread has its separate PC register.
* Java supports and uses **native code** as well. Many low level code is written in languages like C and C++. Native method stacks hold the instruction of native code.

**Execution Engine**

All code assigned to JVM is executed by an **execution engine**. The execution engine reads the byte code and executes one by one. It uses two inbuilt _interpreter_ and _JIT compiler_ **to convert the bytecode to machine code and execute it**.

**<span style="text-decoration:underline;">1.Interpreter</span> **A JVM interpreter pretty much converts each byte-code instruction to corresponding native instruction. It **directly** executes the bytecode only one instruction at a time and **does not perform any optimization.**

**<span style="text-decoration:underline;">2.JIT Compiler</span> **JIT compiler **takes a block of code** (not one statement at a time as interpreter), optimize the code and then translate it to optimized machine code.** To improve performance, it will Optimizes the bytecode**

**Differences between JDK, JRE and JVM**

JVM = Just a Specification. HotSpot VM is implementation of IT

JRE = JVM + libraries to run Java application.

JDK = JRE + tools to develop Java Application.



<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image5.png "image_tooltip")



## Identifiers


```
public class Hello {
public static void main(String[] args) {
       System.out.println("Hello Java!");
}
}
```


In Above Hello, main, args are called **Identifiers** 

**Rules for defining Identifiers**



* Only Allowed charaters are
        * ** a-z **
        * **A-Z**
        * ** 0-9**
        * ** $ **
        * **  – **
* if we are using any other symbol we will get Compile time error “_IllegalCharacter_”.
* Identifier should not be starts with digit.
* There is no length limit for java identifiers but it is not recommended to take more than 15 length.
* All Java class names, Interface names we can uses as an Identifier, but it’s not recommended

    ```
    public class Test {
    	int Runnable = 10;
    	int Integer = 20;	
    }

    ```



## Keywords

Some identifiers are reserved to associate some functionality or to represent values, such type of reserved identifiers are called “_ReservedWords_” / “Keywords”


<table>
  <tr>
   <td>
    abstract
   </td>
   <td>
    continue
   </td>
   <td>
    for
   </td>
   <td>
    new
   </td>
   <td>
    switch
   </td>
  </tr>
  <tr>
   <td>
    assert<sup>***</sup>
   </td>
   <td>
    default
   </td>
   <td>
    goto<sup>*</sup>
   </td>
   <td>
    package
   </td>
   <td>
    synchronized
   </td>
  </tr>
  <tr>
   <td>
    boolean
   </td>
   <td>
    do
   </td>
   <td>
    if
   </td>
   <td>
    private
   </td>
   <td>
    this
   </td>
  </tr>
  <tr>
   <td>
    break
   </td>
   <td>
    double
   </td>
   <td>
    implements
   </td>
   <td>
    protected
   </td>
   <td>
    throw
   </td>
  </tr>
  <tr>
   <td>
    byte
   </td>
   <td>
    else
   </td>
   <td>
    import
   </td>
   <td>
    public
   </td>
   <td>
    throws
   </td>
  </tr>
  <tr>
   <td>
    case
   </td>
   <td>
    enum<sup>****</sup>
   </td>
   <td>
    instanceof
   </td>
   <td>
    return
   </td>
   <td>
    transient
   </td>
  </tr>
  <tr>
   <td>
    catch
   </td>
   <td>
    extends
   </td>
   <td>
    int
   </td>
   <td>
    short
   </td>
   <td>
    try
   </td>
  </tr>
  <tr>
   <td>
    char
   </td>
   <td>
    final
   </td>
   <td>
    interface
   </td>
   <td>
    static
   </td>
   <td>
    void
   </td>
  </tr>
  <tr>
   <td>
    class
   </td>
   <td>
    finally
   </td>
   <td>
    long
   </td>
   <td>
    strictfp<sup>**</sup>
   </td>
   <td>
    volatile
   </td>
  </tr>
  <tr>
   <td>
    const<sup>*</sup>
   </td>
   <td>
    float
   </td>
   <td>
    native
   </td>
   <td>
    super
   </td>
   <td>
    while
   </td>
  </tr>
</table>



<table>
  <tr>
   <td>
    <sup>*</sup>
   </td>
   <td>
     
   </td>
   <td>
    not used
   </td>
  </tr>
  <tr>
   <td>
    <sup>**</sup>
   </td>
   <td>
     
   </td>
   <td>
    added in 1.2
   </td>
  </tr>
  <tr>
   <td>
    <sup>***</sup>
   </td>
   <td>
     
   </td>
   <td>
    added in 1.4
   </td>
  </tr>
  <tr>
   <td>
    <sup>****</sup>
   </td>
   <td>
     
   </td>
   <td>
    added in 5.0
   </td>
  </tr>
</table>



## Comments 


    /* _text_ */


    The compiler ignores everything from /* to */.


    /** _documentation_ */


    This indicates a documentation comment (_doc comment_, for short). The compiler ignores this kind of comment, just like it ignores comments that use /* and */. The javadoc tool uses doc comments when preparing automatically generated documentation. 


    // _text_


    The compiler ignores everything from // to the end of the line


## Datatypes


<table>
  <tr>
   <td><strong>Data Type</strong>
   </td>
   <td><strong>Default Value</strong>
   </td>
   <td><strong>Default size</strong>
   </td>
  </tr>
  <tr>
   <td>boolean
   </td>
   <td>false
   </td>
   <td>1 bit
   </td>
  </tr>
  <tr>
   <td>char
   </td>
   <td>'\u0000'
   </td>
   <td>2 byte
   </td>
  </tr>
  <tr>
   <td>byte
   </td>
   <td>0
   </td>
   <td>1 byte
   </td>
  </tr>
  <tr>
   <td>short
   </td>
   <td>0
   </td>
   <td>2 byte
   </td>
  </tr>
  <tr>
   <td>int
   </td>
   <td>0
   </td>
   <td>4 byte
   </td>
  </tr>
  <tr>
   <td>long
   </td>
   <td>0L
   </td>
   <td>8 byte
   </td>
  </tr>
  <tr>
   <td>float
   </td>
   <td>0.0f
   </td>
   <td>4 byte
   </td>
  </tr>
  <tr>
   <td>double
   </td>
   <td>0.0d
   </td>
   <td>8 byte
   </td>
  </tr>
</table>


**int** : The size of int is always fixed irrespective of platform hence the chance of failing java program is very less if u r changing the platform hence the java is considered as Robust


## Literals

A literal represents a constant value which can be assigned to the variables

**<code>int x = 10;</code></strong>  int – Datatype, x – variable, <strong>10 – Liertal </strong>

**<span style="text-decoration:underline;">1.Integral Literal:</span>**

We can specify an integral literal in the following ways.



* **Decimal literals: **allowed digits are 0 to 9
* Binary **literals** (digits 0–1): which uses the number 0 followed by b or B as a prefix—for example, 0b10
* Octal **literals** (digits 0–7) : which uses the number 0 as a prefix—for example, 017
* Hexadecimal **literals** (digits 0–9 and letters A–F), which uses the number 0 followed by x or X as a prefix—for example, 0xFF(A=10, B=11, c=12, D=13, E=14, F=15)


```
System.out.println(56); // 56
System.out.println(0b11); // 3	// 1*(2)1 +1*(2)0 🡺 (1*2) + (1*1) == 3 
System.out.println(017); // 15	// 1*(8)1 +7*(8)0 🡺 (1*8) + (7*1) == 15
System.out.println(0x1F); // 31	// 1*(16)1 +F*(16)0 🡺 (1*16) + (15*1) == 31
```


By default, every **integral lateral is of int datatype**. An integral literal is of long type by suffixing with l or L.



* 10 - int value.
* 10L -  long value

There is no way to specify explicitly an integral literal is of type **byte and short**. If the integral literal is with in the range of byte then the JVM by default treats it as byte literal.



<p id="gdcalert6" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image6.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert7">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image6.png "image_tooltip")


**<span style="text-decoration:underline;">2.Floating – Point literals</span>**

By default floating-point literals are **double** type we can specify explicitly as float type by suffixing with **‘f’ or ‘F’.**


```
float f = 10.5;  // C.E possible loss of precision
float f = 10.5f; 
```


Floating point literals can be specified only in decimal form. i.e we can’t use octal and hexa decimal representation for floating point literals. But we can assign Octal & hexa interger values to float.


```
Double d = 0x123.456; // C.E Invalid hex literal number
Double d = 0x123; //But we can assign Octal & hexa interger values to float
```


added in Java 7. You can have underscores in numbers to make them easier to read:

You can add underscores anywhere **except** 



* at the beginning of a literal
* the end of a literal
* right before a decimal point, or right after a decimal point.
* Prior to an F or L suffix


```
int million1 = 1000000;
int million2 = 1_000_000;

double notAtStart = _1000.00; // DOES NOT COMPILE
double notAtEnd = 1000.00_; // DOES NOT COMPILE

double notByDecimal = 1000_.00; // DOES NOT COMPILE
double annoyingButLegal = 1_00_0.0_0; // this one compiles
```


The following example shows other ways you can use the underscore in numeric literals:


```
long creditCardNumber = 1234_5678_9012_3456L;
long socialSecurityNumber = 999_99_9999L;
float pi =  3.14_15F;
long hexBytes = 0xFF_EC_DE_5E;
long hexWords = 0xCAFE_BABE;
long maxLong = 0x7fff_ffff_ffff_ffffL;
byte nybbles = 0b0010_0101;
long bytes = 0b11010010_01101001_10010100_10010010;
```


Following are Invalid Locations


```
long x1 = 999_99_9999_L; // Before L
int x2 = 52_;		// At the End Not allowed
int x3 = 5_______2;	//correct : Any no.of _'s will allowed beween numbers

int x4 = 0_x52;	// cannot put underscores in the 0x radix prefix
int x5 = 0x_52;	// cannot put underscores  at the beginning of a number

int x6 = 0x5_2; correct
```


**<span style="text-decoration:underline;">3. Character literal</span>**

A char literal can be represented as a single character with in single quotes.


```
char ch = 'a';
char ch = 'ab'; C.E: unclosed character literal.
```


we can represent a char literal by it’s Unicode value. For the allowed Unicode values are 0 to 65535.


```
char ch = 97;
System.out.println(ch); 	O/P: a

char ch = 65535;
char ch = 65536; C.E : possible loss of precision found : int required :char
```


we can represent a char literal by using Unicode representation which is nothing but \uxxxx’(0-F)


```
char ch = '\u0061'
System.out.println(ch); --> O/P:a
char ch = '\ubeef'; --> O/P: ? (No charater defiend with this value)
char ch = '\uface'; --> O/P: ?
```


we can also represent a char literal by using escape character.


```
char ch = '\b';
char ch = '\n';
char ch = '\l';
```



## Arrays

An array is a data structure that represents an index collection of fixed no of homogeneous data

elements.

**<span style="text-decoration:underline;">1.Declaring Arrays</span>**

you can type the [] before or after the name, and adding a space is optional. This means that all four of these statements do the exact same thing:


```
int[] numAnimals;
int [] numAnimals2;
int numAnimals3[];
int numAnimals4 [];
```


The following are the valid declarations for multidimensional arrays.


```
int[][] a;
int a[][];
int [][]a;
int[] a[];
int[] []a;
```


we can specify the dimension before name of variable also, but this facility is available only for the first variable.


```
int[] a[],b[];
int[] []a,[]b; //Wrong
```


**<span style="text-decoration:underline;">2.Construction of Arrays</span>**

**Single Dimension:** Arrays are internally implemented as object hence by using new operator we can construct an array.

Compulsory at the time of construction we should specify the size otherwise compile time error.


```
int[] a = new int[10]; _/
int[] a = new int[]; C.E : error: array dimension missing
```


It is legal to have an error with size 0 there is no C.E or R.E


```
int[] a = new int[0]; // it will create Empty Array [] (no elemets inside it)
```


If we are specifying array size with some –ve integer, we will get R.E:NegativeArraySizeException.


```
int[] a = new int[-10]; // Exception in thread "main" java.lang.NegativeArraySizeException
```


The only allowed Data type to allow the size are byte, short, char, int. if we are using any other datatype we will get a C.E.


```
int[] a = new int[10];
int[] a1 = new int[10l];
int[] a = new int[10L]; --> C.E:incompatible types:possible loss of precision found: long required: int
```


**Multi Dimension: **In java multidimensional arrays are implemented as single dimension arrays. This approach improves performance with respect to memory.


```
int[][] a = new int[3][2];	🡪 First Row has 3 locations,  each locaton has 2 elements, total tree height will be 2
```




<p id="gdcalert7" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image7.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert8">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image7.png "image_tooltip")



```
int[][] a = new int[4][]

a[0] = new int[1];
a[1] = new int[2];
a[2] = new int[4];
a[3] = new int[3];
```




<p id="gdcalert8" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image8.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert9">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image8.png "image_tooltip")



```
declare an array for the following diagram
```




<p id="gdcalert9" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image9.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert10">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image9.png "image_tooltip")



```
a[][][] = new int[2][][];
a[0] 	= new int[3];
a[0][1] = new int[1];
a[0][2] = new int[2];
a[0][3] = new int[3];
a[1] 	= new int[2][2];
```


**<span style="text-decoration:underline;">3.Initialization of arrays</span>**

Once we created an array all it’s elements initialized with default values.


```
int[] a = new int[3];
System.out.println(a[0]); O/P: 0
System.out.println(a); O/P: [I@10b62c9

int[][] a = new int[3][2];
System.out.println(a); --> [I@10b62c9
System.out.println(a[0]); --> [[I@82ba41
System.out.println(a[0][0]); --> 0

int[][] a = new int[3][];
System.out.println(a); --> [I@10b62c9
System.out.println(a[0]); --> null
System.out.println(a[0][0]); --> NullPointerException
```


**<span style="text-decoration:underline;">4.Declaration and Initialization Array in a single line</span>**


```
int[] a = {10,20,30};
String[] s = {"Chiru","Allu","Ram","Akil"}
```


**<span style="text-decoration:underline;">5.length Vs length();</span>**

**length: **It is the final variable applicable for array objects. It represents the size of the array.


```
int [] a = new int[5];
System.out.println(a.length()); --> C.E
System.out.println(a.length); --> 6
```


l**ength():**It is the final method applicable only for String Objects. Ex:


```
String s = "raju";
System.out.println(s.length); --> C.E
System.out.println(s.length()); --> 4
```



## Types of Variables

**<span style="text-decoration:underline;">1.Instance Variables </span>**



* If the value of a variable is varied from object to object. Such type of variables are called instance variables. For every object a separate copy of instance variables will be created.
* Instance variables will be crated at the time of object creation and will be destroyed at the time of object destruction
* All the Instance varibles Stored in **“Heap area”**

    ```
    public class Demo
    {
        int count = 20;        //1 - Instance variable
    }

    ```


**<span style="text-decoration:underline;">2.Staic Variables </span>**



* If the value of a variable is fixed for all objects, then we have to declare at class level by using static keyword. For the static variables a single copy will be created at class level and shared by all objects of that class.
* Static variables will be created at the time of class loading and destroyed at the time of unloading.
* All Static varibles are Stored in **“Method Area”**

    ```
    public class Test {
    	int i;
    	static int j = 10;

    	public static void main(String arg[]) {
    		Test t1 = new Test();
    		t1.i = 100;
    		t1.j = 200;
    		Test t2 = new Test();
    		System.out.println(t2.i + " : " + t2.j); //0 : 200
    	}
    }

    ```


**<span style="text-decoration:underline;">3.Local variables</span>**



* If we are declaring a variable with in a method or constants or block such type of variables are called local variables.
* For the local variables JVM won’t provide any default values. **Before using a local variable compulsory we should perform initialization explicitly otherwise compile time error.**

        ```
        public class Test {
        	public static void main(String arg[]) {
        		int i;
        		System.out.println(i);
        	}
        }
        Exception in thread "main" java.lang.Error: Unresolved compilation problem: 
        	The local variable i may not have been initialized

        public class Test {
        	public static void main(String arg[]) {
        		int i;
        		System.out.println("Here i not used");//No error
        	}
        }
        ```


* It is not recommended to perform initialization of local variables in logical blocks because their is no guarenty of execution these blocks at runtime.

        ```
        public class Test {
        	public static void main(String arg[]) {
        		int i;
        		if(arg.length>0){
        			i=10;
        		}
        		System.out.println(i);
        	}
        }
        Test.java:9: error: variable i might not have been initialized
                        System.out.println(i);
                                           ^

        class Test {
        	public static void main(String arg[]) {
        		int i;
        		if (arg.length > 0) {
        			i = 10;
        		} else {
        			i = 20;
        		}
        		System.out.println(i);
        	}
        }
        //Because if we give arguments 10 will be initialized other wise 20 will be initialized.
        It is not good programming practice to perform initialization in logical blocks for local variables because they may not execute at runtime.
        ```


* The only applicable modifier for the local variable is **final**. If we are using any other modifier we will get compile time error.

        ```
        public class Test {
        	public static void main(String arg[]) {
        		public int a;
        		protected int b;
        		private int c;			
        	}
        }
        Test.java:7: error: illegal start of expression
                        public int a;

        ```



## main() method

JVM always calls main method to start the program. **Compiler is not responsible** to check whether the class contain main() or not. Hence if we are not the main method **we won’t get any C.E.** **But at runtime JVM raises NoSuchMethodError:main**


## Operators


```
System.out.print(9 / 3); // Outputs 3
System.out.print(9 % 3); // Outputs 0

System.out.print(10 / 3); // Outputs 3
System.out.print(10 % 3); // Outputs 1

System.out.print(11 / 3); // Outputs 3
System.out.print(11 % 3); // Outputs 2

System.out.print(12 / 3); // Outputs 4
System.out.print(12 % 3); // Outputs 0
```


**<span style="text-decoration:underline;">Numeric Promotion Rules</span>**

1. If two values have different data types, Java will automatically promote one of the values to the larger of the two data types.

2. If one of the values is integral and the other is floating-point, Java will automatically promote the integral value to the floating-point value’s data type.

3. Smaller data types, namely byte, short, and char, are first promoted to int any time they’re used with a Java binary arithmetic operator, even if neither of the operands is int.

4. After all promotion has occurred and the operands have the same data type, the resulting value will have the same data type as its promoted operands.

**What is the data type of x / y?**


```
short x = 10;
short y = 3;
```


In this case, we must apply the third rule, namely that 



* first x and y will both be promoted to int 
* After promation, operation will perform, resulting output of int type.

**What is the data type of x * y / z?**


```
short x = 14;
float y = 13;
double z = 30;
```


we evaluate the multiple and division from left-to-right. In this case, we must apply all of the rules. First, x will automatically be promoted to int solely because it is a short and it is being used in an arithmetic binary operation. The promoted x value will then be automatically promoted to a float so that it can be multiplied with y. The result of x * y will then be automatically.

**<span style="text-decoration:underline;">1.Increment/ Decement</span>**



<p id="gdcalert10" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image10.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert11">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image10.png "image_tooltip")




* For the final variables we can’t apply increment or decrement operators

        ```
        	final int i=10;
        	i++;  
         (or)		 
        i=20;
        Test.java:8: error: cannot assign a value to final variable i
                         i++;
                         ^
        ```


* We can apply increment or decrement operators even for **floating point data types** also.

        ```
        double d = 10.5;
        d++;
        System.out.println(d);// 11.5

        ```


**How this following expression is evaluated?**


```
int x = 3;
int y = ++x * 5 / x-- + --x;
System.out.println("x is " + x);
System.out.println("y is " + y);

int y = 4 * 5 / x-- + --x; // x assigned value of 4
int y = 4 * 5 / 4 + --x; // x assigned value of 3
int y = 4 * 5 / 4 + 2; // x assigned value of 2
```


we evaluate the multiple and division from left-to-right, and finish with the addition.The result is then printed: x is 2 & y is 7

**Does it work?**


```
long t = 192301398193810323; // DOES NOT COMPILE
```


It does not compile because Java interprets the literal as an int and notices that the value is larger than int allows. The literal would need a postfi x L to be considered a long


```
short x = 10;
short y = 3;
short z = x * y; // DOES NOT COMPILE

short x = 10;
short y = 3;
short z = (short)(x * y);

long x = 10;
int y = 5;
y = y * x; // DOES NOT COMPILE
```


Based on the last two sections, you should be able to spot the problem in the last line.This last line could be fi xed with an explicit cast to (int), but there’s a better way using the compound assignment operator:


```
long x = 10;
int y = 5;
y *= x;
```


The compound operator will first cast x to a long, apply the multiplication of two long values, and then cast the result to an int.


```
long x = 5;
long y = (x=3);
System.out.println(x); // Outputs 3
System.out.println(y); // Also, outputs 3
```


**Infinity and -Infinity**



* In Integer Arthematic (byte,int,short), if any thing divide 0 will get R.E: A.E: Divide by 0.
* But In Floating point arthematic, if any thing didvide by 0.0, we will get **Infinity/ -Infinity**


```
		System.out.println(10 / 0.0); // Infinity	
		System.out.println(-10 / 0.0);// -Infinity
```


**NaN – Not a Number**



* In Integer Arthematic (byte,int,short), 0 divide 0 will get R.E: A.E: Divide by 0.
* But In Floating point arthematic, 0 divide by 0.0, we will get **Nan (no -Nan is there)**


```
		System.out.println(0.0 / 0.0); // NaN	
		System.out.println(-0.0 / 0.0);// NaN
```


**<span style="text-decoration:underline;">Equality Operators (==)</span>**

The comparisons for equality are limited to these three cases, so you cannot mix and match types. For example, each of the following would result in a compiler error:


```
boolean x = true == 3; // DOES NOT COMPILE
boolean y = false != "Giraffe"; // DOES NOT COMPILE
boolean z = 3 == "Kangaroo"; // DOES NOT COMPILE
```


**<span style="text-decoration:underline;">Conditional Statements</span>**


```
int x = 1;
if(x) { // DOES NOT COMPILE
...
}

int x = 1;
if(x = 5) { // DOES NOT COMPILE
...
}

System.out.println((y > 5) ? 21 : "Zebra");
int animal = (y < 91) ? 9 : "Horse"; // DOES NOT COMPILE
```


**^ (X-OR) - Homogenious are FALSE(T,T F,F), Hertrogenious are TRUE(T,F  F,T) **


## Flow Control

Flow control describes the order in which all the statements will execute at run time



<p id="gdcalert11" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image11.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert12">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image11.png "image_tooltip")


**Selection Statements**

**<span style="text-decoration:underline;">1.if-else :</span>**



* The argument in the if statement Should be ‘boolean’. If we provide other datatype, it will generate Compiletime Error

<table>
  <tr>
   <td>
<strong><code>int x=0;</code></strong>
<strong><code>if (<span style="text-decoration:underline;">x</span>) {</code></strong>
<strong><code>   System.<em>out</em>.println("Hello");</code></strong>
<strong><code>} else {</code></strong>
<strong><code>   System.<em>out</em>.println("Hi");</code></strong>
<strong><code>}</code></strong>
<strong><code>incompatible types: int cannot be converted to boolean</code></strong>
   </td>
   <td><strong><code>boolean <span style="text-decoration:underline;">b</span>=false;</code></strong>
<strong><code>if (b=true) {</code></strong>
<strong><code>   System.<em>out</em>.println("Hello");</code></strong>
<strong><code>} else {	</code></strong>
<strong><code>   System.<em>out</em>.println("Hi");</code></strong>
<strong><code>}</code></strong>
<strong><code>//o/p Hello</code></strong>
   </td>
  </tr>
</table>




* In the case of if-else statements else part & **curly braces are optional**.Without curly braces we are allowed to take 1 statement under ‘if’, that statement never be declarative statement other wise compile time error.

    

<p id="gdcalert12" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image12.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert13">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image12.png "image_tooltip")



**<span style="text-decoration:underline;">2.Switch :</span>**

Syntax:


```
		int i = 0;
		switch (i) {
		case 1:
			ACTION 1;
		case 2:
			ACTION 2;
		case n:
			ACTION N;
		default:
			Def. Action
		}

```



* **Curly bases are mandatory**
* Inside a Switch **both case and default are optional** 

        ```
        int i = 10;
        switch (i)
        {
        	// CORRECT
        }
        ```


* With in switch every statement should be under some case or default i.e independent statements are not allowed inside switch.

        ```
        int i = 10;
        switch(i)
        {
        	System.out.println("Hello");
        }
        //CE : error: case, default, or '}' expected
        ```


* All **Interger Datatypes(int, short except floting point datatypes), Wrapper Classes, enums** **(1.5v ), Strings(1.7v)** are allowed in switch statements.
* Case labels **must be compiled time constants(final varibles),** varibles are not allowd.

        ```
        int i = 10; //final int i=10 - No Error		
        switch (i) {
        case i:
        	System.out.println("Hello");
        	break;
        }
        error: constant expression required : case i:
                             			^
        ```


* The ‘case’ labels must be in the range supported by switch argument.

        ```
        		byte b = 100;
        		switch (b)
        		{
        		case 10 :System.out.println("10");
        				 break;
        		case 100 :System.out.println("100");
        				  break;
        		case 1000 :System.out.println("1000");
        				   break;
        		}
        error: incompatible types: possible lossy conversion from int to byte
        ```


* The case labels and the switch arguments can be expressions also but case label must be constant expression

        ```
        int x=10, y=10;
        byte b = 100;
        switch (b + 1) {
        case 10:
        	System.out.println("10");
        case 20:
        	System.out.println("20");
        case 30 + 40:
        	System.out.println("30+40 = 70");
        case x + y:
        	System.out.println("30+40 = 70"); //ERROR

        }
        Test.java:16: error: constant expression required
                        case x + y:
                               ^
        ```


* Duplicate case labels are not allowed.

**default Case**: In the switch statement we can place default case any where but it is convention to take default case always at least.

In side switch once we got matched case from that statement on words all the statements will execute from top to bottom until break or end of switch


```
     switch (x) {
		default:
			System.out.println("default");
		case 0:
			System.out.println("0");
			break;
		case 1:
			System.out.println("1");
		case 2:
			System.out.println("2");
	}
Here if 'x' is 0 then output is 0.
if 'x' is 1 then output is 1,2.
if 'x' is 2 then output is 2.
if 'x' is 3 then output is default, 0.
```


**Iterative Statements**

**<span style="text-decoration:underline;">1.While:</span>**

Syntax:


```
while(boolean){
//statements…
}

```



* The argument in the while Statement Should be Boolean, otherwise we will get C.E
* **curly braces are optional**. Without curly braces we are allowed to take 1 statement under ‘while’, that statement never be declarative statement other wise compile time error.
* If we wrote **boolean argument as Constant value**, it leades to **“UnReachable Statement”**

<table>
  <tr>
   <td>
<strong><code>while (true) {</code></strong>
<strong><code>    System.<em>out</em>.println("hi");</code></strong>
<strong><code>}</code></strong>
<strong><code>System.<em>out</em>.println("Hello");</code></strong>
<strong>Test.java:12: error: unreachable statement                System.out.println("Hello");</strong>
<p>
<strong>                ^</strong>
   </td>
   <td><strong><code>while (false) {</code></strong>
<strong><code>    System.<em>out</em>.println("hi");</code></strong>
<strong><code>}</code></strong>
<strong><code>System.<em>out</em>.println("Hello");</code></strong>
<strong>Test.java:4: error: unreachable tatement                System.out.println("hi");</strong>
<p>
<strong>                ^</strong>
   </td>
  </tr>
</table>




* If we wrote constant expression which is never change, it leades to **infinite loop**. If **any final Constant expression**, then the next statement after while will be **“UnReachable Statement”**

<table>
  <tr>
   <td>
<strong><code>int a = 10;</code></strong>
<strong><code>int b = 20;</code></strong>
<strong><code>while(a&lt;b)</code></strong>
<strong><code>{</code></strong>
<strong><code>  System.<em>out</em>.println("Hi");</code></strong>
<strong><code>}</code></strong>
<strong><code>System.<em>out</em>.println("Hello");</code></strong>
<strong><code>Output : Hi Hi Hi …. Infinite loop, no error		</code></strong>
   </td>
   <td><strong><code><em>final</em> int a = 10;</code></strong>
<strong><code><em>final</em> int b = 20;</code></strong>
<strong><code>while(a&lt;b)</code></strong>
<strong><code>{</code></strong>
<strong><code>  System.<em>out</em>.println("Hi");</code></strong>
<strong><code>}</code></strong>
<strong><code>System.<em>out</em>.println("Hello");</code></strong>
<strong>Test.java:4: error: unreachable tatement                System.out.println("Hello");</strong>
<p>
<strong>                ^</strong>
   </td>
  </tr>
</table>


**<span style="text-decoration:underline;">2.do-while:</span>**

In the loop body has to execute at least once then we should go for do-while loop.

Syntax: **Here ‘;’ is mandatory**.


```
do
{
}while (boolean);

```



* Curly braces are optional; with out curly braces we should take only 1 statement b/w do-

while, that statement never be declarative statement`		`


<table>
  <tr>
   <td><strong><code>do</code></strong>
<strong><code>System.<em>out</em>.println("hi");</code></strong>
<strong><code>while (<span style="text-decoration:underline;">a</span>><span style="text-decoration:underline;">b</span>);</code></strong>
   </td>
   <td><strong><code>do</code></strong>
<strong><code>while(<span style="text-decoration:underline;">a</span>><span style="text-decoration:underline;">b</span>)<span style="text-decoration:underline;">;</span></code></strong>
<strong><code>//Error: <span style="text-decoration:underline;">atleaset</span> one statement required</code></strong>
   </td>
   <td><strong><code>do; </code></strong>
<strong><code>while(<span style="text-decoration:underline;">a</span>><span style="text-decoration:underline;">b</span>);</code></strong>
<strong><code>//; is valid statement</code></strong>
   </td>
  </tr>
</table>




* Like while, we will get **Unreachable statement** error, in following case

    ```
    final int a = 10;
    final int b = 20;
    do
    {
    System.out.println("Hi");
    }
    while (a<b);
    System.out.println("Hello");

    ```


**<span style="text-decoration:underline;">3.for:</span>**

The most commonly used loop



<p id="gdcalert13" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image13.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert14">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image13.png "image_tooltip")


All the 3 parts of for loop are independent of each other & optional.


```
for(; ;);  //valid
```


Curly braces are optional, with out curly braces we should take only 1 statement, that statement never be declarative statement.

**<span style="text-decoration:underline;">a. Initialization Section</span>**



* This will be executed only once
* Here we can declare multiple varibles of same type, but maultiple varibles of different types are not allowed. Because **break between the varibles leads** **to C.E**

        ```
        for (int x=10, y=20 ; ; ) // No Error
        for (int x=10, byte  y=20 ; ; ) // ERROR : error: <identifier> expected
        ```


* In the initialization section we can **take any valid java statement**, including **s.o.p** also.

        ```
        int i = 0;
        for(System.out.println("Hi"); i<5; i++)
        {
        System.out.print("Hello");
        }
        //O/p : Hi, Hello …(5 times)

        ```


**<span style="text-decoration:underline;">b. Conditional Expression</span>**



* Here We can **take any valid Conditional expression**, but result should be boolean type.
* Conditional statement is Optional; if wont specifies any thing, **default** should be **‘TRUE’**

**<span style="text-decoration:underline;">c. Increment/Decrement </span>**



* This statement also Optional.
* In this section we can **take any valid java statement**, including **s.o.p** also.
*  Unreachable Statement

<table>
  <tr>
   <td>
<strong><code>for (int i = 0; ; i++)</code></strong>
<strong><code>{</code></strong>
<strong><code>	System.<em>out</em>.println("Hello");</code></strong>
<strong><code>}</code></strong>
<strong><code>System.<em>out</em>.println("Hi");</code></strong>
<strong><code>// unreachable statement                System.out.println("Hi");</code></strong>
   </td>
   <td><strong><code>for (int i = 0;false;i++)</code></strong>
<strong><code>{</code></strong>
<strong><code>  System.<em>out</em>.println("Hello");</code></strong>
<strong><code>}</code></strong>
<strong><code>System.<em>out</em>.println("Hi");</code></strong>
<strong><code>// unreachable statement                System.out.println("Hello");</code></strong>
   </td>
   <td><strong><code>final int a = 10, b = 20;</code></strong>
<strong><code>for(int i = 0;a&lt;b; i++)</code></strong>
<strong><code>{</code></strong>
<strong><code>  System.<em>out</em>.println("Hello");</code></strong>
<strong><code>}</code></strong>
<strong><code>System.<em>out</em>.println("Hi");</code></strong>
<strong><code>// unreachable statement                System.out.println("hi");</code></strong>
   </td>
  </tr>
</table>


**Transfer Statements**

**<span style="text-decoration:underline;">1.break:</span>**

It can be used in the following places.



* **with in the loops** to come out of the loop.
* **inside switch** statement to come out of the switch.
* **If we are using break any where else, we will get a compile time error.**

        ```
        int x = 0;
        if(x!=5)
        break;
        System.out.println("if");
        C.E: error: break should not outside switch or loop

        ```


**<span style="text-decoration:underline;">2.continue:</span>**



* we should use ‘**continue’ only in the loops to skip current iteration** & continue for the next iteration.
* If we are using ‘continue’ any where except loops we will get compile time error saying, **“continue out side of loop”.**


```
for(int i=0;i<10;i++)
{
if((i%2) == 0)
continue;
System.out.print(i);
}
O/P:- 13579
```



## Fundamentals – Interview Questions

**<span style="text-decoration:underline;">Difference between interpreter and JIT compiler?</span>**

The interpreter interprets the bytecode line by line and executes it sequentially. It results in poor performance. JIT compiler add optimization to this process by analyzing the code in blocks and then prepare more optimized machine code.

**<span style="text-decoration:underline;">Difference between JRE and JVM?</span>**

JVM is the specification for runtime environment which executes the Java applications. Hotspot JVM is such one implementation of the specification. It loads the class files and uses interpreter and JIT compiler to convert bytecode into machine code and execute it.

**<span style="text-decoration:underline;">Difference Between JVM & HotSpot VM</span>**

**JVM: **is a Specification, **HotSpot **: is a implementation of JVM.** **

**[HotSpot](http://en.wikipedia.org/wiki/HotSpot) **is an implementation of the JVM concept, originally developed by Sun and now owned by Oracle. There are other implementations of the JVM specification, like [JRockit](http://en.wikipedia.org/wiki/JRockit), [IBM J9](http://en.wikipedia.org/wiki/IBM_J9), among many others.

**<span style="text-decoration:underline;">How does WeakHashMap work?</span>**

WeakHashMap operates like a normal HashMap but uses WeakReference for keys. Meaning if the key object does not hold any reference then both key/value mapping will become appropriate for garbage collection.

**<span style="text-decoration:underline;">How do you locate memory usage from a Java program?  </span>**

You can use memory related methods from **java.lang.Runtime** class to get the free memory, total memory and maximum heap memory in Java.


<table>
  <tr>
   <td><strong>public static Runtime getRuntime()</strong>
   </td>
   <td>returns the instance of Runtime class.
   </td>
  </tr>
  <tr>
   <td><strong>public void exit(int status)</strong>
   </td>
   <td>terminates the current virtual machine.
   </td>
  </tr>
  <tr>
   <td><strong>public void addShutdownHook(Thread hook)</strong>
   </td>
   <td>registers new hook thread.
   </td>
  </tr>
  <tr>
   <td><strong>public Process exec(String command)</strong>
   </td>
   <td>executes given command in a separate process.
   </td>
  </tr>
  <tr>
   <td><strong>public int availableProcessors()</strong>
   </td>
   <td>returns no. of available processors.
   </td>
  </tr>
  <tr>
   <td><strong>public long freeMemory()</strong>
   </td>
   <td>returns amount of free memory in JVM.
   </td>
  </tr>
  <tr>
   <td><strong>public long totalMemory()</strong>
   </td>
   <td>returns amount of total memory in JVM.
   </td>
  </tr>
</table>



```
public class TestApp {
	public static void main(String[] args) {
		Runtime r = Runtime.getRuntime();
		System.out.println(r.totalMemory()); //16252928
		System.out.println(r.freeMemory()); //15709576
		System.out.println(r.availableProcessors());//24
		r.gc();
	}
}
```


**<span style="text-decoration:underline;">What is ClassLoader in Java?</span>**

When a Java program is converted into **.class **file by Java compiler which is collection of byte code. **ClassLoader** is responsible to load that class file from file system, network or any other location 



* Bootstrap ClassLoader - **JRE/lib/rt.jar**
* Extension ClassLoader - **JRE/lib/ext** or any directory denoted by java.ext.dirs
* Application ClassLoader - **CLASSPATH environment variable, -classpath or -cp option, Class-Path attribute of Manifest inside [JAR file](http://javarevisited.blogspot.sg/2012/03/how-to-create-and-execute-jar-file-in.html).**

**<span style="text-decoration:underline;"> \
Java heap memory</span>**

When a Java program started Java Virtual Machine gets some memory from Operating System.

whenever we create an object using new operator or by any another means the object is allocated memory from Heap and When object dies or garbage collected, memory goes back to Heap space.

**<span style="text-decoration:underline;">How to increase heap size in Java</span>**

Default size of Heap space in Java is 128MB on most of 32 bit Sun's [JVM](http://javarevisited.blogspot.sg/2011/12/jre-jvm-jdk-jit-in-java-programming.html) but its highly varies from JVM to JVM. change size of heap space by using JVM **options -Xms and -Xmx**. Xms denotes starting size of Heap while -Xmx denotes maximum size of Heap in Java.

**<span style="text-decoration:underline;">Java Heap and Garbage Collection</span>**

As we know objects are created inside heap memory and Garbage Collection is a process which removes dead objects from Java Heap space and returns memory back to Heap in Java.

 For the sake of Garbage collection Heap is divided into three main regions named as **New Generation, Old Generation, and Perm space**

<p id="gdcalert14" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image14.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert15">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image14.png "image_tooltip")




* **New Generation** of Java Heap is part of Java Heap memory where a newly created object is stored, 
* **Old Generation** During the course of application many objects created and died but those remain live they got moved to Old Generation by Java Garbage collector thread 
* **Perm space** of Java Heap is where JVM stores Metadata about classes and methods, String pool and Class level details.
* Perm Gen stands for permanent generation which holds the meta-data information about the classes.
* Suppose if you create a class name A, it's instance variable will be stored in heap memory and class A along with static classloaders will be stored in permanent generation.
* Garbage collectors will find it difficult to clear or free the memory space stored in permanent generation memory. Hence it is always recommended to keep the permgen memory settings to the advisable limit.
* JAVA8 has introduced the concept called meta-space generation, hence permgen is no longer needed when you use jdk 1.8 versions.

**Garbage collection is performed by a daemon thread called Garbage Collector(GC). This thread calls the finalize() method before object is garbage collected.**

**The Garbage collector of JVM collects only those objects that are created by new keyword. So if you have created any object without new, you can use finalize method to perform cleanup processing (destroying remaining objects).**

**Neither finalization nor garbage collection is guaranteed.**


## Data Types

**<span style="text-decoration:underline;">How do you convert bytes to String?</span>**

you can convert bytes to the string using string constructor which accepts byte[], just make sure that right character encoding otherwise platform's default character encoding will be used which may or may not be same.


```
String str = new String(bytes, "UTF-8");
```


**<span style="text-decoration:underline;">How do you convert bytes to long in Java</span>** \
The byte takes 1 byte of memory and long takes 8 bytes of memory. Assignment 1 byte value to 8 bytes is done implicitly by the JVM.

**byte –> short –> int –> long –> float –> double**

The left-side value can be assigned to any right-side value and is done implicitly. The reverse requires explicit casting.


```
 byte b1 = 10;                 // 1 byte  
 long l1 = b1;                 //  one byte to 8 bytes, assigned implicitly
```


**<span style="text-decoration:underline;">Is ++ operator is thread-safe in Java?</span>**

No it's not a thread safe operator because its involve multiple instructions like reading a value, incriminating it and storing it back into memory which can be overlapped between multiple threads. \


**<span style="text-decoration:underline;">What will this return 3*0.1 == 0.3? true or false?</span>**

Both are not equal, because floating point arithmetic has a certain precision. Check the difference (a-b) it should be really small.

 In computer memory, floats and doubles are stored using [IEEE 754](https://en.wikipedia.org/wiki/IEEE_754) standard format. 



* f1 = (0.1+0.1+0.1….11 times) 	= 1.0999999999999999
* f2 = 0.1*11			= 1.1

In **[BigDecimal](https://docs.oracle.com/javase/7/docs/api/java/math/BigDecimal.html)** class, you can specify the rounding mode and exact precision which you want to use. Using the exact precision limit, rounding errors are mostly solved. Best part is that BigDecimal numbers are immutable i.e. if you create a BigDecimal BD with value “1.23”, that object will remain “1.23” and can never be changed. You can use it’s .compareTo() method to compare to BigDecimal numbers


```
private static void testBdEquality()
{
     BigDecimal a = new BigDecimal("2.00");
     BigDecimal b = new BigDecimal("2.0");


     System.out.println(a.equals(b));           // false


     System.out.println(a.compareTo(b) == 0);   // true
}
```


**<span style="text-decoration:underline;">Which one will take more memory, an int or Integer? (answer)</span>** \
An Integer object will take more memory an Integer is the an object and it  store meta data overhead about the object and int is primitive type so its takes less space.

**<span style="text-decoration:underline;">How to convert Primitives to Wrapper  & Wrapper to Primitive ??</span>**


```
// 1. using constructor
Integer i = new Integer(10);


// 2. using static factory method
Integer i = Integer.valueOf(10);

//3.wrapper to primitive
int val = i.intValue();    
```


 

**<span style="text-decoration:underline;">Autoboxing and Unboxing?</span>**

If a method requires Integer Object value, we can directly pass primitive value without issue. Autoboxing will take care about these.

But direct initializations it doesn’t possible.


```
Integer i = 10;// Type mismatch: cannot convert from Integer to int
int j = i;
```


**<span style="text-decoration:underline;">what if I make main() private/protected ?</span>**

 if you do not make `main()` method `public`, there is no compilation error. You will **runtime error** because matching `main()` method is not present. Remember that whole syntax should match to execute `main()` method.


```
Error: Main method not found in class Main, please define the main method as:
   public static void main(String[] args)
```



# 2.Class Declaration & Access Modifiers


## Java Source File Structure



* A java Source file can contain any no of classes but at most one class can be declared as the public.
* if there is any public class then compulsory the name of the source file and the name of the public class must be matched other wise we will get compile time error. 
* If there is no public class, then any name we can use for the source file


## Java Access Modifiers



1. **public** – accessible everywhere
2. **protected** – accessible in the same package and in sub-classes
3. **default** – accessible only in the same package
4. **private** – accessible only in the same class

**(Top most) Classes and interfaces cannot be private. **

**private members are accessible within the same class only.**

There are two levels of access control.



* **Class level** — Allowed modifiers are public, default only
* **Method level** — Allowed modifiers are public, private, protected, or package-private (default)

A class may be declared with the modifier public, in which case that class is visible to all classes everywhere. If a class has no modifier (the default, also known as package-private), it is visible only within its own package.


## Class Modifiers – Applicable only for classes


<table>
  <tr>
   <td><strong>For Top – Level Class</strong>
   </td>
   <td><strong>For Inner classes</strong>
   </td>
  </tr>
  <tr>
   <td>
<ul>

<li><strong>public</strong>

<li><strong>default</strong>

<li><strong>final</strong>

<li><strong>abstract</strong>

<li><strong>strictfp</strong>
    If we are using any other modifier we will get <strong>C.E : error: modifier private not allowed here</strong>
</li>
</ul>
   </td>
   <td>
<ul>

<li><strong>public</strong>

<li><strong>default</strong>

<li><strong>protected</strong>

<li><strong>private</strong>

<li><strong>final</strong>

<li><strong>abstract</strong>

<li><strong>strictfp</strong>

<li><strong>static</strong>
</li>
</ul>
   </td>
  </tr>
</table>


**<span style="text-decoration:underline;">final:</span>**

**final** is the modifier applicable for **classes, methods and variables**.

**1.final at Class level**

If a class declared as final, **inheritcance is not allowed**.


```
    final class P {


    }
    class C extends P {


    }
    Test.java:18: error: cannot inherit from final P
    class C extends P {
```


**2.final at Method level**

If a method declared as final, **we are not allowed to override** that method in child classes


```
    class P {
    	public final void marry() {
    		System.out.println("Bujji");
    	}
    }
    class C extends P {
    	public void marry() {
    		System.out.println("Preeti");
    	}
    }
    Test.java:21: error: marry() in C cannot override marry() in P
            public void marry() {
```


**3.final at varible level**



* If a varible declared as final, **we are not allowed to change it’ s value.**
* For the final instance variables JVM won’t provide any default values, compulsory we should perform initialization **before completion of constructor. **The following are the places to perform this
    * At the time of declaration:

        ```
        final int i = 0;
        ```


    * Inside instance initialization class

        ```
        final int i;
        {
        i = 0;
        }
        ```


    * Inside constructor

        ```
        final int i;
        test()
        {
        i = 0;
        }
        ```


    * Inside static blocks, for static final variables 

        ```
        static
        {
        i = 0;
        }
        ```


* For the local variables the only applicable modifier is final.
* Before using a local variable (whether it is final or non-final) we should perform initialization. If we are not using local variable, then no need of perform initialization even though it is final.
* Every method presents in final class by default final, but variables are not final.

**<span style="text-decoration:underline;">abstract:</span>**



* abstract modifier is applicable only for **classes and methods**, but not for variables.
* abstract method should have only declaration but not implementation hence abstract method declaration should end with ;(semicolon)

        ```
        public abstract void m1(); 	//CORRECT
        public abstract void m1(){}	//WRONG
        ```


* If a class contain at least one abstract method then the corresponding class should be declared as abstract otherwise we will get C.E.
* Even though class doesn’t contain any abstract method still we can declare that class with abstract modifier.i. e abstract class can contain zero no of abstract methods.

<table>
  <tr>
   <td>
<strong><code>class Test</code></strong>
<code>{</code>
<p>
<strong><code>  public abstract void m1()</code></strong>
<code>  {</code>
<p>
<code>  }</code>
<p>
<code>}</code>
<p>
<strong><code>C<span style="text-decoration:underline;">.</span>E: abstract methods can't have a <em>body</em></code></strong>
   </td>
   <td><strong><code>class Test</code></strong>
<code>{</code>
<p>
<strong><code>  public abstract void m1();</code></strong>
<code>}</code>
<p>
<strong><code>C.E: Test is not abstract and doesn't override abstract method m1 in Test()</code></strong>
   </td>
   <td><strong><code>abstract class Test</code></strong>
<code>{</code>
<p>
<strong><code>   public abstract void m1();</code></strong>
<code>}</code>
<p>
<strong><code>class SubTest extends Test</code></strong>
<code>{</code>
<p>
<code>}</code>
<p>
<strong><code>C.E: SubTest is not abstract and doesn't override abstract method m1() in Test.</code></strong>
   </td>
  </tr>
</table>


**<span style="text-decoration:underline;">strictfp:</span>**



* strictfp modifier is applicable only for **methods and classes** but not for variables.
* If a method declared as a strictfp **all floating point calculations in that method will follows IEEE standard so** that we can get platform independent results.
* strictfp and abstract is always illegal combination for methods, but allowd for classes
* If a class declared as strictfp all concrete methods in that class will follow IEEE standard for floating point arithmetic.


## Member modifiers – Applicable for methods & variables


<table>
  <tr>
   <td> 
<ol>
 
<li><strong>public</strong>
 
<li><strong>protected</strong>
 
<li><strong>&lt;default></strong>
 
<li><strong>private</strong>
</li> 
</ol>
   </td>
   <td> 
<ol>
 
<li><strong>final</strong>
 
<li><strong>static</strong>
 
<li><strong>native</strong>
 
<li><strong>synchronized</strong>
 
<li><strong>transient</strong>
 
<li><strong>volataile</strong>
</li> 
</ol>
   </td>
  </tr>
</table>


**1.public members**

we can access public members from any where but the corresponding class must be visible

**2.protected members**

If a member declared as protected then we can access that member from any where with in the current package and only in child classes from outside package.

**3.&lt;default> members**

If a member declared as a default, we can access that member only in the current package.

**4.private members**

If a member declared as private, we can access that member only in the current class.

**5.final members**



* A final class cannot be inherited. You cannot create subclasses of final classes.
* If a method declared as final, **we are not allowed to override** that method in child classes
* We cannot change the value of a final variable once it is initialized.

**<span style="text-decoration:underline;">6.Static</span>**

static is the modifier is applicable for methods and variables but not classes (inner classes allowed).



* **Overloading** is possible for static methods.
* **Inheritance **concept is applicable for static methods, including main().for example, while executing child class, if child class main() method is not present then parent class main() will execute.

    ```
    class A{
    	public static void main(String[] args) {
    		System.out.println("Parent class");
    	}
    }
    public class B extends A{

    }
    C:\Users\kaveti_S\Downloads\JUnitHelloWorld\src\main\java>java B
    A
    ```


* It seems Overriding concept is applicable for static methods, **but it’s not Overriding, it is “method hiding”**

    ```
    class A{
    	public static void main(String[] args) {
    		System.out.println("Parent class");
    	}
    }

    public class B extends A{
    	public static void main(String[] args) {
    		System.out.println("Child class");
    	}
    }
    C:\Users\kaveti_S\Downloads\JUnitHelloWorld\src\main\java>java A
    Parent class

    C:\Users\kaveti_S\Downloads\JUnitHelloWorld\src\main\java>java B
    Child class

    ```


**<span style="text-decoration:underline;">7.native modifier</span>**



* The methods which are implemented in non-java(like C,C++) are called “**native methods**”. The main objectives of native keyword are 
        * To improve performance of the system.
        * To communicate with already existing legacy systems.
* native is the modifier applicable only for methods , **but not classes and variables**.
* native method should end with ;(semicolon).because we are not responsible to provide implementation, it is already available.so _abstract _and _native _is _illegal combination _of modifier
* For the native methods **_overloading_**, **_Inheritance _**and **_overriding _**concepts are applicable.
* The use of native keyword breaks the platform independent nature of java.

    ```
    class Native {
    	static {
    		System.loadLibrary("Path of native library") ;// Loading the native
    														// library.
    	}

    	public native void m1(); // Declaring a native method.
    }

    class client
    {
    Native n = new Native();
    n.m1();//Invoking a native method.
    }

    ```


**<span style="text-decoration:underline;">8. Synchronized</span>**



* It is a keyword applicable only for methods and blocks. We can’t declare variables and classes with synchronized keyword.
* If a method declared as synchronized at a time only one thread is allowed to execute on the given object. Hence the main advantage of synchronized keyword is we can overcome data inconsistency problem.
* Synchronized methods are implemented methods, so abstract combination is illegal for the methods.

**<span style="text-decoration:underline;">9.Transient Modifier</span>**



* Transient is the keyword applicable only for variables, but not methods and classes.
* While performing serialization if u don’t want to save the value of a particular variable, that variable we have declared with transient keyword.
* At the time of serialization, JVM ignores the value of transient variable and saves it’s default value.

**<span style="text-decoration:underline;">10.Volatile </span>**



* Volatile keyword is used with only variable in Java
* it guarantees that value of volatile variable will always be read from main memory and not from Thread's local cache. 
* So, we can use volatile to achieve synchronization because its guaranteed that all reader thread will see updated value of volatile variable once write operation completed.
* volatile provides the guarantee, changes made in one thread is visible to others.

**What is the difference between the volatile and atomic variable in Java?** \
For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly, you have atomic version for other data type and reference variable as well.

**Conclusion **


<table>
  <tr>
   <td><strong>Modifier </strong>
   </td>
   <td><strong>Variables</strong>
   </td>
   <td><strong>Method</strong>
   </td>
   <td><strong>Top level class</strong>
   </td>
   <td><strong>Inner class</strong>
   </td>
   <td><strong>Blocks</strong>
   </td>
   <td><strong>constructor</strong>
   </td>
  </tr>
  <tr>
   <td><strong>public</strong>
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
  </tr>
  <tr>
   <td><strong>&lt;default></strong>
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
  </tr>
  <tr>
   <td><strong>protected</strong>
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
  </tr>
  <tr>
   <td><strong>private</strong>
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
  </tr>
  <tr>
   <td><strong>abstract</strong>
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
  </tr>
  <tr>
   <td><strong>final</strong>
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
  </tr>
  <tr>
   <td><strong>strictfp</strong>
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
  </tr>
  <tr>
   <td><strong>synchronized</strong>
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
  </tr>
  <tr>
   <td><strong>native</strong>
   </td>
   <td>🗷
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
  </tr>
  <tr>
   <td><strong>transient</strong>
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
  </tr>
  <tr>
   <td><strong>volatile</strong>
   </td>
   <td>🗹
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
   <td>🗷
   </td>
  </tr>
</table>



## Nested Classes


<table>
  <tr>
   <td><strong>Type</strong>
   </td>
   <td>Description
   </td>
  </tr>
  <tr>
   <td><strong><a href="http://www.smlcodes.com/java/vi-java-inner-classes/">Inner Class</a></strong>
   </td>
   <td>A class created within class and outside method.
   </td>
  </tr>
  <tr>
   <td><strong><a href="http://www.smlcodes.com/java/vi-java-inner-classes/">Static Nested Class</a></strong>
   </td>
   <td>A static class created within class and outside method.
   </td>
  </tr>
  <tr>
   <td><strong><a href="http://www.smlcodes.com/java/vi-java-inner-classes/">Local Inner Class</a></strong>
   </td>
   <td>A class created within method.
   </td>
  </tr>
  <tr>
   <td><strong><a href="http://www.smlcodes.com/java/vi-java-inner-classes/">Anonymous Inner Class</a></strong>
   </td>
   <td>A class created for implementing interface or extending class. Its name is decided by the java compiler.
   </td>
  </tr>
  <tr>
   <td><strong><a href="http://www.smlcodes.com/java/vi-java-inner-classes/">Nested Interface</a></strong>
   </td>
   <td>An interface created within class or interface.
   </td>
  </tr>
</table>



#### 1. Member Inner Classes

If a non-static class is created in the class & outside the method is known as “Member Inner class”. Because it is just a member of that class

**<span style="text-decoration:underline;">Example : </span>**

public class Outer{    

    int a =100;

    String msg="Iam Outer Class";    

    class Inner{

        int b=200;

        String inmsg="Inner class variable";

        public void show(){

            System.out.println(b+"\n"+inmsg+"\n"+msg);

        }

    }

  public static void main(String []args){

        Outer o = new Outer();

       Outer.Inner i = o.new Inner();

       i.show();

     }

}

**Internal Working**

**1.** **instance of inner class is created inside the instance of outer class.**

The java compiler creates two class files in case of inner class. The class file name of inner class is** "Outer$Inner".For **Outer.java it will create 2 .class files



* Outer$Inner.class 
* Outer.class  
* For creating normal class object we do 

         **OuterClass ob = new OuterClass();**

* For creating inner class object we have to add OuterClass class & Object as below **OuterClass.InnerClass i = o.new InnerClass();**

        

<p id="gdcalert15" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image15.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert16">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image15.jpg "image_tooltip")



**Outer$Inner.Java Generated code**

import java.io.PrintStream;

class Outer.Inner {

 int b;

 String inmsg;

 Outer.Inner() {

  this.b = 200;

  this.inmsg = "Inner class variable";

 }

 public void show() {

  System.out.println("" + this.b + "\n" + this.inmsg + "\n" + Outer.this.msg);

 }

}


#### 2. Static Nested Classes (Nested Classes)

If a Static class is created inside Outer class is know as Static Nested class



* **Non Static Data Members/Methods	**: it **Cannot** assess  directly
* **Static Data Members** 			:  it **Can** access 

**Example**


```
public class StaticNestedDemo {
	int a = 100;
	static int b = 200;
	static class Inner {
		static void get() {
			System.out.println("B " + b);
		// a -Cannot make a static reference to the non-static field a
		}
	}
	public static void main(String[] args) {
		StaticNestedDemo.Inner ob = new StaticNestedDemo.Inner();
		ob.get();
		// ditectly
		StaticNestedDemo.Inner.get();
	}
}
B 200
B 200
```



#### 3. Local Inner Classes

If a class is created inside the method is known as “Local Inner Class”



* Local class variable should **not Private, Public and Protected**
* Local inner **class cannot be invoked from outside of the method**.
* Local Inner class only access Final variables from outside class(until 1.7 , from 1.8 they can access non-final also)

**Example : Local.java**

public class Local {

 public void get() {

  System.out.println("Get Method");

  int a = 100;

  class Inner {

   public void show() {

    System.out.println(a);

   }

  }

  Inner ob = new Inner();

  ob.show();

 }

 public static void main(String ar[]) {

  Local ob = new Local();

  ob.get();

 }

}


```
Get Method                                                                                                                                                            
100
```



#### 4. Anonymous Inner Classes

If a class doesn’t have any Name, such type of classes are noted as Anonymous Inner classes.in real time two types of Anonymous inner classes we may implement

**Class** : If method of one class may return Instance we can directly implement and will get the Object

**Interface**: at same way a method of interface return object we directly implement to get the object

**Example**


```
interface A {
	public void aShow();
}

abstract class B {
	abstract void bShow();
}

public class AnnonymousDemo {

	A a = new A() {
		@Override
		public void aShow() {
			System.out.println("A show()");
		}
	};

	B b = new B() {
		@Override
		void bShow() {
			System.out.println("B show()");
		}
	};

	public static void main(String[] args) {
		AnnonymousDemo demo = new AnnonymousDemo();
		demo.a.aShow();
		demo.b.bShow();
	}
}
A show()
B show()
```


**Internal Working**

1.If we use anonymous inner class in our main class, internally it creates the new inner class with name **MainClass$X(x is a number)** which is 



* **Extends** in case of **Class**
* **Implements** in case of **Interface** 

In above class the complile generates Anonymous inner class as below

**Class A : Inner class**


```
class AnnonymousDemo$1  implements A
{
  AnnonymousDemo$1(AnnonymousDemo paramAnnonymousDemo) {}


  public void aShow()
  {
    System.out.println("A show()");
  }
}
```


**Class B : Inner Class**


```
class AnnonymousDemo$2  extends B
{
  AnnonymousDemo$2(AnnonymousDemo paramAnnonymousDemo) {}


  void bShow()
  {
    System.out.println("B show()");
  }
}
```


2.If we want to create the Object for inner class we must use outer class object . because inner classes are generated inside of outer class


```
AnnonymousDemo demo = new AnnonymousDemo();
		demo.a.aShow();
		demo.b.bShow();
```



# 3. Interfaces



* We can declare interface by **‘interface’** keyword & implementing using **‘implemets’** keyword. The allowed modifiers for interface are

    ```
    public
    abstract
    strictfp
    <default>
    ```


* When ever a class implementing an interface we should provide the implementation for all the interface methods. Other wise the class must be declared that class as abstract. Violation leads to compile time error.
* By default, all interface methods are **‘public abstract’** & variables are **‘public static final’.**
* When ever we are implementing an interface method compulsory we should declare that method as public, otherwise we will get compile time error.

    ```
    interface sample {
    	void m1();
    }

    class Test implements sample {
    	void m1() {
    	}
    }
    Test.java:13: error: m1() in Test cannot implement m1() in sample
            void m1() {
                 ^
      attempting to assign weaker access privileges; was public
    1 error
    ```


* Every interface variable is by default **public static and final.** Hence the following declarations are equal inside interface.

    ```
    int i = 10;
    public int i = 10;
    public static int i = 10;
    public static final int i = 10;
    ```


* For interface variables we should perform initialization at the time of Declaration only.

    ```
    interface inter
    {
    int i;  C.E = expected.
    }
    ```


* interface variables are by default available in the implemented classes. From the implementation classes we are allowed to access but not allowed to change their values i.e reassignment is not possible because these are final.

    ```
    interface inter {
    	int i = 10;
    }

    class test implements inter {
    	public static void main(String arg[]) {	
    		i=20;
    		System.out.println(inter.i);
    	}
    }
    B.java:7: error: cannot assign a value to final variable i
                    i=20;
                    ^

    ```


**<span style="text-decoration:underline;">Naming conflicts in interfaces</span>**



* If two interfaces contain a method with same signature and same return type in the implementation class, only one method implementation is enough

    ```
    interface Left {
    	void m1();
    }

    interface Right {
    	void m1();
    }

    class Test implements Left, Right {
    	public void m1() {
    		System.out.println("method");
    	}
    

    	public static void main(String[] args) {
    		Left l = new Test();
    		l.m1();
    

    		Right r = new Test();
    		r.m1();
    	}
    }
    method
    method
    ```


* If two interfaces contain a method with **same signature but different return type,** then we can’t implement those two interfaces simultaneously.

    ```
    interface Left {
    	void m1();
    }

    interface Right {
    	int m1();
    }

    class Test implements Left, Right {
    	public void m1() {
    		System.out.println("void");
    	}
    

    	public int m1() {
    		System.out.println("void");
    	}	 
    }
    Test.java:10: error: m1() in Test cannot implement m1() in Right
            public void m1() {
                        ^
      return type void is not compatible with int

    ```


**<span style="text-decoration:underline;">Marker Interface</span>**

an interface which doen’t contain any methods, treated as ‘Marker’ interface

By implementing an interface if our objects will get some special ability(features), such type of interfaces are called “_marker_” or _“taginterface”._

Ex: Serializable, Clonable interfaces are marked for some ability.


## Interface Enhancements

**<span style="text-decoration:underline;">interface Default Methods: Java 8</span>**

Java 8 allows you to add non-abstract methods in interfaces. These methods must be declared **default** keyword.

Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.


```
interface Vehicle {
	default void move() {
		System.out.println("Def. move");
	}
}

class Car implements Vehicle {


}

class Bus implements Vehicle{
	@Override
	public void move() {
	System.out.println("Bus. Move");
	}
}

public class Test{
	public static void main(String[] args) {
		new Car().move();
		new Bus().move();
	}
}
Def. move
Bus. Move

```



* `Vehicle` interface defines a method `move()` and provided a default implementation as well. If any class implements this interface then it need not to implement it’s own version of `move()` method. It can directly call `instance.move()`. 
* If class willingly wants to customize the behavior of move() method then it can provide it’s own custom implementation and override the method by removing **‘default’ **keyword

**<span style="text-decoration:underline;">interface Static Methods: Java 8</span>**

Java interface static method is similar to default method except that **we can’t override them in the implementation classes**. This feature helps us in avoiding inconsistant results incase of poor implementation in implementation classes


```
interface Vehicle {
	default void move() {
		System.out.println("Def. move");
	}
	static void year(){
		System.out.println("Def. 1998");
	}
}

class Test implements Vehicle{
	@Override
	public void move() {
	System.out.println("Bus. Move");
	}
	static void year(){
		System.out.println("2018");
	}
	public static void main(String[] args) {
		Vehicle.year();
		year();
	}
}
Def. 1998
2018
```


Note that year() is a simple class method, it’s not overriding the interface method. For example, if we will add [@Override annotation](https://www.journaldev.com/817/java-override-annotation) to the year() method, it will result in compiler error.

**<span style="text-decoration:underline;">Interface Private Methods – Java 9</span>**

private methods will improve code re-usability inside interfaces. For example, if two default methods needed to share code, a private interface method would allow them to do so, but without exposing that private method to it’s implementing classes.

Using private methods in interfaces have four rules:



* Private interface method cannot be abstract.
* Private method can be used only inside interface.
* Private static method can be used inside other static and non-static interface methods.
* Private non-static methods cannot be used inside private static methods.


```
public interface Calculator
{
    default int addEvenNumbers(int... nums) {
        return add(n -> n % 2 == 0, nums);
    }


    default int addOddNumbers(int... nums) {
        return add(n -> n % 2 != 0, nums);
    }


    private int add(IntPredicate predicate, int... nums) {
        return IntStream.of(nums)
                .filter(predicate)
                .sum();
    }
}
```


**<span style="text-decoration:underline;">Functional Interfaces</span>**

Functional interfaces are also called _Single Abstract Method interfaces (SAM Interfaces)_. As name suggest, they permit exactly one abstract method inside them. 

Java 8 introduces an annotation i.e. `@FunctionalInterface` which can be used for compiler level errors when the interface you have annotated violates the contracts of Functional Interface.


```
@FunctionalInterface
public interface Test {
    public void firstWork();
}
```


Please note that a functional interface is valid even if the `@FunctionalInterface` annotation would be omitted. It is only for informing the compiler to enforce single abstract method inside interface.


# 4.OOPS


## 1.Data Hiding 

Hiding of data, so that out side persion can’t access our data. The main advantage of data hiding is we can achieve security.

using **‘private’ modifier** we can achive data hiding.


```
class datademo
{
private double amount;
………
}
```



## 2.Abstraction

Hiding implementation details is nothing but abstraction. The main advantages of abstraction are we can achieve **security **as we are not highlighting internal implementation.

using **interfaces & abstract classes** we can achive data Abstarction.


## 3. Encapsulation

Wrapping data and methods with in classes in combination with implementation **hiding** (through access control) is often called encapsulation.

If a class follows data hiding and abstraction such type of class is said to be ‘Encapsulated’ class. **Encapsulation = Data Hiding + Abstraction**

**Abstraction VS Encapusulation **



* Abstraction is more about ‘**What**‘a class can do. [**Idea**]
* Encapsulation is more about ‘**How**‘to achieve that functionality. [**Implementation**]


```
class Account {
	private int balance;

	public void setBalance(int balance) {
		// validating the user & his permissions.
		this.balance = balance;
	}

	public int getBalance() {
		// validating the user and his permissions.
		return balance;
	}
}
```


**Encapsulation essentially has both i.e. information hiding and implementation hiding.**

**<span style="text-decoration:underline;">Tightly Encapsulated Class</span>**

A class is said to be tightly encapsulated iff **all the data members declared as private**.



* The data memebers should private, getters, setters & other methods are not required to be private.
* if the parent class is not tightly encapsulated then no child class is tightly encapsulated.

    ```
    class x {
    	int i = 0;
    }

    class y extends x {
    	//int i -> hides as public
    	private int j = 20;
    }

    class z extends y {
    	//int i -> hides as public
    	private int k = 30;
    }

    ```



## 4. Inheritance

**<span style="text-decoration:underline;">IS-A Relationship</span>**



* Also known as **‘Inheritance’.**
* By using **extends** keyword we can implement inheritance.
* The main advantage is reusability.

    ```
    class P {
    	public void m1() {
    		System.out.println("Parent method");
    	}
    }

    class C extends P {
    	public void m1() {
    		System.out.println("Child method");
    	}
    }
    public class Test {
    	public static void main(String[] args) {
    		C p = new C();
    		p.m1();
    	}
    }
    Child method
    ```


* Every java class is a direct Child class of ‘Object’ class

    ```
    Object
       |
    Class A
    ```


* If our java class extends any other class, then it is indirect child class of Object

    ```
        Object
           |    
       Class B
           |
    Class A extends B
    ```


* Cycic inheritance is not allowed in java

    ```
    class A extends B{ 
    

    }

    class B extends A{
    

    }
    Test.java:3: error: cyclic inheritance involving A
    class A extends B{
    ^
    1 error

    ```


**<span style="text-decoration:underline;">Has-A Relationship</span>**

Has-a relationship is one in which an **object of one class is created as a data member in another class**.


```
class Student
{
  int sno;
  String name;
  Address address; 
}
```


**<span style="text-decoration:underline;">Uses-A Relationship</span>**

Uses-a relationship is one in which an **Object of one class is created inside a method of another class.**


```
class Student {
	int sno;
	String name;

	public static void main(String[] args) {
		Address address = new Address();
	}
}
```


[Association, Aggregation and Composition](https://howtodoinjava.com/oops/association-aggregation-composition/)?

**Association**: We call association those relationships whose objects have an independent lifecycle and where there is **no ownership between the objects**.

Let’s take an example of a teacher and student. Multiple students can associate with a single teacher, and a single student can associate with multiple teachers, but both have their own lifecycles (both can be create and delete independently); **so when a teacher leaves the school, we don’t need to delete any students, and when a student leaves the school, we don’t need to delete any teachers**.



<p id="gdcalert16" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image16.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert17">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image16.jpg "image_tooltip")


**Aggregation: **We call aggregation those relationships whose objects have an **independent lifecycle, but there is ownership**, and child objects cannot belong to another parent object.

Let’s take an example of a cell phone and a cell phone battery. A single battery can belong to a phone, but if the phone stops working, and we delete it from our database, the phone battery will not be deleted because it may still be functional. So in aggregation, while there is ownership, objects have their own lifecycle.



<p id="gdcalert17" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image17.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert18">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image17.jpg "image_tooltip")


**Composition: **We use the term composition to refer to relationships whose **objects don’t have an independent lifecycle**, and if the parent object is deleted, all child objects will also be deleted.

Let’s take an example of the relationship between questions and answers. Single questions can have multiple answers, and answers cannot belong to multiple questions. If we delete questions, answers will automatically be deleted.



<p id="gdcalert18" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image18.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert19">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image18.jpg "image_tooltip")


 

**<span style="text-decoration:underline;">Overloading</span>**

Two methods are said to be overloaded, iff the method names are same, but arguments are different.


```
class Test {
	public void m1() {
		System.out.println("no-args");
	}
	public void m1(int i) {
		System.out.println("int-args");
	}
	public void m1(double d) {
		System.out.println("double-args");
	}

	public static void main(String[] args) {
		Test t = new Test();
		t.m1();
		t.m1(10);
		t.m1(10.5f); // Pramoted to next level
	}
}
no-args
int-args
double-args
```


The overloading method resolution is the responsibility of compiler based on reference type and method arguments. Hence overloading is considered as **compile-time polymorphism**



* In the case of overloading if there is no method with the required argument then the compiler won’t raise immediately compile time error. First it will promote arguments to next level and checks is there any matched method with promoted arguments, if there is no such method compiler will promote the argument to the next level and checks for the matched method. After all possible promotions still the compiler unable to find the matched method then it raises compile time error.
* In the case of overloading the more specific version will get the chance first. If Specfific version is not avaible **Child version will get more priotity than Parent version**

    ```
    class Test {
    	public void m1(String s) {
    		System.out.println("String Version");
    	}

    	public void m1(Object o) {
    		System.out.println("Object Version");
    	}

    	public static void main(String arg[]) {
    		Test t = new Test();
    		t.m1("raju"); // String Version
    		t.m1(new Object());// Object Version
    		t.m1(null); // String(child) 🡪 Object(parent)
    	}
    }
    String Version
    Object Version
    String Version
    ```


* In case of Same level of Child classes available, it will** thows Abiguty error** 

    ```
    class Test {
    	public void m1(String s) {
    		System.out.println("String Version");
    	}

    	public void m1(StringBuffer o) {
    		System.out.println("StringBuffer Version");
    	}

    	public static void main(String arg[]) {
    		Test t = new Test();
    		t.m1("raju"); // String Version
    		t.m1(null); // Ambiguty Version
    

    	}
    }
    Test.java:13: error: reference to m1 is ambiguous
                    t.m1(null); // Ambiguty Version
                     ^
      both method m1(String) in Test and method m1(StringBuffer) in Test match: 1 error
    ```


* var-arg method will always get least priority i.e if no other method matched then only var-arg method will get chance for execution

**<span style="text-decoration:underline;">Overriding</span>**

If the child class is not satisfied with the parent class implementation then the child is allowed to overwrite that parent class method to provide it’s own specific implementation, this concept is nothing but **_“overriding”_.**

Rules

**#1:** **Only inherited methods can be overridden.**

**#2:** **Final and static methods cannot be overridden.**

[private](http://java67.blogspot.sg/2012/08/can-we-override-private-method-in-java.html), [static](http://java67.blogspot.sg/2012/08/can-we-override-static-method-in-java.html) and [final method](http://javarevisited.blogspot.sg/2011/12/final-variable-method-class-java.html) can not be overridden in Java. By the way, **you can hide private and static method** but trying to override final method will result in compile time error "Cannot override the final method from a class"


<table>
  <tr>
   <td><strong><code>class P {</code></strong>
<code>	<strong>public</strong> <strong>final</strong> <strong>void</strong> m1(){</code>
<code>		System.<strong><em>out</em></strong>.println("m1");	</code>
<code>	}</code>
<p>
<code>}</code>
<p>
<strong><code>class Test extends P {</code></strong>
<code>	<strong>public</strong>	<strong>void</strong> m1() {</code>
<code>	 }</code>
<p>
<code>}</code>
   </td>
   <td><strong><code>class P {</code></strong>
<code>	<strong>public</strong> <strong>static</strong> <strong>void</strong> m1(){</code>
<code>		System.<strong><em>out</em></strong>.println("m1");	</code>
<code>	}</code>
<p>
<code>}</code>
<p>
<strong><code>class Test extends P {</code></strong>
<code>	<strong>public</strong> void m1(){</code>
<code>		</code>
<p>
<code>	 }</code>
<p>
<code>}</code>
   </td>
  </tr>
  <tr>
   <td><strong><code>Test.java:8: error: m1() in Test cannot override m1() in P</code></strong>
<strong><code>        public  void m1(){</code></strong>
<strong><code>                     ^</code></strong>
<strong><code>  overridden method is final</code></strong>
<strong><code>1 error</code></strong>
   </td>
   <td><strong><code>Test.java:8: error: m1() in Test cannot override m1() in P</code></strong>
<strong><code>        public  void m1(){</code></strong>
<strong><code>                     ^</code></strong>
<strong><code>  overridden method is static</code></strong>
<strong><code>1 error</code></strong>
   </td>
  </tr>
</table>


**#3: The overriding method must have same return type (or Child type/subtype/Covariant).**


```
class P{
	public Object m1(){
		return null;	
	}
}
class Test extends P {
	public String m1(){
		return null;
	 }
}
```


**#4**: **The overriding method must not have more restrictive access modifier.**


```
class P{
	public String m1(){
		return null;	
	}
}

class Test extends P{
	protected  String m1(){
		return null;
	 }
}
Test.java:8: error: m1() in Test cannot override m1() in P
        protected String m1(){
                          ^
  attempting to assign weaker access privileges; was public
1 error
```


**#5**: **The overriding method must not throw new or broader CheckedExceptions.It can have allowed to throw Child Exceptions or remove throws keyword from method signature.**


```
class P{
	public String  m1() throws IOException{
		return null;	
	}
}
class Test extends P{
	public String m1() throws Exception{
		return null;
	 }
}
Test.java:10: error: m1() in Test cannot override m1() in P
        public String m1() throws Exception{
                      ^
  overridden method does not throw Exception : 1 error
```


**Confusing Cases**



* final method can’t be overridden in child classes. Private methods are not visible in the child classes. Hence they won’t participate in overriding. Based on our requirement we can take exactly same declaration in child class, But It is not overriding.
* A static method can’t be overridden as non-static non-static method can’t be overridden as static method
* If both parent and child class methods are static, then there is no compile time error or run time error it seems that overriding is happened but it is not overriding this concept is called “method hiding”. All the rules of method hiding are exactly similar to overriding, except both methods declared as static.
* In the case of method hiding method resolution will take care by compiler based on reference type(But not runtime object).
* Overriding concept is not applicable for variables. And it is applicable only for methods. Variable resolution always takes care by compiler based on reference type

    ```
    class P {
    	int i = 888;
    }
    class C extends P {
    	int i = 999;
    }
    class Test {
    	public static void main(String arg[]) {
    		// Case1:
    		P p = new P();
    		System.out.println(p.i); // 888

    		// Case2:
    		C c = new C();
    		System.out.println(c.i); // 999

    		// Case3:
    		P p1 = new C();
    		System.out.println(p1.i); // 888
    	}
    }

    ```



## 4. Static & Instace Control flows

**<span style="text-decoration:underline;">static Blocks</span>**

If we want to perform some activity at the time of class loading, Then we should define that activity at static blocks because these (static blocks) will execute at the time of class loading only.

We have to load native libraries at the time of class loading. Hence we have to define this activity inside the “_static block_”.


```
class Native
{
static
{
System.loadLibrary("native Library path");
}
}
```


**<span style="text-decoration:underline;">Static Control Flow</span>**

whenever child class being loaded automatically its parent classes will be loaded 



1. **Identifying the static members** from parent to child (top to bottom).
2. Execution of **static variable assignments & static blocks** from parent to child.
3. Execution of child class main method

During these phases there is one such state called RIWO(Read Indirectly Write Only) for a static variable.

**<span style="text-decoration:underline;">Read Indirectly Write Only</span>**

If a variable is RIWO state , we can’t perform Read operation Directly, if we try to do that it will throw Compiletime Error : **illegal forward reference**


<table>
  <tr>
   <td><strong><code>public class Test{</code></strong>
<code>	</code>
<p>
<code>	<strong>static</strong> <strong>int</strong> <em>x</em> = 10;</code>
<code>	<strong>static</strong> {</code>
<code>		System.<strong><em>out</em></strong>.println(<em>x</em>);</code>
<code>	}</code>
<p>
<code>}</code>
   </td>
   <td><strong><code>public class Test{</code></strong>
<code>	<strong>static</strong> {</code>
<code>		System.<strong><em>out</em></strong>.println(<em>x</em>);</code>
<code>	}</code>
<p>
<code>	<strong>static</strong> <strong>int</strong> <em>x</em> = 10;</code>
<code>}</code>
   </td>
  </tr>
  <tr>
   <td><strong>Output : 10</strong>
   </td>
   <td><strong><code>Test.java:5: error: illegal forward reference</code></strong>
<strong><code>                System.out.println(x);</code></strong>
<strong><code>                                   ^</code></strong>
   </td>
  </tr>
</table>




<p id="gdcalert19" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image19.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert20">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image19.png "image_tooltip")


To resolve this, instead of direct read, we should go for indirect read. Line use method in-between.


```
public class Test{
	static {
		m1();
	}
	static void m1(){
		System.out.println(x);
	}
	static int x = 10;
}
Output : 0
```


**Static Control flow example**


```
class Base {
	static int x = 10;

	static {
		m1();
		System.out.println("Base Class : static block");
	}


public static void main(String[] args) {
		m1();
		System.out.println("Base Class : Main method");
	}	
public static void m1() {
		{
			System.out.println("y ==>" + y);
		}
	}
	static int y = 20;
}

class Derived extends Base {
	static int i = 100;

	static {
		m2();
		System.out.println("Derived Class : Static block");
	}

	public static void main(String[] args) {
		m2();
		System.out.println("Derived Class : Main method");
	}

	public static void m2() {
		System.out.println("j ==> " + j);
	}

	static {
		System.out.println("Derived Class : Static block at the end");
	}
	static int j = 200;
}

C:\Users\src\main\java>java Base
y ==>0
Base Class : static block
y ==>20
Base Class : Main method

C:\Users\src\main\java>java Derived
y ==>0
Base Class : static block
j ==> 0
Derived Class : Static block
Derived Class : Static block at the end
j ==> 200
Derived Class : Main method
```


**<span style="text-decoration:underline;">Instance Control flow</span>**

static control flow is only one-time activity and it will be performed at the time of class loading but instance control flow is not one-time activity for every object creation it will be executed. 

When ever we care tring to create child class object, the following events will be performed autopmatically.

**1.Identification of instance members from parent to child (top to bottom).**

**2.Parent Class**



* Execution of instance variables assignments and instance blocks only in parent class.
* Execution of parent class constructor.

**3.Child Class**



* Execution of instance variables assignments and instance blocks only in child class.
* Execution of child class constructor. 

All static initializers are executed in textual order in which they appear, and execute before any instance initializers.


```
class Parent {
	int i = 10;
	{
		System.out.println("First parent Instance block");
	}

	Parent() {
		m1();
		System.out.println("Parent Constructor");
	}

	public static void main(String[] args) {
		Parent p = new Parent();
		System.out.println(" parent main");
	}

	public void m1() {
		System.out.println(j);
	}

	static {
		System.out.println("parent static block");
	}

	int j = 20;
}

class Child extends Parent {
	int x = 20;

	{
		m2();
		System.out.println("First child Instance block");
	}

	Child() {
		System.out.println("Child Constructor");
	}

	public static void main(String[] args) {
		Child c = new Child();
		System.out.println(" Child main");
	}

	public void m2() {
		System.out.println(y);
	}

	{
		System.out.println("Second child instance block");
	}

	int y = 200;
}

C:\Users\kaveti_S\Downloads\JUnitHelloWorld\src\main\java>java Parent
parent static block
First parent Instance block
20
Parent Constructor
parent main

C:\Users\kaveti_S\Downloads\JUnitHelloWorld\src\main\java>java Child
parent static block
First parent Instance block
20
Parent Constructor
0
First child Instance block
Second child instance block
Child Constructor
Child main
```


**<span style="text-decoration:underline;">Cobining Both</span>**

**1.Identification of static & instance members from parent to child (top to bottom).**

**2. **Execution **of static variable assignments & static blocks** from parent to child**.**

**3.Parent Class**



* Execution of instance variables assignments and instance blocks only in parent class.
* Execution of parent class constructor.

**4.Child Class**



* Execution of instance variables assignments and instance blocks only in child class.
* Execution of child class constructor. 

 


## 5. Constructor

At the time of Object Creation some peace of code will execute automatically to perform initialization that peace of code is nothing but “**_Constructor_**”. Hence the main Objective of constructor is to perform initialization.

**<span style="text-decoration:underline;">Rules for writing Constructor</span>**



* The name of the constructor and name of the class must be same.
* The only allowed modifiers for the constructors are **public, private, protected, &lt;default>.** If we are using any other modifier we will get **C.E(Compiler Error).**

    ```
    class Test
    {
    static Test()
    {
    ----
    }
    }
    C.E:- modifier static not allowed here.
    ```


* return type is not allowed for the constructors even void also. If we are declaring return type, then the compiler treats it as a method and hence there is no C.E and R.E(RuntimeError).

    ```
    class Test
    {
    void Test()
    {
    System.out.println("Hai .....");
    }
    public static void main(String arg[])
    {
    Test t = new Test();
    }
    }
    ```


* If we are not writing any constructor, then the compiler always **generate default constructor**.
* If we are writing at least one constructor, then **the compiler won’t generate any constructor**. Hence every class contains either programmer written constructor or compiler generated default constructor but not both simultaneously.

<table>
  <tr>
   <td>
<strong>Programmer Code</strong>
   </td>
   <td><strong>Compiler Code</strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>class Test{</code></strong>
<strong><code>}</code></strong>
   </td>
   <td><strong><code>class Test {</code></strong>
<strong><code>	Test() {</code></strong>
<strong><code>		super();</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>public class Test {</code></strong>
<strong><code>}</code></strong>
   </td>
   <td><strong><code>public class Test {</code></strong>
<strong><code>	public Test() {</code></strong>
<strong><code>		super();</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>class Test {</code></strong>
<strong><code>	private Test() {</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
   <td><strong><code>class Test {</code></strong>
<strong><code>	private Test() {</code></strong>
<strong><code>		super();</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>class Test {</code></strong>
<strong><code>	void Test() {</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
   <td><strong><code>class Test {</code></strong>
<strong><code>	void Test() {</code></strong>
<strong><code>	}</code></strong>
<strong><code>	Test() {</code></strong>
<strong><code>		super();</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>class Test {</code></strong>
<strong><code>	Test() {</code></strong>
<strong><code>		this(10);</code></strong>
<strong><code>	}</code></strong>
<strong><code>	Test(int i) {</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
   <td><strong><code>class Test {</code></strong>
<strong><code>	Test() {</code></strong>
<strong><code>		this(10);</code></strong>
<strong><code>	}</code></strong>
<strong><code>	Test(int i) {</code></strong>
<strong><code>		super();</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>class Test {</code></strong>
<strong><code>	Test(int i) {</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
   <td><strong><code>class Test {</code></strong>
<strong><code>	 </code></strong>
<strong><code>	Test(int i) {</code></strong>
<strong><code>		super();</code></strong>
<strong><code>	}</code></strong>
<strong><code>}</code></strong>
   </td>
  </tr>
</table>




* **<span style="text-decoration:underline;">super() & this() in constructor</span>**
* we should use as first statement in constructor. 
* We can use either super or this but not both simultaneously. 
* we can invoke a constructor directly from another constructor only
* Inheritance concept is not applicable for constructor, so overriding is also not applicable
* Recursive Constuctor invocation leads to Compiletime Exception.

    ```
    class Test {
    	Test() {
    		this(10);
    	}

    	Test(int i) {
    		this();
    	}	 
    }
    Test.java:6: error: recursive constructor invocation
            Test(int i) {
            ^
    1 error
    ```


* when ever we are writing parameterized constructor, it is recomended to provide no-arument constructor as well. If parent class contains parameterized constructor, then while writing child class constructor we should take a bit care

    ```
    class p {
    	p(int i) {
    	}
    }

    class c extends p
    {
    	//no-arg not defiend
    }
    Test.java:6: error: constructor p in class p cannot be applied to given types;
    class c extends p
    ^
    ```


* If the parent class constructor throws **checked exception**, Compulsory the child class constructor should throw the same checked exception or it’s parent other wise we will get compile time error

    ```
    class p {
    	p() throws IOException {
    	}
    }

    class c extends p {
    	c() {
    		super();
    	}
    }
    Test.java:10: error: unreported exception IOException; must be caught or declared to be thrown
                    super();
                         ^
    ```


* If the parent class constructor throws **unchecked exception,** then child class constructor **not required to throw that exception.**


## Java OOPs Concepts 

Return type of method is not part of method signature, so just changing the return type will not overload a method in Java.  In fact, just changing the return type will result in compile time error as "duplicate method X in type Y 

<p id="gdcalert20" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image20.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert21">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image20.png "image_tooltip")


**<span style="text-decoration:underline;"> Overring rules </span>**

**Rule #1:** **Only inherited methods can be overridden.**

**Rule #2:** **Final and static methods cannot be overridden.**

[private](http://java67.blogspot.sg/2012/08/can-we-override-private-method-in-java.html), [static](http://java67.blogspot.sg/2012/08/can-we-override-static-method-in-java.html) and [final method](http://javarevisited.blogspot.sg/2011/12/final-variable-method-class-java.html) can not be overridden in Java. See other articles in this blog to learn why you cannot override private, static or final method in Java. By the way, you can hide private and static method but trying to override final method will result in compile time error "Cannot override the final method from a class" 

<p id="gdcalert21" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image21.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert22">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image21.png "image_tooltip")
** \
 \
**

**Rule #3 :The overriding method must have same return type (or subtype/Covariant ).**

**Rule #5**: **The overriding method must not have more restrictive access modifier**



<p id="gdcalert22" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image22.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert23">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image22.png "image_tooltip")


**Rule #6**: **The overriding method must not throw new or broader CheckedExceptions.**



<p id="gdcalert23" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image23.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert24">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image23.png "image_tooltip")


**[Association, Aggregation and Composition](https://howtodoinjava.com/oops/association-aggregation-composition/)<span style="text-decoration:underline;">?</span>**

**Association** : We call association those relationships whose objects have an independent lifecycle and where there is **no ownership between the objects**.

Let’s take an example of a teacher and student. Multiple students can associate with a single teacher, and a single student can associate with multiple teachers, but both have their own lifecycles (both can be create and delete independently); so when a teacher leaves the school, we don’t need to delete any students, and when a student leaves the school, we don’t need to delete any teachers.



<p id="gdcalert24" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image24.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert25">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image24.jpg "image_tooltip")


**Aggregation: **We call aggregation those relationships whose objects have an **independent lifecycle, but there is ownership**, and child objects cannot belong to another parent object.

Let’s take an example of a cell phone and a cell phone battery. A single battery can belong to a phone, but if the phone stops working, and we delete it from our database, the phone battery will not be deleted because it may still be functional. So in aggregation, while there is ownership, objects have their own lifecycle.



<p id="gdcalert25" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image25.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert26">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image25.jpg "image_tooltip")


**Composition: **We use the term composition to refer to relationships whose objects don’t have an independent lifecycle, and if the parent object is deleted, all child objects will also be deleted.

Let’s take an example of the relationship between questions and answers. Single questions can have multiple answers, and answers cannot belong to multiple questions. If we delete questions, answers will automatically be deleted.



<p id="gdcalert26" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image26.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert27">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image26.jpg "image_tooltip")


 


# 5.Exception Handling

The unexpected unwanted event which disturbs entire flow of the program is known as “Exception”



* If we are not handling exception, the program may terminate abnormally with out releasing allocated resources.
* Exception handling means it is not repairing an exception, just providing alternative way to continue the program execution normally.

**Common scenarios where exceptions may occur**

If we divide any number by zero, there occurs an **ArithmeticException**.


```
    int a=50/0;//ArithmeticException  
```


If we have null value in any variable, performing any operation occurs a **NullPointerException**.


```
    String s=null;  
    System.out.println(s.length());//NullPointerException  
```


The wrong formatting of any value, may occur **NumberFormatException**.


```
    String s="abc";  
    int i=Integer.parseInt(s);//NumberFormatException  
```


If you are inserting any value in the wrong index, it would result **ArrayIndexOutOfBoundsException** 


```
    int a[]=new int[5];  
    a[10]=50; //ArrayIndexOutOfBoundsException  
```



## Default Exception Handling



* When ever an exception raised, the method in which it is raised is responsible for the preparation of exception object by including the following information

    ```
    Name of Exception.
    Description.
    Location of Exception
    ```


* After preparation of Exception Object, the method handovers the object to the **JVM**, JVM will check for Exception handling code in that method.
*  If the method doesn’t contain any exception handling code, then JVM terminates that method abnormally and removes corresponding entry from the stack.
* JVM will check for exception handling code in the caller and if the caller method also doesn’t contain exception handling code then JVM terminates that caller method abnormally and removes corresponding entry from the stack.
* This process will be continued until main method, if the main method also doesn’t contain any exception handling code then JVM terminates main method abnormally.
* Just before terminating the program JVM handovers the responsibilities of exception handling to default exception handler.
*  Default exception handler prints the error in the following format.

    ```
    Name of Exception: Description
    stackTrace

    ```



## Exception Hierarchy



<p id="gdcalert27" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image27.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert28">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image27.png "image_tooltip")


**Throwable** is the parent of entire java exception hierarchy. It has 2 child classes



1. **Exception.**
2. **Error**.

**<span style="text-decoration:underline;">1.Exception</span>**

These are recoverable. Most of the cases exceptions are raised due to program code only.

**Checked Exceptions: **They Cheeked by Compiler, they will check that the given resource is existed or not, they are usually occur interacting with outside resources/ network resources e.g. database problems, network connection errors, missing files etc.** Java forces you to handle these error scenarios in some manner in your application code**

**Unchecked Exceptions: **occurrences of which are not checked by the compiler like coding, initialization, Primitive data errors. They usually result of bad code in your system.**Runtimeexception_ _**and it’s child classes, **Error_ _**and it’s child classes are considered as unchecked exceptions and all the remaining considered as checked

**<span style="text-decoration:underline;">2.Error</span>**

Errors are non-recoverable. Most of the cases errors are due to lack of system resources but not due to our programs.

JVM +Memory+ OS level issues. OutofMemory, StatckOverFlow

**<span style="text-decoration:underline;">Parially Checked Vs Fully Checked </span>**

A checked exception is said to be fully checked iff all it’s child classes also checked.

**Ex: - IOException.**

A checked exception is said to be partially checked if some of it’s child classes are not checked.

**Ex: - Exception, Throwable.**

**Number of ways to find details of the exception**

**<span style="text-decoration:underline;">1.Using an object of java.lang.Exception</span>**


```
try
{
int x=Integer.parseInt ("10x");
}
catch (Exception e)
{
   System.out.println (e); // java.lang.NumberFormatException : for input string 10x
} 				name of the exception	   ||  nature of the message
```


**<span style="text-decoration:underline;">2.Using printStackTrace method</span>**


```
e.printStackTrace (); // java.lang.ArithmeticException : / by zero : at line no: 4
                 name of the exception         || nature of the message || line number
```


**<span style="text-decoration:underline;">3.Using getMessage method</span>**:

**<code>System.out.println (e.getMessage ()); // </code>/ by zero</strong>

**                                                                nature of the message**


## Using try, catch, finally 



* We have to place the risky code inside the try block and the corresponding exception handling code inside catch block.

<table>
  <tr>
   <td>
<strong>Without try-catch</strong>
   </td>
   <td><strong>With try-catch</strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>class Test {</code></strong>
<code> <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String arg[]) {</code>
<code>	System.<strong><em>out</em></strong>.println("Statement 1");</code>
<code>	System.<strong><em>out</em></strong>.println(10 / 0);</code>
<code>	System.<strong><em>out</em></strong>.println("Statement 2");</code>
<code>	}</code>
<p>
<code> }</code>
   </td>
   <td><strong><code>class Test {</code></strong>
<code>  <strong>public</strong> <strong>static</strong> <strong>void</strong> main(String arg[])</code>
<code>   {</code>
<p>
<code>      System.<strong><em>out</em></strong>.println("Statement 1");</code>
<code>	<strong>try</strong> {</code>
<code>		System.<strong><em>out</em></strong>.println(10 / 0);</code>
<code>	}</code>
<p>
<code>        <strong>catch</strong> (ArithmeticException e) </code>
<code>        {</code>
<p>
<code>		System.<strong><em>out</em></strong>.println(10 / 2);</code>
<code>	}</code>
<p>
<code>	System.<strong><em>out</em></strong>.println("Statement 2");</code>
<code>   }</code>
<p>
<code>}</code>
   </td>
  </tr>
  <tr>
   <td><strong><code>Statement 1</code></strong>
<strong><code>Exception in thread "main" java.lang.ArithmeticException: / by zero</code></strong>
   </td>
   <td><strong><code>Statement 1</code></strong>
<strong><code>5</code></strong>
<strong><code>Statement 2</code></strong>
   </td>
  </tr>
</table>




* In the case of try with multiple catch blocks the order of catch blocks is important. And it should be from child to parent, other wise Compiler Error. Saying Exception xxx has already been caught.
* If there is no chance of raising an exception in try statement, then we are not allowed to maintain catch block for that exception.If we do so, violation leads to compile time error. but this rule is applicable only for fully checked exceptions.

    ```
    class Test {
    	public static void main(String arg[]) {
    		try {
    			System.out.println("Hi");
    		} catch (IOException e) {
    		}
    	}
    }
    Test.java:7: error: exception IOException is never thrown in body of corresponding try statement
                    } catch (IOException e) {
                      ^
    ```


* It is not recommended to maintain cleanup code with in the catch block. because there is no guarenty of execution of perticlular catch block.
* finally block should always execute irrespective of whether the exception is raised or not and  handled or not handled.
* The finally block won’t be executed ,if the system it self exists(JVM shutdown) i.e in the case of  System.exit() finally block won’t be executed.

**<span style="text-decoration:underline;">Possibe combinations of try, catch, finally</span>**


<table>
  <tr>
   <td><strong><code>try</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>catch (X e)</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>finally</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong>CORRECT</strong>
   </td>
   <td><strong><code>try</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>finally</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong>CORRECT</strong>
   </td>
   <td><strong><code>try</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong>CE:</strong> <strong>error: 'try' without 'catch', 'finally' or resource declarations</strong>
   </td>
  </tr>
  <tr>
   <td><strong><code>try</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>System.out.println("Hello");</code></strong>
<strong><code>catch (X e)</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong>CE:</strong> <strong>error: 'try' without 'catch', 'finally' or resource declarations</strong>
   </td>
   <td><strong><code>try</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>catch (X e)</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>System.out.println("Hello");</code></strong>
<strong><code>finally</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong>CE:</strong> <strong>error: 'try' without 'catch', 'finally' or resource declarations</strong>
   </td>
   <td><strong><code>try</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>finally</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong><code>catch (X e)</code></strong>
<strong><code>{</code></strong>
<strong><code>}</code></strong>
<strong>CE:</strong> <strong>error: 'try' without 'catch', 'finally' or resource declarations</strong>
   </td>
  </tr>
</table>


The following program will demonstrate the control flow in different cases.


```
class Demo {
	public static void main(String arg[]) {

		try{			
			statement1;
			statement2;
			statement3;					

		} catch (Exception e) 
		{
			statement4;
		} finally 
		{
			statement5;
		}
		statement6;
	}
}

```



* if there is no exception, then the statements **1, 2, 3, 5, 6** will execute with normal termination.
* if an exception raised at **statement-2** and the corresponding catch block matched, then the statements **1, 4, 5, 6** will execute with normal termination.
* if an exception raised at **statement-2** but the corresponding catch block not matched then the statements **1, 5, 6** will execute with abnormal termination.
* if an exception raised at **statement-2** and while executing the corresponding catch block at **statement–4** an exception raised then the statements **1, 5** will execute with abnormal termination.
* if an exception raised at **statement-5** or at **statement-6** then it is always abnormal condition.

**<span style="text-decoration:underline;">Throws</span>**

If our code may be a chance of raising **_checked exception _**then compulsory we should handle that checked exception either by using try, catch or we have to delegate that responsibility to the caller using throws keyword other wise **C.E : must be caught or declared to be thrown**

Throws will give an indication to the calling function to keep the called function **under try and catch blocks**.

It gives an information to the programmer that there may occur an exception so it is better for the programmer to provide the exception handling code so that normal flow can be maintained


```
class Cal {
	public void div(String a, String b) throws ArithmeticException,NumberFormatException {
		int c = Integer.parseInt(a) / Integer.parseInt(b);
	}
}

public class A {
	public static void main(String[] args) {
		Cal ob = new Cal();
		try {
			ob.div("a", "b");
		} catch (ArithmeticException e) {
			System.out.println("Divide By Zero");
		} catch (NumberFormatException e) {
			System.out.println("Enter Only INT's");
		} catch (Exception e) {
			System.out.println(" Some Other " + e);
		}
	}
}
Enter Only INT's
```


In above **<code>throws <span style="text-decoration:underline;">ArithmeticException,NumberFormatException </span></code></strong>Indicates it may throws these exceptions so please put <code>ob.div(str,str) </code>method in try,catch block 

**<span style="text-decoration:underline;">Throw</span>**

**Throw** keyword is used to explicitly throw an exception. 

In above we didn’t create any Exception class Object in throws because JVM automatically creates Objects. If you want to create Exception class object manually and throw exception using **throw** keyword 


```
public class Marks {
	public void pass(int marks) {
		if (marks < 35) {
			throw new ArithmeticException("You are Failed");
		} else {
			System.out.println(" You are Pass : " + marks);
		}
	}


	public static void main(String[] args) {
		Marks m = new Marks();
		m.pass(26);
	}
}
Exception in thread "main" java.lang.ArithmeticException: You are Failed
	at excep.Marks.pass(Marks.java:9)
	at excep.Marks.main(Marks.java:18)
```



## User Defined Exceptions

User defined exceptions are those which are developed by JAVA programmer as a part of Application development for dealing with specific problems such as negative salaries, negative ages.

**3 Steps to developing user defined exceptions**



* Choose the appropriate user defined class must extends either **java.lang.Exception** or **java.lang.RunTimeException** class.
* That class must contain a **parameterized Constructor by taking string as a parameter**.
* Above constructor must call super constructor with string Ex : **super(s)**

**Example**

For implementing example, we must create 3 classes



1. **User defined Exception class**
2. **A class with a method which throws User defined Exception **
3. **Main class which calls above method**

1.User Defined Exception class 🡺 1.Extends Exception || 2.Constructor(s) || 3.Super(s)


```
    public class NegativeNumberException extends Exception {
    	public NegativeNumberException(String s) {
    		super(s);
    	}
    }
```


2.A class with a method which throws User defined Exception 🡺 throws & throw


```
    public class Salary {
    	public void show(int sal) throws NegativeNumberException {
    		if (sal < 0) {
    			throw new NegativeNumberException("Salary Should be >1");
    		} else {
    			System.out.println("Your Sal is :" + sal);
    		}
    	}
    }
```


3.Main class which calls above method


```
    public class UserMain {
    	public static void main(String[] args) {
    		Salary salary = new Salary();
    		try {
    			salary.show(-100);
    		} catch (NegativeNumberException e) {			 
    			e.printStackTrace();
    		}
    	}
    }
    excep.NegativeNumberException: Salary Should be >1
    	at excep.Salary.show(Salary.java:8)
    	at excep.Salary.main(Salary.java:18)
```


In Real time CSW Id Start with A1 & Contains 8 digit number, so if given ID not met the requirement Throws CSWException


## ExceptionHandling with MethodOverriding in Java


```
If the superclass method does not declare an exception
If the superclass method does not declare an exception, subclass overridden method cannot declare the checked exception but it can declare unchecked exception.
If the superclass method declares an exception
If the superclass method declares an exception, subclass overridden method can declare same, subclass exception or no exception but cannot declare parent exception.
```



## Java 1.7 Execption handling Enhancements 

**<span style="text-decoration:underline;">Java try-with-resources</span>**



* Before java 7, we had to use finally blocks to cleanup the resources. Finally blocks were not mandatory, but resource clean up was to prevent the system from being corrupt.
* With java 7, no need to explicit resource cleanup. Its done automatically.
* Automatic resource cleanup done when initializing resource in try-with-resources block (try(…) {…}).
* Cleanup happens because of new interface **AutoCloseable**. Its close method is invoked by JVM as soon as try block finishes.
* If you want to use this in custom resources, then implementing AutoCloseable interface is mandatory. otherwise program will not compile.


```
public class ResourceManagementInJava7 {
	public static void main(String[] args) {
		try ({
BufferedReader br = new BufferedReader(new FileReader("C:/temp/test.txt")}
)) {
			String sCurrentLine;
			while ((sCurrentLine = br.readLine()) != null) {
				System.out.println(sCurrentLine);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}
}
```


In java 7, we have a new super interface **[java.lang.AutoCloseable](https://docs.oracle.com/javase/7/docs/api/java/lang/AutoCloseable.html).** This interface has one method:


```
void close() throws Exception;
```


When we open any such AutoCloseable resource in special try-with-resource block, immediately after finishing the try block, **JVM calls this close() method on all resources initialized in “try()” block**.

**<span style="text-decoration:underline;">Catch with Multiple Exception classes</span>**

From Java 7 onwards, you can catch multiple exceptions in single catch block using ( | ) symbol.


```
 catch(NullPointerException | IndexOutOfBoundsException ex)
        {
            Ex.printStackTrace();
        }

```



* If a `catch` block handles more than one exception type, then the **<code>catch </code></strong>parameter is implicitly <strong><code>final</code></strong>. In this example, the <code>catch</code> parameter <code>ex</code> is <code>final</code> and therefore you cannot assign any values to it within the <code>catch</code> block.
* The Exceptions must be in same level of Hierarchy.


```
catch(NullPointerException | Exception ex)
        {
            throw ex;
```


**<code>        }</code> The exception NullPointerException is already caught by the alternative</strong>


## Exception Handling Interview Questions

**What will happen if you put System.exit(0) on try or catch block? **

In normal Finally block will always execute. The only case finally block is not executed is **System.exit(0).** In advanced case it will execute in following case.

By Calling System.exit(0) in try or catch block, its stops execution & throws **SecurityException**.



* If System.exit(0) **NOT throws security exception, then finally block Won’t be executed** 
* But, if **System.exit(0) throws security exception then finally block will be executed**.

**java.lang.System.exit()** will terminates the currently executing program by JVM.



* **exit(0)** : Generally used to indicate successful termination.
* **exit(1) or exit(-1) or any other non-zero value** –indicates unsuccessful termination.

**What happens if we put return statement on try/catch? Will finally block execute?**

Yes, finally block will execute even if you put a return statement in the try block or catch block.


```
try {
    //try block
    ...
    return success;
}
catch (Exception ex) {
    //catch block
    .....
    return failure;
}
finally {
    System.out.println("Inside finally");
}
```


The answer is yes. **finally** block will execute. The only case where it will not execute is when it encounters **System.exit().**

**What happens when a finally block has a return statement?**

Finally block overrides the value returned by try and catch blocks.


```
public static int myTestingFuncn(){
  try{
     ....
     return 5;
  } 
  finally {
     ....
     return 19;
   }
}
```


This program would return value 19 since the value returned by try has been overridden by finally.

**Why do you think Checked Exception exists in Java, since we can also convey error using RuntimeException?** \
**Most of checked exceptions are in java.io package**, which make sense because if you request any system resource and its not available, than a robust program must be able to handle that situation gracefully. 

By declaring **IOException** as checked Exception, Java ensures that your should provide that gracefully exception handling. Another possible reason could be to ensuring that system resources like file descriptors, which are limited in numbers, should be released as soon as you are done with that using catch or finally block \
 

**Have you faced OutOfMemoryError in Java? How did you solved that?** \
**OutOfMemoryError in **Java is a subclass of java.lang.VirtualMachineError and JVM throws java.lang.OutOfMemoryError when it **ran _out of memory in the heap_.**

An easy way to solve OutOfMemoryError in java is to [increase the maximum heap size](http://javarevisited.blogspot.com/2011/08/increase-heap-size-maven-ant.html) by using JVM options "-Xmx512M", this will immediately solve your OutOfMemoryError.


# 6. java. lang package

The most commonly used and general purpose classes which are required for any java program are grouped into a package which is nothing but a “**java.lang.package”.**

All the classes and interfaces which are available in this package are by default available to any java program. There is no need to import this class.



<p id="gdcalert28" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image28.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert29">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image28.png "image_tooltip")




1. **Object Class**
2. **String class**
3. **StringBuffer Class**
4. **StringBuilder Class**
5. **Wrapper Classes**


## 1.Object Class

The most common general methods which can be applicable on any java object are defined in object class. Object class is the parent class of any java class, whether it is predefined or programmer defined, hence all the object class methods are by default available to any java class.** Object class define the following 11 methods**

**<span style="text-decoration:underline;">1.toString():</span>**Returns a string representation of the object.



* When ever we are passing object reference as argument to s.o.p() internally JVM will call toString() on that object.
* If we are not providing implementation to toString() method, then Object class toString() will be executed which is implemented as follows

    ```
    public String toString() {
    		return getClass.getName() + '@' + Integer.toHexString(HashCode);
    	}

    ```


**<span style="text-decoration:underline;">2.equals(Object otherObject) </span>**– As method name suggests, is used to simply verify the equality of two objects. It’s default implementation simply check the object references of two objects to verify their equality. _By default, two objects are equal if and only if they are stored in the same memory address._

**<span style="text-decoration:underline;">3.hashcode() </span>**– Returns a unique integer value for the object in runtime. By default, integer value is mostly derived from memory address of the object in heap (but it’s not mandatory always).

**Relation between equals() & hashcode() methods**



* If two objects are equal according to the `equals(Object)` method, then calling the `hashCode `method on each of the two objects must produce the same integer result.
* **Whenever we override the equals() method, we should override hashcode() method.**
* In **String class(not StringBuilder, StringBuffer) & All Wrapper classes equals()** method is overridden for Content Comparison

**Compare two employee Objects based on Their Id?**


```
public class Employe {
	int id;
	String name;
//Setters & Getters
	@Override
	public boolean equals(Object obj) {		
		Employe e = (Employe) obj;
		boolean flag = false;
		if (this.getId() == e.getId()) {
			flag = true;
		}
		return flag;
	}
	public static void main(String[] args) {
		Employe e1 = new Employe();
		Employe e2 = new Employe();
		e1.setId(101);
		e2.setId(101);
		System.out.println(e1.equals(e2));//true
	}
}
```


So are we done? Not yet. Let’s test again above modified `Employee` class in different way.


```
public static void main(String[] args) {
		Employe e1 = new Employe();
		Employe e2 = new Employe();
		e1.setId(101);
		e2.setId(101);


		Set<Employe> set = new HashSet<>();
		set.add(e1);
		set.add(e2);
		System.out.println(set); //[basic.Employe@15db9742, basic.Employe@6d06d69c]	
	}
```


Above class prints two objects in the second print statement. If both employee objects have been equal, in a `Set` which stores only unique objects, there must be only one instance inside `HashSet.`

We are missing the second important method `hashCode()`. As java docs say, if you override `equals()`method then you **_must_** override `hashCode()` method


```
public class Employe {
	int id;
	String name;

	@Override
	public boolean equals(Object obj) {		
		Employe e = (Employe) obj;
		boolean flag = false;
		if (this.getId() == e.getId()) {
			flag = true;
		}
		return flag;
	}


	@Override
	public int hashCode() {		
		return getId();
	}
	public static void main(String[] args) {
		Employe e1 = new Employe();
		Employe e2 = new Employe();
		e1.setId(101);
		e2.setId(101);


		Set<Employe> set = new HashSet<>();
		set.add(e1);
		set.add(e2);
		System.out.println(set); //[basic.Employe@65]		
	}
}
```


[Apache commons](https://commons.apache.org/proper/commons-lang/) provide two excellent utility classes **[EqualsBuilder](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html) & [HashCodeBuilder](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html)**  for generating hash code and equals methods.

**<span style="text-decoration:underline;">4.clone():</span>** Creates a new object of the same class as this object which implements Clonable interface.


```
Test t1 = new Test();
Test t2 = (Test)t1.clone();
```


An Object is said to be cloneable iff the corresponding class has to implement **java.lang.cloneable** interface. It doesn’t contain any methods it is a marker interface.

**<span style="text-decoration:underline;">5.finalize():</span>**Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.

**<span style="text-decoration:underline;">6.getClass():</span>**Returns the runtime class of an object.`g`etClass(), or the class-literal - Foo.class return a Class object, which contains some metadata about the class:



* name
* package
* methods
* fields
* constructors
* annotations

we can create Class object by following ways


```
Class c = Class.forName("StudentBO")
Class c = StudentBO.class
Class c = a.getClass();

public static void main(String[] args) throws Exception {
		TestApp a = new TestApp();
		Class c1 = a.getClass();


		 Class c = Class.forName("java.lang.String");
		 System.out.print("Class represented by c : " + c.toString());


		 Object obj = c.newInstance();
	}
```


**<span style="text-decoration:underline;">7.wait():</span>**current thread will wait, until another thread notifies

**<span style="text-decoration:underline;">8.wait(long ms):</span>** current thread will wait for the specified milliseconds, until another thread notifies

**<span style="text-decoration:underline;">9.wait(long ms, int nano):</span>** current thread will wait for the specified milliseconds and nanoseconds, until another thread notifies.

**<span style="text-decoration:underline;">10.notify():</span>**Wakes up a single thread that is waiting on this object's monitor.

**<span style="text-decoration:underline;">11.notifyAll():</span>**Wakes up all threads that are waiting on this object's monitor.


## 2.String Class

There are two ways to create String object:

**1.By string literal**


```
String s1="Welcome";  
String s2="Welcome";//It doesn't create a new instance  
```


**2.By new keyword**


```
String s1=new String("Welcome");//creates two objects and one reference variable
```


**Understand the following cases**

**<span style="text-decoration:underline;">Case 1 : literal VS Object</span>**


```
public class StringDemo {
	public static void main(String[] args) {
		String s1 = "Cat";
		String s2 = "Cat";

		String s3 = new String("Cat");

		System.out.println(s1 == s2); // true
		System.out.println(s1 == s3); // false
	}
}
```




<p id="gdcalert29" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image29.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert30">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image29.png "image_tooltip")


To be clear what this code is making is on the first line of code it will create the `String s1 = "Cat"`and store this on the **String pool**, and on the second line of code it will create the `String s2` and reference to `"Cat"` because this already exist on the **String pool**. But line 3 will create a new reference of this string no matter if this already exist

**<span style="text-decoration:underline;">Case 2:</span>**


```
	String s1 = "abc";
	String s2 = s1;
	       s1 += "d";
	System.out.println(s1+", "+s2+", "+(s1==s2));

abcd, abc, false
```




<p id="gdcalert30" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image30.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert31">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image30.png "image_tooltip")


**<span style="text-decoration:underline;">Case 3:</span>**


```
StringBuffer s1 = new StringBuffer("abc");
StringBuffer s2 = s1;
     s1.append("d");
System.out.println(s1+", "+s2+", "+(s1==s2));

abcd, abcd, true
```


**StringBuffer operates on Same Object .** 

<p id="gdcalert31" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image31.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert32">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image31.png "image_tooltip")


**<span style="text-decoration:underline;">Case 4:</span>**


```
		String a = "hello" + " world";
		String b = "hello world";
		System.out.println(a==b); //TRUE
```




<p id="gdcalert32" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image32.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert33">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image32.png "image_tooltip")


When concatenating two string literals `"a" + "b"` the jvm joins the two values and then check the string pool, then it realizes the value already exists in the pool so it just simply assigns this reference to the String.

**<span style="text-decoration:underline;">Case 5 : (+= uses StringBuilder Inside to Create & Append String)</span>**


```
		String a = "Bye";
		       a += " bye!";


		String b = "Bye bye!";


		System.out.println(a == b);//FALSE
```


This case is kind of different tho, because you’re using the += operator which when compiled to bytecode it uses StringBuilder to concatenate the strings, so this creates a new instance of StringBuilder Object thus pointing to a different reference. (string pool vs Object)

Oracle Says, To improve performance, instead of using string concatenation, use `StringBuffer.append()`. String objects are immutable

**<span style="text-decoration:underline;">Performance</span>**

It’s better to use StringBuilder (it’s an unsynchronized version; when do you build strings in parallel?) these days, in almost every case, but here’s what happens:

When you use + with two strings, it compiles code like this:


```
String third = first + second;
```


To something like this


```
StringBuilder builder = new StringBuilder( first );
builder.append( second );
third = builder.toString();
```


for example, you might be using many different appending statements, or a loop like this:


```
for( String str : strings ) {
  out += str;
}
```


In this case, a new `StringBuilder` instance, and a new `String` (the new value of `out` – `String`s are immutable) is required in each iteration. This is very wasteful. Replacing this with a single `StringBuilder` means you can just produce a single `String` and not fill up the heap with `String`s you don’t care about

 

To get the String which is created in SCP while executing String(“welcome”), we use intern() method


```
String s=new String("Welcome");  
String s2=s.intern();  
System.out.println(s2);// Welcome
```


In java, **string objects are immutable**. Immutable simply means unmodifiable or unchangeable.


```
class Testimmutablestring{  
 public static void main(String args[]){  
   String s1="Sachin";  
   s.concat(" Tendulkar");//concat() method appends the string at the end  
   System.out.println(s);//Sachin, because strings are immutable objects  
 }  
}  
```




<p id="gdcalert33" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image33.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert34">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image33.png "image_tooltip")



## 3,4.StringBuffer, StringBuilder Classes


<table>
  <tr>
   <td><strong>String</strong>
   </td>
   <td><strong>StringBuffer</strong>
   </td>
  </tr>
  <tr>
   <td>String class is immutable.
   </td>
   <td>StringBuffer class is mutable.
   </td>
  </tr>
  <tr>
   <td>String is slow and consumes more memory when you concat too many strings because every time it creates new instance.
   </td>
   <td>StringBuffer is fast and consumes less memory when you cancat strings.
   </td>
  </tr>
  <tr>
   <td>String class overrides the equals() method of Object class. So you can compare the contents of two strings by equals() method.
   </td>
   <td>StringBuffer class doesn't override the equals() method of Object class.
   </td>
  </tr>
  <tr>
   <td><strong>String </strong>is  synchronized i.e. thread safe
   </td>
   <td><strong>StringBuffer</strong> is synchronized i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously.
   </td>
  </tr>
</table>


Creates an empty StringBuffer object with default initial capacity 16.If it reaches max capacity then a new StringBuffer object will be created with new **capacity = (currentcapacity + 1) * 2**


```
    StringBuffer sb = new StringBuffer();


<table>
  <tr>
   <td>```

<strong>StringBuffer</strong>
   </td>
   <td><strong>StringBuilder</strong>
   </td>
  </tr>
  <tr>
   <td>StringBuffer is <em>synchronized</em> i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously.
   </td>
   <td>StringBuilder is <em>non-synchronized</em> i.e. not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
   </td>
  </tr>
  <tr>
   <td>StringBuffer is <em>less efficient</em> than StringBuilder.
   </td>
   <td>StringBuilder is <em>more efficient</em> than StringBuffer.
   </td>
  </tr>
</table>



<table>
  <tr>
   <td>
   </td>
   <td><strong>String                    </strong>
   </td>
   <td><strong>StringBuffer         </strong>
   </td>
   <td><strong>StringBuilder</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Storage Area</strong>
<p>
<strong>Modifiable  </strong>
<p>
<strong>Thread Safe </strong>
<p>
<strong>Performance</strong>
   </td>
   <td>Constant String Pool
<p>
No (immutable)      
<p>
      Yes           
<p>
      Fast          
   </td>
   <td>      Heap        
<p>
 Yes( mutable )   
<p>
        Yes       
<p>
   Very slow      
   </td>
   <td>     Heap 
<p>
 Yes( mutable )
<p>
     No
<p>
    Fast
   </td>
  </tr>
</table>


**Examples on String, StringBuffer, StringBuilder**

**<span style="text-decoration:underline;">1.What is immutable object? Can you write immutable object?</span>**

**_Don’t confuse over SingleTon class_**

Immutable classes are Java classes whose objects can not be modified once created. 



1. Declare **the class as final** so it can’t be extended.
2. Make all **fields private & final** so that direct access is not allowed & it’s values can be assigned only once.
3. **Initialize** all the fields via a **constructor** 
4. Write getters only**, not setters**.


```
// An immutable class
public final class Student {
	final String name;
	final int regNo;

	public Student(String name, int regNo) {
		this.name = name;
		this.regNo = regNo;
	}
	public String getName() {
		return name;
	}
	public int getRegNo() {
		return regNo;
	}
}

// Driver class
class Test {
	public static void main(String args[]) {
		Student s = new Student("ABC", 101);
		System.out.println(s.name);
		System.out.println(s.regNo);

		// Uncommenting below line causes error
		// s.regNo = 102;
	}
}
```


**<span style="text-decoration:underline;">2.What is Singleton? Can you write critical section code for singleton?</span>**

**A Singleton class is one which allows us to create only one object for JVM.**

**Rules: **



* Create Singleton class **Object make it as PRIVATE **
* Create **PRIVATE contrcutor **
* Every Singleton class contains **at least one factory method **


```
class Student {
	private static Student st;

	private Student() {
		System.out.println("OBJECET Created FIRST TIME");
	}

	public static Student getObject() {
		if (st == null) {
			st = new Student();
		} else {
			System.out.println("OBJECET ALREDAY CREATED");
		}
		return st;
	}
}

public class Singleton {
	public static void main(String[] args) {
		Student s1 = Student.getObject();
		Student s2 = Student.getObject();
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}
}
```


In above code, it will create multiple instances of Singleton class if called by more than one thread parallel

**_Double checked locking of Singleton_** is a way to ensure only one instance of Singleton class is created through application life cycle.

This will bring us to **double checked locking pattern**, where only critical section of code is locked. Programmer call it double checked locking because there are two checks for _instance == null, one without locking and other with locking (inside synchronized) block. Here is how double checked locking looks like in Java


```
public static Singleton getInstanceDC() {
        if (_instance == null) {                // Single Checked
            synchronized (Singleton.class) {
                if (_instance == null) {        // Double checked
                    _instance = new Singleton();
                }
            }
        }
        return _instance;
}
```


**<span style="text-decoration:underline;">How do you reverse a String in Java without using StringBuffer?</span>**

The Java library provides String Buffer and StringBuilder class with **reverse()** method, which can be used to reverse String in Java.


```
String reverse = "";
String source= "My Name is Khan";
        for(int i = source.length() -1; i>=0; i--){
            reverse = reverse + source.charAt(i);
        }
```


**<span style="text-decoration:underline;">How to Print duplicate characters from String?</span>**


```
public class RepreatedChar {
	public static void main(String[] args) {
		String a = "success";

		// 1.convert into char array
		char[] c = a.toCharArray();

		// 2.create Hashmap store key as character, count as value
		HashMap map = new HashMap<>();
		for (char ch : c) {

			// 3.Check if Map contains given Char as <key> or not
			if (map.containsKey(ch)) {
				// if their, get the value & increment it
				int i = (int) map.get(ch);
				i++;
				// add updated value to it
				map.put(ch, i);
			} else {
				// if not their , add key & value as 1
				map.put(ch, 1);
			}
		}


		 Set  set =  map.entrySet();
		 Iterator iterator = set.iterator() ;
		 while (iterator.hasNext()) {
			Map.Entry entry = (Entry) iterator.next();
			System.out.println(entry.getKey()+" : "+entry.getValue());


		}
	}
}
s : 3
c : 2
u : 1
e : 1
```


**<span style="text-decoration:underline;">Reverse String in Java</span>**



1. Get String length
2. Iterate by using charAt() in reverse & append to new String


```
public class ReverseString {
public static void main(String[] args) {


	String s = "satyam";
	String rev="";
	int len = s.length();


	for(int i=(len-1);i>=0;i--){


		rev = rev+s.charAt(i);
	}


	System.out.println(rev);
}
}
```


**<span style="text-decoration:underline;">Is String contains Number or not</span>**


```
public class RegEx {
	public static void main(String[] args) {
		// Regular expression in Java to check if String is number or not
		Pattern pattern = Pattern.compile(".*[^0-9].*");		 
		String[] inputs = { "123", "-123", "123.12", "abcd123" };
		/* Matches m = pattern.match(input);
		 * boolean ch = m.match();	 */		

		for (String input : inputs) {
System.out.println("does " + input + " is number : " + !pattern.matcher(input).matches());
		}

	// Regular expression in java to check if String is 6 digit number or  not
		String[] numbers = { "123", "1234", "123.12", "abcd123", "123456" };
		Pattern digitPattern = Pattern.compile("\\d{6}");
		// Pattern digitPattern = Pattern.compile("\\d\\d\\d\\d\\d\\d");

		for (String number : numbers) {
			System.out.println("does " + number + " is 6 digit number : " + digitPattern.matcher(number).matches());
		}
	}
}
```


**<span style="text-decoration:underline;">Reverse Words in a String</span>**


```
public class RevWords {
	public static void main(String[] args) {
		// using s.split("\\s");
		String s = "My name is Satya";
		String words[] = s.split("\\s");
		String rev = "";
		int len = words.length;
		for (int i = (len - 1); i >= 0; i--) {
			rev = rev + words[i];
		}
		System.out.println(rev);

		// using Collections.reverse(str)
		List<String> word = Arrays.asList(s.split("\\s"));
		Collections.reverse(word);
		System.out.println(word);
	}
}
```



## 5.Wrapper classes

Collections in Java deal only with objects; to store a primitive type values in one of these Collection classes, you need to Conevert the primitive type to Object Type.

The main objectives of wrapper classes are:



* To Wrap primitives into object form. So that we can handle primitives also just like objects.
* To Define several utility functions for the primitives (converting primitive to the string form etc)

Each primitive type has a corresponding wrapper class.


<table>
  <tr>
   <td><strong>Primtive Type</strong>
   </td>
   <td><strong>Wrapper Class</strong>
   </td>
  </tr>
  <tr>
   <td><strong>double</strong>
   </td>
   <td><strong>Double</strong>
   </td>
  </tr>
  <tr>
   <td><strong>float</strong>
   </td>
   <td><strong>Float</strong>
   </td>
  </tr>
  <tr>
   <td><strong>long</strong>
   </td>
   <td><strong>Long</strong>
   </td>
  </tr>
  <tr>
   <td><strong>int</strong>
   </td>
   <td><strong>Integer</strong>
   </td>
  </tr>
  <tr>
   <td><strong>short</strong>
   </td>
   <td><strong>Short</strong>
   </td>
  </tr>
  <tr>
   <td><strong>byte</strong>
   </td>
   <td><strong>Byte</strong>
   </td>
  </tr>
  <tr>
   <td><strong>char</strong>
   </td>
   <td><strong>Character</strong>
   </td>
  </tr>
  <tr>
   <td><strong>boolean</strong>
   </td>
   <td><strong>Boolean</strong>
   </td>
  </tr>
</table>


**<span style="text-decoration:underline;">Primitive type to wrapper class</span>**

1.using **constrcutors**


```
    // 1. using constructor
    Integer object = new Integer(10);
```


2.using **static factory methods** such as valueOf() (except Character)


```
    // 2. using static factory method
    Integer anotherObject = Integer.valueOf(10);
```


Similarly, we can convert other primitive types like boolean to Boolean, char to Character, etc.

**<span style="text-decoration:underline;">Wrapper class to primitive type</span>**

Converting from wrapper to primitive type is simple. We can use the corresponding methods to get the primitive type. e.g. **intValue()**, **doubleValue()**, **shortValue()** etc.


```
Integer object = new Integer(10);


int val = object.intValue();    //wrapper to primitive
```


**<span style="text-decoration:underline;">Autoboxing and Unboxing</span>**

Beginning with JDK 5, Java added two important features: _autoboxing_ and _auto-unboxing_.

**Autoboxing** is the automatic conversion of the primitive types into their corresponding object wrapper classes. For example, converting an `int` to an `Integer`, a `char` to a `Character`, and so on.

We can simply pass or assign a primitive type to an argument or reference accepting wrapper class object. e.g.


```
List<Integer> integerList = new ArrayList<>();


for (int i = 1; i < 50; i += 2)
{
    integerList.add(Integer.valueOf(i));        //autoboxing
}
```


**Unboxing**  happens when the conversion happens from wrapper class to its corresponding primitive type. It means we can pass or assign a wrapper object to an argument or reference accepting primitive type. e.g.


```
public static int sumOfEven(List<Integer> integerList)
{
    int sum = 0;
    for (Integer i: integerList) {
        if (i % 2 == 0)
            sum += i;           //Integer to int
    }
    return sum;
}
```


In above example, the remainder (`%`) and unary plus (`+=`) operators does not apply on Integer objects. The compiler automatically converts an Integer to an int at runtime by invoking the `intValue()`method.

**<span style="text-decoration:underline;">Wrapper Classes Internal Caching</span>**

Wrapper classes are immutable in java, Right? “YES”. So, like string pool, they can also have their pool, right? “Great Idea”. Well, it’s already there. JDK provided wrapper classes also provide this in form of instance pooling i.e. each wrapper class store a list of commonly used instances of own type in form of cache and whenever required, you can use them in your code. It helps in saving lots of byes in your program runtime.

In **Integer.java** class, there is an inner class i.e. **IntegerCache**. When you assign a new int to Integer type like below


```
Integer i = 10; //OR
Integer i = Integer.valueOf(10);
```


An already created Integer instance is returned and reference is stored in i. Please note that if you use new Integer(10); then a new instance of Integer class will be created and caching will not come into picture. Its only available when you use `Integer.valueOf()` OR directly primitive assignment (which ultimately uses `valueOf()` function)


```
public class IntegerCacheDemo {


    public static void main(String[] args) {


        Integer a1 = 100;
        Integer a2 = 100;
        Integer a3 = new Integer(100);


        System.out.println(a1 == a2);
        System.out.println(a1 == a3);
    }
}


Output: 
true
false
```


If you want to store a bigger number of instances, you can use runtime parameter as below:


```
-Djava.lang.Integer.IntegerCache.high=2000
```



## java.lang Package

We have mainly five classes in java.lang. Which are most commonly used in any java program



1. **Object**
2. **String**
3. **StringBuffer**
4. **StringBuilder**
5. **Wrapper Classes (AutoBoxing / AutoUnboxing)**

**<span style="text-decoration:underline;">Object Class</span>**

The most common general methods which can be applicable on any java object are defined in object class. Object class is the parent class of any java class, whether it is predefined or programmer defined, hence all the object class methods are by default available to any java class.

Object class define the following 11 methods

**1.toString**():Returns a string representation of the object.


```
public String toString() {
		return getClass.getName() + '@' + Integer.toHexString(HashCode);
	}
```


**2.hashCode**():returns the integer representation of memory location which used by JVM while saving/adding Objects into Hashsets, Hashtables or Hashmap

**3.equals**(Object): Compares two Objects for equality.

**4.clone**(): Creates a new object of the same class as this object which implements Clonable interface.


```
Test t1 = new Test();
Test t2 = (Test)t1.clone();
```


**5.finalize**():Called by the garbage collector on an object when garbage collection determines that there are no more references to the object.

**6.getClass**():Returns the runtime class of an object.` `etClass(), or the class-literal - Foo.class return a Class object, which contains some metadata about the class:



* name
* package
* methods
* fields
* constructors
* annotations

we can create Class object by following ways


```
Class c = Class.forName("StudentBO")
Class c = StudentBO.class
Class c = a.getClass();

public static void main(String[] args) throws Exception {
		TestApp a = new TestApp();
		Class c1 = a.getClass();


		 Class c = Class.forName("java.lang.String");
		 System.out.print("Class represented by c : " + c.toString());


		 Object obj = c.newInstance();
	}
```


**7.wait**():Waits to be notified by another thread of a change in this object.

**8.wait**(long):Waits to be notified by another thread of a change in this object.

**wait**(long, int):Waits to be notified by another thread of a change in this object.

**9.notify**():Wakes up a single thread that is waiting on this object's monitor.

**notifyAll**():Wakes up all threads that are waiting on this object's monitor.

`equals(Object otherObject)` – As method name suggests, is used to simply verify the equality of two objects. It’s default implementation simply check the object references of two objects to verify their equality. _By default, two objects are equal if and only if they are stored in the same memory address._

`hashcode()` – Returns a unique integer value for the object in runtime. By default, integer value is mostly derived from memory address of the object in heap (but it’s not mandatory always).

If two objects are equal according to the `equals(Object)` method, then calling the `hashCode `method on each of the two objects must produce the same integer result.

**Whenever we override the equals() method, we should override hashcode() method**

**In String class(not StringBuilder, StringBuffer) & All Wrapper classes equals() method is overridden for Content Comparison**

**<span style="text-decoration:underline;">Compare two employee Objects based on Their Id?</span>**


```
public class Employe {
	int id;
	String name;
//Setters & Getters
	@Override
	public boolean equals(Object obj) {		
		Employe e = (Employe) obj;
		boolean flag = false;
		if (this.getId() == e.getId()) {
			flag = true;
		}
		return flag;
	}
	public static void main(String[] args) {
		Employe e1 = new Employe();
		Employe e2 = new Employe();
		e1.setId(101);
		e2.setId(101);
		System.out.println(e1.equals(e2));//true
	}
}
```


So are we done? Not yet. Lets test again above modified `Employee` class in different way.


```
public static void main(String[] args) {
		Employe e1 = new Employe();
		Employe e2 = new Employe();
		e1.setId(101);
		e2.setId(101);


		Set<Employe> set = new HashSet<>();
		set.add(e1);
		set.add(e2);
		System.out.println(set); //[basic.Employe@15db9742, basic.Employe@6d06d69c]	
	}
```


Above class prints two objects in the second print statement. If both employee objects have been equal, in a `Set` which stores only unique objects, there must be only one instance inside `HashSet`

We are missing the second important method `hashCode()`. As java docs say, if you override `equals()`method then you **_must_** override `hashCode()` method


```
public class Employe {
	int id;
	String name;

	@Override
	public boolean equals(Object obj) {		
		Employe e = (Employe) obj;
		boolean flag = false;
		if (this.getId() == e.getId()) {
			flag = true;
		}
		return flag;
	}


	@Override
	public int hashCode() {		
		return getId();
	}

	public static void main(String[] args) {
		Employe e1 = new Employe();
		Employe e2 = new Employe();
		e1.setId(101);
		e2.setId(101);


		Set<Employe> set = new HashSet<>();
		set.add(e1);
		set.add(e2);
		System.out.println(set); //[basic.Employe@65]		
	}
}
```


[Apache commons](https://commons.apache.org/proper/commons-lang/) provide two excellent utility classes **[EqualsBuilder](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/EqualsBuilder.html) & [HashCodeBuilder](https://commons.apache.org/proper/commons-lang/apidocs/org/apache/commons/lang3/builder/HashCodeBuilder.html)**  for generating hash code and equals methods.


## Strings

There are two ways to create String object:

**1) By string literal**


```
String s1="Welcome";  
String s2="Welcome";//It doesn't create a new instance  
```


 Firstly, JVM will not find any string object with the value "Welcome" in string constant pool, that is why it will create a new object. After that it will find the string with the value "Welcome" in the pool, it will not create a new object but will return the reference to the same instance.



<p id="gdcalert34" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image34.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert35">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image34.png "image_tooltip")


**2) By new keyword**

**<code>String s1=</code></strong>new<strong><code> String(</code>"Welcome"<code>);</code>//creates two objects and one reference variable</strong>

JVM will create a new string object in normal  heap memory, and the literal "Welcome" will be placed in the string constant pool. The variable s will refer to the object in a heap (non-pool).




<p id="gdcalert35" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image35.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert36">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image35.png "image_tooltip")


To get the String which is created in SCP while executing String(“welcome”), we use intern() method


```
String s=new String("Welcome");  
String s2=s.intern();  
System.out.println(s2);//Sachin  
```


In java, **string objects are immutable**. Immutable simply means unmodifiable or unchangeable.


```
class Testimmutablestring{  
 public static void main(String args[]){  
   String s1="Sachin";  
   s.concat(" Tendulkar");//concat() method appends the string at the end  
   System.out.println(s);//will print Sachin because strings are immutable objects  
 }  
}  
```




<p id="gdcalert36" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image36.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert37">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image36.png "image_tooltip")



<table>
  <tr>
   <td><strong>String</strong>
   </td>
   <td><strong>StringBuffer</strong>
   </td>
  </tr>
  <tr>
   <td>String class is immutable.
   </td>
   <td>StringBuffer class is mutable.
   </td>
  </tr>
  <tr>
   <td>String is slow and consumes more memory when you concat too many strings because every time it creates new instance.
   </td>
   <td>StringBuffer is fast and consumes less memory when you cancat strings.
   </td>
  </tr>
  <tr>
   <td>String class overrides the equals() method of Object class. So you can compare the contents of two strings by equals() method.
   </td>
   <td>StringBuffer class doesn't override the equals() method of Object class.
   </td>
  </tr>
  <tr>
   <td><strong>StringBuilder</strong> is non-synchronized i.e. not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
   </td>
   <td><strong>StringBuffer</strong> is synchronized i.e. thread safe. It means two threads can't call the methods of StringBuffer simultaneously.
   </td>
  </tr>
</table>


**<span style="text-decoration:underline;">1.What is immutable object? Can you write immutable object?</span>**

**_Don’t confuse over SingleTon class_**

Immutable classes are Java classes whose objects can not be modified once created. 



5. Declare **the class as final** so it can’t be extended.
6. Make all **fields private & final** so that direct access is not allowed & it’s values can be assigned only once..
7. **Initialize** all the fields via a **constructor** 
8. Write getters only**, not setters**.


```
// An immutable class
public final class Student {
	final String name;
	final int regNo;

	public Student(String name, int regNo) {
		this.name = name;
		this.regNo = regNo;
	}
	public String getName() {
		return name;
	}
	public int getRegNo() {
		return regNo;
	}
}

// Driver class
class Test {
	public static void main(String args[]) {
		Student s = new Student("ABC", 101);
		System.out.println(s.name);
		System.out.println(s.regNo);

		// Uncommenting below line causes error
		// s.regNo = 102;
	}
}
```


**<span style="text-decoration:underline;">2.What is Singleton? Can you write critical section code for singleton?</span>**

**A Singleton class is one which allows us to create only one object for JVM.**

**Rules: **



* Create Singleton class **Object make it as PRIVATE **
* Create **PRIVATE contrcutor **
* Every Singleton class contains **at least one factory method **


```
class Student {
	private static Student st;

	private Student() {
		System.out.println("OBJECET Created FIRST TIME");
	}

	public static Student getObject() {
		if (st == null) {
			st = new Student();
		} else {
			System.out.println("OBJECET ALREDAY CREATED");
		}
		return st;
	}
}

public class Singleton {
	public static void main(String[] args) {
		Student s1 = Student.getObject();
		Student s2 = Student.getObject();
		System.out.println(s1.hashCode());
		System.out.println(s2.hashCode());
	}
}
```


In above code, it will create multiple instances of Singleton class if called by more than one thread parallel

**_Double checked locking of Singleton_** is a way to ensure only one instance of Singleton class is created through application life cycle.

This will bring us to **double checked locking pattern**, where only critical section of code is locked. Programmer call it double checked locking because there are two checks for _instance == null, one without locking and other with locking (inside synchronized) block. Here is how double checked locking looks like in Java


```
public static Singleton getInstanceDC() {
        if (_instance == null) {                // Single Checked
            synchronized (Singleton.class) {
                if (_instance == null) {        // Double checked
                    _instance = new Singleton();
                }
            }
        }
        return _instance;
}
```


**<span style="text-decoration:underline;">How do you reverse a String in Java without using StringBuffer?</span>**

The Java library provides String Buffer and StringBuilder class with **reverse()** method, which can be used to reverse String in Java.


```
String reverse = "";
String source= "My Name is Khan";
        for(int i = source.length() -1; i>=0; i--){
            reverse = reverse + source.charAt(i);
        }
```


**<span style="text-decoration:underline;">How to Print duplicate characters from String?</span>**


```
public class RepreatedChar {
	public static void main(String[] args) {
		String a = "success";

		// 1.convert into char array
		char[] c = a.toCharArray();

		// 2.create Hashmap store key as character, count as value
		HashMap map = new HashMap<>();
		for (char ch : c) {

			// 3.Check if Map contains given Char as <key> or not
			if (map.containsKey(ch)) {
				// if their, get the value & increment it
				int i = (int) map.get(ch);
				i++;
				// add updated value to it
				map.put(ch, i);
			} else {
				// if not their , add key & value as 1
				map.put(ch, 1);
			}
		}


		 Set  set =  map.entrySet();
		 Iterator iterator = set.iterator() ;
		 while (iterator.hasNext()) {
			Map.Entry entry = (Entry) iterator.next();
			System.out.println(entry.getKey()+" : "+entry.getValue());


		}
	}
}
s : 3
c : 2
u : 1
e : 1
```


**<span style="text-decoration:underline;">Reverse String in Java</span>**



3. Get String length
4. Iterate by using charAt() in reverse & append to new String


```
public class ReverseString {
public static void main(String[] args) {


	String s = "satyam";
	String rev="";
	int len = s.length();


	for(int i=(len-1);i>=0;i--){


		rev = rev+s.charAt(i);
	}


	System.out.println(rev);
}
}
```


**<span style="text-decoration:underline;">Is String contains Number or not</span>**


```
public class RegEx {
	public static void main(String[] args) {
		// Regular expression in Java to check if String is number or not
		Pattern pattern = Pattern.compile(".*[^0-9].*");		 
		String[] inputs = { "123", "-123", "123.12", "abcd123" };
		/* Matches m = pattern.match(input);
		 * boolean ch = m.match();	 */		

		for (String input : inputs) {
System.out.println("does " + input + " is number : " + !pattern.matcher(input).matches());
		}

	// Regular expression in java to check if String is 6 digit number or  not
		String[] numbers = { "123", "1234", "123.12", "abcd123", "123456" };
		Pattern digitPattern = Pattern.compile("\\d{6}");
		// Pattern digitPattern = Pattern.compile("\\d\\d\\d\\d\\d\\d");

		for (String number : numbers) {
			System.out.println("does " + number + " is 6 digit number : " + digitPattern.matcher(number).matches());
		}
	}
}
```


**<span style="text-decoration:underline;">Reverse Words in a String</span>**


```
public class RevWords {
	public static void main(String[] args) {
		// using s.split("\\s");
		String s = "My name is Satya";
		String words[] = s.split("\\s");
		String rev = "";
		int len = words.length;
		for (int i = (len - 1); i >= 0; i--) {
			rev = rev + words[i];
		}
		System.out.println(rev);

		// using Collections.reverse(str)
		List<String> word = Arrays.asList(s.split("\\s"));
		Collections.reverse(word);
		System.out.println(word);
	}
}
```


**<span style="text-decoration:underline;">Can a top-level class be private or protected?</span>**

Top level classes in java can’t be private or protected, but inner classes in java can. The reason for not making a top-level class as private is very obvious, because nobody can see a private class and thus they cannot use it

**<span style="text-decoration:underline;">What Happens if we compile Empty java file?</span>**

Compiles but Runtime Error.

 

<p id="gdcalert37" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image37.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert38">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image37.png "image_tooltip")


**<span style="text-decoration:underline;">Is it possible to make array volatile in Java?</span>**

Yes, it is possible to make an array volatile in Java, but only the reference which is pointing to an array, by reassigning it

**<span style="text-decoration:underline;">What is a.hashCode() used for? How is it related to a.equals(b)?</span>**

According to the Java specification, two objects which are identical to each other using equals() method needs to have the same hash code

**<span style="text-decoration:underline;">What is a compile time constant in Java? What is the risk of using it?</span>**

Answer: **Public static final variables** are also known as the compile time constant, the public is optional there. They are substituted with actual values at compile time because compiler recognizes their value up-front, and also recognize that it cannot be altered during runtime.

One of the issues is that if you choose to use a public static final variable from in-house or a third party library, and their value changed later, then your client will still be using the old value even after you deploy a new version of JARs.

**<span style="text-decoration:underline;">Explain Liskov Substitution Principle.</span>**

According to the Liskov Substitution Principle, Subtypes must be appropriate for super type i.e. methods or functions which use super class type must be able to work with object of subclass without issues. Co-Variant return types are implemented based on this principle . 

**<span style="text-decoration:underline;">What is double checked locking in Singleton?</span>**

**Singleton** means we can create only one instance of that class

**<span style="text-decoration:underline;">Rules:</span>**



* Create Singleton class Object make it as PRIVATE
* Create PRIVATE constructor
* Every Singleton class contains at least one factory method


```
class Student {
    private static Student st;
    private Student() {
        System.out.println("OBJECET Created FIRST TIME");
    }
    public static Student getObject() {
        if (st == null) {
            st = new Student();
        } else {
            System.out.println("OBJECET ALREDAY CREATED");
        }
        return st;
    }
}


public class Singleton {
    public static void main(String[] args) {
        Student s1 = Student.getObject();
        Student s2 = Student.getObject();
        System.out.println(s1.hashCode());
        System.out.println(s2.hashCode());
    }
}
```


**Double checked locking in Singleton means, **at any cost only one instance is created in multi-threaded environment.

In this case at null checking make Block as Synchronized.


```

public static Singleton getInstanceDC() {
        if (_instance == null) {                // Single Checked
            synchronized (Singleton.class) {
                if (_instance == null) {        // Double checked
                    _instance = new Singleton();
                }
            }
        }
        return _instance;
}
```


 \
 

**<span style="text-decoration:underline;">When to use volatile variable in Java?</span>**



* Volatile keyword is used with only variable in Java
* it guarantees that value of volatile variable will always be read from main memory and not from Thread's local cache. 
* So, we can use volatile to achieve synchronization because its guaranteed that all reader thread will see updated value of volatile variable once write operation completed

**<span style="text-decoration:underline;">Difference between Serializable and Externalizable in Java?</span>**

**Serialization** is a default process of serializing or persisting any object's state in Java. It's triggered by implementing Serializable interface which is a marker interface (an interface without any method). uses default implementation to handle the object serialization process.

**Externalizable** is used to user defined serialization process and control default serialization process which is implemented by application.

Externalizable interface extends Serializable interface. It consists of two methods 

// to read object from stream

**void readExternal(ObjectInput in) **

// to write object into stream

**void writeExternal(ObjectOutput out) **

**<span style="text-decoration:underline;">Difference between static and dynamic binding in Java? ([detailed answer](http://java67.blogspot.sg/2014/02/static-vs-dynamic-binding-in-java.html))</span>** \
This is usually asked as follow-up of previous question, static binding is related to overloaded method and dynamic binding is related to overridden method. Method like private, final and static are resolved using static binding at compile time but virtual methods which can be overridden are resolved using dynamic binding at runtime. 

**<span style="text-decoration:underline;">Which design pattern have you used in your production code?</span>**



* **Dependency injection**
* **Factory pattern**
* **Adapter Design pattern**
* **Singleton**

**Decorator **[design pattern](https://www.journaldev.com/1827/java-design-patterns-example-tutorial) is used to modify the functionality of an object at runtime.

**<span style="text-decoration:underline;">Can you explain Liskov Substitution principle?(Comes under inheritance )</span>**

According to Liskov Substitution Principle, Subtypes must be substitutable for supertype i.e. methods or functions which uses superclass type must be able to work with the [object ](http://javarevisited.blogspot.com/2012/12/what-is-object-in-java-or-oops-example.html)of subclass without any issue \


**<span style="text-decoration:underline;">How to create an instance of any class without using new keyword</span>**

Using newInstance method of Class class


```
Class c = Class.forName("StudentBo");
StudentBo bo = (StudentBo) c.newInstance();
```


Using clone() of java.lang.Object


```
NewClass obj = new NewClass();
NewClass obj2 = (NewClass) obj.clone();
```



# 7. java.io

For dealing with input & Output Operations in java we have **java.io.*** package

In java we will write two types of programs 

**1. volatile programs** : whose result are stored in main Memory (RAM),Temporally (Ex. Console Applications)

**2. Non-Volatile programs** : whose results are saved permanently in secondary memory like Drives,Harddisks, Databases & files.

**Stream** : flow of data/bites/bytes from source to destination

<p id="gdcalert38" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image38.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert39">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image38.jpg "image_tooltip")


We have following types of streams to handle IO operations.**<span style="text-decoration:underline;"> </span>**


    **1. Byte Streams**  : perform input and output of 8-bit bytes. (**FileInputStream** & **FileOutputStream**)


    **2**. **Character Streams** : I/O of character data, automatically handling translation to and from the local character set (**FileReader and FileWriter)**


    **3. Buffered Streams : **Above are **unbuffered I/O**. This means each read or write request is handled **directly by the underlying OS. **Buffered input streams read data from a memory area known as a buffer; the native input API is called only when the buffer is empty. Similarly, buffered output streams write data to a buffer, and the native output API is called only when the buffer is full **(BufferedInputStream and BufferedOutputStream)**


    **4.** **Data Streams :  **handle I/O of primitive data type and String values. **( DataInputStream & DataOutputStream.)**


    **5. Object Streams **: handle binary I/O of objects**. (ObjectInputStream and ObjectOutputStream)** 



<p id="gdcalert39" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image39.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert40">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image39.jpg "image_tooltip")


InputStream, OutputStream methods can be used by all their child classes for performing IO operations

**<span style="text-decoration:underline;">1. InputStream </span>: read Data from File/Source**



1. _public int read ();_
2. _public int length (); // total size of the file_
3. _public int available (); // available number of bytes only_
4. _public void close ();_

**<span style="text-decoration:underline;">2.OutputStream</span> : Write data to file/Destination**



1. _public void write (int);_
2. _public int length ();_
3. _public void available ();_
4. _public void close ();_

**In java End of file (EOF) is indicated by -1**


## Byte Streams



* Data transfer is **one byte at a time** from source to destination
* used for reading streams of raw bytes such as **image data**
* used to read byte-oriented data for example **to read image, audio, video etc**

**<span style="text-decoration:underline;">1. FileInputStream</span>** is meant for reading streams of raw bytes such **as image data**. For reading streams of characters, consider using **FileReader**. Below are the constructor’s to use FileInputStream


<table>
  <tr>
   <td><strong>Constructors</strong>
   </td>
   <td><strong>Methods</strong>
   </td>
  </tr>
  <tr>
   <td><strong>FileInputStream(File file)</strong>
<p>
<strong>FileInputStream(String FilePath)</strong>
<p>
<strong>FileInputStream(FileDescriptor fdObj)</strong>
   </td>
   <td>Int read(byte b[])
<p>
Int read(byte[] b, int off, int len)
   </td>
  </tr>
</table>


**<span style="text-decoration:underline;">2. FileOutputStream</span>**


<table>
  <tr>
   <td><strong>Constructors </strong>
   </td>
   <td><strong>Methods</strong>
   </td>
  </tr>
  <tr>
   <td><strong>FileOutputStream(File file) </strong>
<p>
<strong>FileOutputStream(String filepath) </strong>
<p>
<strong>FileOutputStream(FileDescriptor fdObj) </strong>
<p>
<strong>FileOutputStream(File file, boolean append)   </strong>
<p>
//true 🡺append, false🡺 overrite
<p>
<strong>FileOutputStream(String name, boolean append)  name.</strong>
   </td>
   <td>void write(byte b[])
<p>
void write(byte[] b, int off, int len)
   </td>
  </tr>
</table>


used for reading/writing data from/to **Binary files like image,videos,xls,docs**.

**Example**


```
public class ByteStreams {
	public static void main(String[] args) throws IOException {
		String filepath = "E:\\users\\Kaveti_s\\Desktop\\Books\\tmp.txt";
		FileOutputStream outputStream = new FileOutputStream(filepath);
		for (int i = 0; i < 10; i++) {
			outputStream.write(i);
		}
		FileInputStream inputStream = new FileInputStream(filepath);
		int i;
		while ((i = inputStream.read()) != -1) {
			System.out.println("I : " + i);
		}
	}
}
I : 0,I : 1,I : 2,I : 3,I : 4,I : 5,I : 6,I : 7,I : 8,I : 9
```



    If we open **tmp.txt** , the data in the form of bytes. That means we can’t read that data. For above example the file data is **Ā̂Ԅ܆ई**


## Character Streams

Character stream I/O automatically translates this internal format to and from the local character set.here the data is read by character by character

**1. FileReader** is meant for reading streams of characters

**2. FileWriter** is meant for writing streams of characters

Here Methods & Constructors are Similar to Byte Stream, but **instead of byte they will char data.** used for reading/writing data from/to **Files by character encoding**.

**Example**


```
public class CharacterStreams {
	public static void main(String[] args) throws IOException {
		String filepath = "E:\\users\\Kaveti_s\\Desktop\\Books\\tmp.txt";
		char[] ch ={ 'a', 'b', 'c', 'd', 'e' }; 
		FileWriter w = new FileWriter(filepath);
			w.write(ch);
			w.close();		

		FileReader r= new FileReader(filepath);
		int i;
		while ((i = r.read()) != -1) {
			System.out.println(i+":"+(char)i);
		}
	}
}
97:a	98:b	99:c	100:d	101:e
```


Here we can read file data. Data stored in the file is **abcde**

**If we pass int data to FileWriter the program will execute without Compilation Error but it doesn’t display any Output / Empty Output**


## Buffered Streams

 Buffering can speed up IO quite a bit. Rather than read one byte at a time from the network or disk, the BufferedInputStream reads a larger block at a time into an internal buffer. 

When you read a byte from the BufferedInputStream you are therefore reading it from its internal buffer. When the buffer is fully read, the BufferedInputStream reads another larger block of data into the buffer. This is typically much faster than reading a single byte at a time from an InputStream, especially for disk access and larger data amounts.

To convert an unbuffered stream into a buffered stream, we need to pass the unbuffered stream object  to the constructor for a buffered stream class

**<span style="text-decoration:underline;">Example</span>**

inputStream = new BufferedReader(new FileReader("xanadu.txt"));

outputStream = new BufferedWriter(new FileWriter("characteroutput.txt"));

**<span style="text-decoration:underline;">1. BufferedInputStream:</span>**

**BufferedInputStream** class is used for reducing number of physical read operation. When we

create an object of BufferedInputStream, we get a temporary peace of memory space **whose default**

**size is 1024 bytes** and it can be increased by multiples of 2.

**<span style="text-decoration:underline;">2.BufferedOutputStream:</span>**

BufferedOutputStream class is used for reducing number of physical write operation when

we create an object of BufferedOutputStream, we get a temporary peace of memory space whose

**default size is 1024** bytes and it can be increased by multiple of 2.


<table>
  <tr>
   <td><strong>Constructors</strong>
   </td>
   <td><strong>Methods</strong>
   </td>
  </tr>
  <tr>
   <td><strong>BufferedInputStream(InputStream is) BufferedInputStream(InputStream is, int bufsize)</strong>
<p>
<strong>BufferedOutputStream(OutputStream os) BufferedOutputStream(OutputStream os, int bufsize)</strong>
   </td>
   <td>Int read(byte b[])
<p>
Int read(byte[] b, int off, int len)
<p>
void write(byte b[])
<p>
void write(byte[] b, int off, int len)
   </td>
  </tr>
</table>


used for reading/writing data from/to **Files**.

**Example**


```
public class BufferedStreams {
	public static void main(String[] args) throws IOException {
		String filepath = "E:\\users\\Kaveti_s\\Desktop\\Books\\sl.txt";
		// 1.Create Stream Object
		FileOutputStream fos = new FileOutputStream(filepath);
		// 2.pass Stream object to BufferStream constructor
		BufferedOutputStream bos = new BufferedOutputStream(fos);
		String s = "SmlCodes.com -Programmimg Simplified";
		byte[] b = s.getBytes();
		bos.write(b);
		bos.flush();

		// 1.Create Stream Object
		FileInputStream fis = new FileInputStream(filepath);
		// 2.pass Stream object to BufferStream constructor
		BufferedInputStream bis = new BufferedInputStream(fis);
		int i;  
	    while((i=bis.read())!=-1){  
	     System.out.println((char)i);  
	    } 
	}
}

```



* **Byte streams will transfer 1 byte of data at a time**
* **Character streams will transfer 2 bytes of data at a time**
* **Buffered Streams will transfer 1024 bytes of data at a time**


## Data Streams

Data streams support binary I/O of **primitive data type values** (**_boolean, char, byte, short, int, long, float, and double_**) and **String** values.All data streams implement either the **DataInput** interface or the **DataOutput** interface



1. **<span style="text-decoration:underline;">DataInputStream :</span>**Used for read primitive Java data types from input stream.(**readXXX() method)**
2. **<span style="text-decoration:underline;">DataOutputStram</span>** : Used for write primitive Java data types to Output stream.(**writeXXX() method)**

    here XXX = primitive data types


<table>
  <tr>
   <td>
<strong>Constructors</strong>
   </td>
   <td><strong>Methods</strong>
   </td>
  </tr>
  <tr>
   <td><strong>DataInputStream (InputStream is)  </strong>
<p>
<strong>DataOutputStream (OutputStream os)  </strong>
   </td>
   <td>Int read(byte b[])
<p>
Int read(byte[] b, int off, int len)
<p>
Byte readByte()
<p>
Int readInt()
<p>
Char readchar()
<p>
void write(byte b[])
<p>
void write(byte[] b, int off, int len)
<p>
void writeByte(byte b)
<p>
void writeInt(int i)
   </td>
  </tr>
</table>


 

**Example**


```
public class DataStream {
	public static void main(String[] args) throws Exception {
		DataOutputStream dos = new DataOutputStream(new       FileOutputStream("sml.bin"));
		dos.writeInt(10);
		dos.writeUTF("Satya");


		DataInputStream dis = new DataInputStream(new FileInputStream("sml.bin"));
		System.out.println("Int : " + dis.readInt());
		System.out.println("String : " + dis.readUTF());
	}
}
Int : 10
String : Satya
```



## Object Streams

Just as data streams support I/O of primitive data types, **object streams support I/O of objects. **Here we have to know about **Serialization.**


<table>
  <tr>
   <td><strong>ObjectOutputStream(OutputStream out)</strong>
<p>
          void writeObject(Object obj)
   </td>
   <td><strong>ObjectInputStream(InputStream in)</strong>
<p>
                 Object readObject()
   </td>
  </tr>
</table>



### 1.Serialization

Serialization is the **process of saving the state of the object permanently** in the form of a file/byte stream. To develop serialization program follow below steps

**Steps to implement Serialization **

1. **Choose** the appropriate **class** name whose object is participating in serialization.

2. This class must **implement** **java.io.Serializable** (this interface does **not** **contain any abstract methods and** such type of interface is known as **marker or tagged interface**)

3. Choose **data members** , writer **setters** & **getters**

4. Choose **Serializable subclass** 

5. **Choose the file** name and **open it into write mode** with the help of **FileOutputStream** class

6. Pass OutputStream object to **ObjectOutputStream(out)** constructor to write object data at a time

7.use oos.writeObject(student) method to write Student Object data

**Example**


```
class Student implements Serializable {
	// Exception in thread "main" java.io.NotSerializableException: io.Student
	private int sno;
	private String name;
	private String addr;
	public int getSno() {
		return sno;
	}
	public void setSno(int sno) {
		this.sno = sno;
	}
	public String getName() {
		return name;
	}
	//same way setName,SetAddr methods…
}
public class Serialization {
public static void main(String[] args) throws  Exception {
	Student student = new Student();
	student.setSno(101);
	student.setName("Satya Kaveti");
	student.setAddr("VIJAYAWADA");


	FileOutputStream fos = new FileOutputStream("student.txt");
	ObjectOutputStream oos = new ObjectOutputStream(fos);
	oos.writeObject(student);	
}
}
¬í sr 
io.StudentÓÞ®(¦°¦ I snoL addrt Ljava/lang/String;L nameq ~ xp   et 
VIJAYAWADAt  //data saved in student.txt
```



### 2.Deserialization 

De-serialization is a **process of** **retrieve the data from the file in the form of object**.

**Steps**

1. Choose the file name and open it into read mode with the help of FileInputStream class

2. Pass InputStream object to ObjectInputStream(in) constructor to read object data at a time

3.use ois.readObject() method to get Student Object 

**Example**


```
public class Deserialization {
	public static void main(String[] args) throws Exception{
		FileInputStream fis = new FileInputStream("student.txt");
		ObjectInputStream ois = new ObjectInputStream(fis);
		Student st = (Student)ois.readObject();
		System.out.println(st.getSno());
		System.out.println(st.getName());
		System.out.println(st.getAddr()); 
	}
}
101
Satya Kaveti
VIJAYAWADA
```


If we use above process to implement serialization, all the data members will participate in Sterilization process. If you want to use selected data members for serialization use **Transient** keyword


### 3.Transient Keyword

In order to avoid the variable from the serialization process, make that variable declaration as transient i.e., **transient variables never participate in serialization process**.

**Example**


```
class Student implements Serializable {	 
	private transient int sno;
	private transient String name;
	private String addr;
}

public class TransientExample {
	public static void main(String[] args) throws  Exception {
		Student student = new Student();
		student.setSno(101);
		student.setName("Satya Kaveti");
		student.setAddr("VIJAYAWADA");


		FileOutputStream fos = new FileOutputStream("student.txt");
		ObjectOutputStream oos = new ObjectOutputStream(fos);
		oos.writeObject(student);	


		FileInputStream fis = new FileInputStream("student.txt");
		ObjectInputStream ois = new ObjectInputStream(fis);
		Student st = (Student)ois.readObject();
		System.out.println(st.getSno());
		System.out.println(st.getName());
		System.out.println(st.getAddr()); 
	}
}
0
null
VIJAYAWADA
```


**Printing  of sno,name returns 0,null because values of sno,name was not serialized.**


## Summarize Java I/O Streams

**<span style="text-decoration:underline;">Streams</span>**



* byte oriented stream (8 bit)
* good for binary data such as a Java .class file
* good for "machine-oriented" data

**<span style="text-decoration:underline;">Readers/Writers</span>**



1. char (utf-16) oriented stream (16 bit)
2. good for text such as a Java source
3. good for "human-oriented" data

**<span style="text-decoration:underline;">Buffered : </span>**always useful unless proven otherwise


<table>
  <tr>
   <td><strong> Type</strong>
   </td>
   <td colspan="2" ><strong>Byte Based</strong>
   </td>
   <td colspan="2" ><strong>Character Based</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Basic</strong>
   </td>
   <td>InputStream
   </td>
   <td>OutputStream
   </td>
   <td>Reader \
InputStreamReader
   </td>
   <td>Writer \
OutputStreamWriter
   </td>
  </tr>
  <tr>
   <td><strong>1.Arrays</strong>
   </td>
   <td>ByteArrayInputStream
   </td>
   <td>ByteArrayOutputStream
   </td>
   <td>CharArrayReader
   </td>
   <td>CharArrayWriter
   </td>
  </tr>
  <tr>
   <td><strong>2.Files</strong>
   </td>
   <td>FileInputStream \
RandomAccessFile
   </td>
   <td>FileOutputStream \
RandomAccessFile
   </td>
   <td>FileReader
   </td>
   <td>FileWriter
   </td>
  </tr>
  <tr>
   <td><strong>3.Pipes</strong>
   </td>
   <td>PipedInputStream
   </td>
   <td>PipedOutputStream
   </td>
   <td>PipedReader
   </td>
   <td>PipedWriter
   </td>
  </tr>
  <tr>
   <td><strong>4.Buffering</strong>
   </td>
   <td>BufferedInputStream
   </td>
   <td>BufferedOutputStream
   </td>
   <td>BufferedReader
   </td>
   <td>BufferedWriter
   </td>
  </tr>
  <tr>
   <td><strong>5.Filtering</strong>
   </td>
   <td>FilterInputStream
   </td>
   <td>FilterOutputStream
   </td>
   <td>FilterReader
   </td>
   <td>FilterWriter
   </td>
  </tr>
  <tr>
   <td><strong>6.Parsing</strong>
   </td>
   <td>PushbackInputStream \
StreamTokenizer
   </td>
   <td> 
   </td>
   <td>PushbackReader \
LineNumberReader
   </td>
   <td> 
   </td>
  </tr>
  <tr>
   <td><strong>7.Strings</strong>
   </td>
   <td> 
   </td>
   <td> 
   </td>
   <td>StringReader
   </td>
   <td>StringWriter
   </td>
  </tr>
  <tr>
   <td><strong>8.Data</strong>
   </td>
   <td>DataInputStream
   </td>
   <td>DataOutputStream
   </td>
   <td> 
   </td>
   <td>
   </td>
  </tr>
  <tr>
   <td><strong>9.Formatted</strong>
   </td>
   <td> 
   </td>
   <td>PrintStream
   </td>
   <td> 
   </td>
   <td>PrintWriter
   </td>
  </tr>
  <tr>
   <td><strong>10.Objects</strong>
   </td>
   <td>ObjectInputStream
   </td>
   <td>ObjectOutputStream
   </td>
   <td> 
   </td>
   <td> 
   </td>
  </tr>
  <tr>
   <td><strong>11.Utilities</strong>
   </td>
   <td>SequenceInputStream
   </td>
   <td> 
   </td>
   <td> 
   </td>
   <td> 
   </td>
  </tr>
</table>




* Byte Streams 🡪 xxxInputStreams, 	xxxOutputStreams
* Char Streams 🡪 xxxReader	, 	xxxWriter

**<span style="text-decoration:underline;">1.Arrays:</span>**These are used to read/write **same data** to/from **multiple files at same time**



* **ByteArrayInputStream	**
* **ByteArrayOutputStream	**
* **CharArrayReader	**
* **CharArrayWriter**

**<span style="text-decoration:underline;">2.Files</span>**

These are used to read/write data to/from one file at a time. **

<p id="gdcalert40" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: undefined internal link (link text: "See above examples for more"). Did you generate a TOC? </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert41">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>

[See above examples for more](#heading=h.28h4qwu)**



* **FileInputStream **
* **FileOutputStream**
* **RandomAccessFile**
* **RandomAccessFile**
* **FileReader	**
* **FileWriter**

**<span style="text-decoration:underline;">3.Pipes</span>**



* **PipedInputStream**
* **PipedOutputStream	**
* **PipedReader	**
* **PipedWriter**

**<span style="text-decoration:underline;">4.Buffering</span>**



* **BufferedInputStream**
* **BufferedOutputStream	**
* **BufferedReader	**
* **BufferedWriter**

**<span style="text-decoration:underline;">5.Filtering</span>**

The FilterInputStream/FilterOutputStream is a base class for **implementing your own filtering** **input/output streams**. They does not have any special behavior. Frankly there is no sensible purpose for this class



* **FilterInputStream	**
* **FilterOutputStream	**
* **FilterReader	**
* **FilterWriter**

**<span style="text-decoration:underline;">6. Parsing</span>**

**<span style="text-decoration:underline;">PushbackInputStream/PushbackReader</span>**

  Sometimes you need to read ahead a few bytes to see what is coming, before you can determine how to interpret the current byte. 

The PushbackInputStream allows you to do that. it allows you to push the read bytes back into the stream. These bytes will then be read again the next time you call read().


```
PushbackInputStream input = new PushbackInputStream(
                                new FileInputStream("c:\\data\\input.txt"));

int data = input.read();

input.unread(data);
```


**<span style="text-decoration:underline;">StreamTokenizer : </span>**StreamTokenizer class (java.io.StreamTokenizer) can **tokenize the characters read from a Reader into tokens**. For instance, in the string "Mary had a little lamb" each word is a separate token


```
StreamTokenizer streamTokenizer = new StreamTokenizer(
        new StringReader("Mary had 1 little lamb..."));

while(streamTokenizer.nextToken() != StreamTokenizer.TT_EOF){

    if(streamTokenizer.ttype == StreamTokenizer.TT_WORD) {
        System.out.println(streamTokenizer.sval);
    } else if(streamTokenizer.ttype == StreamTokenizer.TT_NUMBER) {
        System.out.println(streamTokenizer.nval);
    } else if(streamTokenizer.ttype == StreamTokenizer.TT_EOL) {
        System.out.println();
    }
}
streamTokenizer.close();
```


**<span style="text-decoration:underline;">7. Strings</span>**



* **StringReader : **takes input string and changes it into character stream
* **StringWriter : **uses BufferedReader to read file data & written in character array as buffer

**<span style="text-decoration:underline;">8.Data</span>**

read Java primitives (int, float, long etc.) from an InputStream instread of bytes



* **DataInputStream	**
* **DataOutputStream**

**<span style="text-decoration:underline;">9.Formatted</span>**

**<span style="text-decoration:underline;">PrintStream : </span>**PrintStream class can **format primitive types like int, long etc**. formatted as text, rather than as their byte values.it is comes under **ByteStream**


```
PrintStream printStream = new PrintStream(outputStream);

printStream.print(true);
printStream.print((int) 123);
printStream.print((float) 123.456);

printStream.close();
```


**System.out and System.err are PrintStreams**

**<span style="text-decoration:underline;">PrintWriter :</span>**this class (java.io.PrintWriter) enables you to write formatted data to an underlying Writer. For instance, writing int, long and other primitive data formatted as text, rather than as their byte values.it is comes under **Character Stream** 


```
FileWriter  writer      = new FileWriter("d:\\data\\report.txt");
PrintWriter printWriter = new PrintWriter(writer);

printWriter.print(true);
printWriter.print((int) 123);
printWriter.print((float) 123.456);

printWriter.printf(Locale.UK, "Text + data: %1$", 123);

printWriter.close();
```


**<span style="text-decoration:underline;">10.Objects :</span>**read Java objects from an InputStream instead of just raw bytes



* **ObjectInputStream	**
* **ObjectOutputStream**

**<span style="text-decoration:underline;">11.Utilities : </span>SequenceInputStream** **combines two or more other InputStream's into one**. First the SequenceInputStream **will read all bytes from the first InputStream**, **then all bytes from the second InputStream**. That is the reason it is called a SequenceInputStream, since the InputStream instances are read in sequence


```
InputStream input1 = new FileInputStream("c:\\data\\file1.txt");
InputStream input2 = new FileInputStream("c:\\data\\file2.txt");

SequenceInputStream si = new SequenceInputStream(input1, input2);

int data = si.read();
while(data != -1){
    System.out.println(data);
    data = si.read();
}
```



## printf and format Methods

The java.io package includes a PrintStream class that has two formatting methods. **format** and **printf**

public PrintStream format (String format, Object... args)


```
System.out.format("The value of " + "the float variable is " +
     "%f, while the value of the " + "integer variable is %d, " +
     "and the string is %s", floatVar, intVar, stringVar);
```



## File I/O (Featuring NIO.2)

The java.nio.file  provide comprehensive support for file I/O and for accessing the default file system.


# 8.Threads


## Introduction to Multi-threading

If a program contains **multiple flow of controls for achieving concurrent execution** then that program is known as **multi**-**threaded** program

The languages like **C, C++ comes under single threaded modeling languages**, since there exist single flow of controls whereas the languages **like JAVA, DOT NET are treated as multi-threaded modeling languages**, since there is a possibility of creating multiple flow of controls

When we write any JAVA program there exist two threads they are 



1. fore ground thread (main Thread) 
2. Back ground thread.

**<span style="text-decoration:underline;">1. Fore ground threads</span>** are those which are **executing user defined sub-programs**. There is a possibility of creating **‘n’ number of fore ground threads**

**<span style="text-decoration:underline;">2. Back ground threads</span>** are those which are **monitoring the status of fore ground thread.** And always there exist **single back ground thread.**

In information technology we can develop two types of applications. They **are process based applications** and **thread based applications.**

**<span style="text-decoration:underline;">Context switch</span>** is the concept of operating system and it says switching the control from one address page to another address page


<table>
  <tr>
   <td><strong>Process Based Applications</strong>
   </td>
   <td><strong>Thread Based Applications</strong>
   </td>
  </tr>
  <tr>
   <td>1.   Exist <strong>single flow of control</strong>.
<p>
2. All <strong>C, C++</strong> applications comes under it.
<p>
3. <strong>Context switch is more</strong>.
<p>
4. Each process have <strong>its own address in memory</strong> i.e. each process allocates separate memory area.
<p>
5. These are treated as <strong>heavy weight</strong> components.
<p>
6. In this we can achieve only sequential execution and they <strong>are not recommending for developing internet applications</strong>.
   </td>
   <td>1. Exist <strong>Multiple flow of controls</strong>.
<p>
2. All <strong>JAVA, DOT NET</strong> applications comes under it.
<p>
3. <strong>Context switch is very less</strong>.
<p>
4. Threads share the <strong>same address space</strong>
<p>
5. These are treated as <strong>light weight</strong> components.
<p>
6. In thread based applications we can achieve both sequential and concurrent execution and they are always <strong>recommended for developing internet applications</strong>.
   </td>
  </tr>
</table>



## What is Thread

A thread is a lightweight sub process, a smallest unit of processing. It is a separate path of execution. Threads are independent, if there occurs exception in one thread, it doesn't affect other threads. It shares a common memory area.



<p id="gdcalert41" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image40.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert42">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image40.png "image_tooltip")


As shown in the above figure, thread is executed inside the process. There is context-switching between the threads. There can be multiple processes inside the OS and one process can have multiple threads

**At a time one thread is executed only.**


## Thread Life Cycles (Thread States)

See below picture which compares Interview process & Thread Execution process. 

<p id="gdcalert42" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image41.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert43">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image41.png "image_tooltip")



<table>
  <tr>
   <td><strong>Interview Process</strong>
   </td>
   <td><strong>Thread execution process</strong>
   </td>
  </tr>
  <tr>
   <td>1.going to interview
<p>
2.Seated, waiting for your call
<p>
3.giving interview
<p>
4.wating for next round
<p>
5.interview completed
   </td>
   <td>1.Thread is created & is about to enter into main memory
<p>
2.Space is allocated, waiting for CPU
<p>
3.Tharead is under control of CPU
<p>
4.waiting for another thread/wait/sleep
<p>
5.interview completed
   </td>
  </tr>
</table>


Based on the process of execution of thread, people said there are 5 states of a thread

<p id="gdcalert43" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image42.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert44">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image42.png "image_tooltip")


**<span style="text-decoration:underline;">1. New</span>**: Thread is created and about to enter into main memory. **i.e.**, New Thread Object is created but **before the invocation of start() method.**

**<span style="text-decoration:underline;">2. Ready/Runnable</span>**: thread memory space allocated and it is waiting for CPU for executing. i.e., **after invocation of start() method**, but the thread scheduler has not selected

**<span style="text-decoration:underline;">3. Running</span>**: thread is under the control of CPU. i.e., **thread scheduler has selected (run() executing)**.

**<span style="text-decoration:underline;">4. Waiting:</span>** This is the state when the thread is still alive, but is currently not eligible to run. Thread is waiting because of the following factors:



* For the repeating CPU burst time of the thread  
* Make the thread to sleep for some specified amount of time.
* Make the thread to suspend.
* Make the thread to wait for a period of time.
* Make the thread to wait without specifying waiting time.

**<span style="text-decoration:underline;">5. Terminated: </span>**thread has completed its total execution. i.e., Exit form run () method

We have two ways of creating Thread,



* **by extending java.lang.Thread** **class** 
* **By implementing java.lang.Runnable interface. **

**In multi-threading we get only one exception known as java.lang.InterruptedException.**


## java.lang.Thread class

Creating a flow of control in JAVA is nothing but creating an object of java.lang.Thread class.

An object of Thread class can be created in three ways. They are:



* Directly **Thread t=new Thread ();**
* Using factory method **Thread t1=Thread.currentThread ();**
* Using sub-class that **extends Thread class**

Public class **Thread _extends_ Object _implements_ Runnable**


<table>
  <tr>
   <td><strong>Constructors</strong>
   </td>
   <td><strong>Usage</strong>
   </td>
  </tr>
  <tr>
   <td><strong>Thread()</strong>
<p>
<strong>Thread(String name)</strong>
<p>
<strong>Thread(Runnable r)</strong>
<p>
<strong>Thread(Runnable r, String name)</strong>
   </td>
   <td>Creates new Thread, whose default thread name is Thread-0
<p>
Creates new Thread, with user defined thread name 
<p>
Used for converting Runnable Object to Thread Object for accessing start() method with default thread name
<p>
Used for converting Runnable Object to Thread Object with user-defined thread name
   </td>
  </tr>
</table>


**Instance Thread State Methods **

**<span style="text-decoration:underline;">1. void	start ()	: </span>**Used for making the **Thread to start to execute the thread logic**. The method start is **internally calling** the method **run ().	**

**<span style="text-decoration:underline;">2. void	run (): The</span>** thread that logic must be defined only in run () method. When the thread is started, the JVM looks for the appropriate run () method for executing the logic of the thread. **Thread class is a concrete class and it contains all defined methods and all these methods are being to final** **except run () method.** **run () method is by default contains a definition with null body**. Since we are providing the logic for the thread in run () method. Hence it must be overridden by extending Thread class into our own class.

**<span style="text-decoration:underline;">3. void	suspend() </span>-** This method is used for **suspending the thread from current execution** of thread. When the thread is suspended**, it sends to waiting state by keeping the temporary results in process control block (PCB)** or job control block (JCB). (deprecat**ed)**

**<span style="text-decoration:underline;">4. void	resume()</span> -**resumes suspend() Thread. Resumed to start executing from where it left out previously by **retrieving the previous result from PCB **(deprecated)

**5. void	interrupt()	-**Interrupts this thread	

**6. void	join()		-**Waits for this thread to die.	

**7. void	join(long mil)	-**Waits at most milliseconds for this **thread to die	**

**8. void	stop()		-**is used to stop the thread(deprecated).

**Static Methods **


```
Static void sleep(long ms) 	- sleeps/temporary block the thread for specified amount of time
Static void yield ()		- pause current thread and allow other threads to execute
Static Thread currentThread()-Get currently running thread Object. mainly used in run()
Static int activeCount()	-Counts the no.of active threads in current thread group& subgroups.
```


**Object class methods used in Multithreading **


```
void wait()		- waits the current thread until another thread invokes the notify()
void wait (long ms)	- waits the current thread until another thread invokes the notify()/specified amount of time
void notify()		-Wakes up a single thread that is waiting on this object's monitor.
void notifyAll()	-Wakes up all threads that are waiting on this object's monitor.
```


**Other useful instance methods**


```
void	setName(String name)        -set thread's name
String	getName()	                    -Returns this thread's name.
long getId()		                    -Returns the identifier of this Thread.
void setDaemon(boolean on)         -Marks this thread as either a daemon thread
int getPriority()	                    -Returns this thread's priority.
Boolean isAlive()                               -Tests if this thread is alive
Boolean isDaemon()	                    -Tests if this thread is a daemon thread.
Thread.State getState()	       -Returns Current Thread State
ThreadGroup getThreadGroup()    -Returns the thread group to which this thread belongs. 
```




* **public static final int MIN_PRIORITY (1); **
* **public static final int NORM_PRIORITY (5);**
* **public static final int MAX_PRIORITY (10);**

The above data members are used for setting the priority to threads are created. 

By default, whenever a thread is created whose default priority **NORM_PRIORITY**

**Thread class contains all defined &final methods except run () method.run() is null body method**


## java.lang.Runnable Interface

Runnable Interface has only one abstract method run(). Thread class is implemented Runnable interface run() method as null body method

**public void run():** is used to perform action for a thread

As said we can use either of Thread class /Runnable interface to implement threads.

**By Extending Thread Class**


```
public class ThreadDemo extends Thread {
	@Override
	public void run() {
		System.out.println("Iam Running");
	}
	public static void main(String[] args) {
		ThreadDemo ob = new ThreadDemo();
		ob.start();
	}
}
```


**By Implementing Runnable Interface **


```
public class RunnableDemo implements Runnable {
	@Override
	public void run() {
		System.out.println("Iam Running");
	}
	public static void main(String[] args) {
		RunnableDemo r = new RunnableDemo();
		Thread ob = new Thread(r);
		ob.start();
	}
}


<table>
  <tr>
   <td>```

<strong>By Extending Thread Class</strong>
   </td>
   <td><strong>By Implementing Runnable Interface</strong>
   </td>
  </tr>
  <tr>
   <td>1.write a class <strong>extending Thread class</strong>
<p>
2.write <strong>execution logic in run()</strong> method
<p>
3.Create Object of thread 
<p>
<strong><code>ThreadDemo ob = new ThreadDemo();</code></strong>
4.<strong>call start()</strong> method, it internally calls run() method<code> ob.start();</code>
   </td>
   <td>1.write a class <strong>implements Runnable Interface</strong>
<p>
2.write <strong>execution logic in run() </strong>method
<p>
3.Create Object of implemented thread class & create Thread Object by passing it 
<p>
<code>    RunnableDemo r = <strong>new</strong> RunnableDemo();</code>
<code>         Thread ob = <strong>new</strong> Thread(r);</code>
4.call start() method, it internally calls run() method<code> ob.start();</code>
   </td>
  </tr>
</table>


**Example 1: **


```
public class ThreadExample extends Thread {
	@Override
	public void run() {
		System.out.println("----- \n Im Run() Running....\n -----");
	}
	public static void main(String[] args) throws InterruptedException {
		ThreadExample th = new ThreadExample();
		System.out.println(th.getState().name());
		th.start();
		System.out.println(th.getState().name());
		System.out.println("getId : " + th.getId());
		System.out.println("getName : " + th.getName());
		System.out.println("getPriority : " + th.getPriority());
		System.out.println("isAlive : " + th.isAlive());
		System.out.println("isDaemon : " + th.isDaemon());
		System.out.println("getThreadGroup : " + th.getThreadGroup().getName());
		th.setName("SmlCodes-Thread");
		System.out.println("getName : " + th.getName());
		Thread.sleep(2500);//
		System.out.println(th.getState().name());
	}
}
NEW
RUNNABLE
getId : 9
getName : Thread-0
getPriority : 5
isAlive : true
isDaemon : false
getThreadGroup : main
getName : SmlCodes-Thread
----- 
 Im Run() Running....
 -----
TERMINATED
```


**Example 2: Thread program which displays 1 to 10 numbers after each and every 1 second**


<table>
  <tr>
   <td><strong><code>public class SleepDemo extends Thread {</code></strong>
<code>	<strong>public</strong> <strong>void</strong> run() {</code>
<code>		<strong>for</strong> (<strong>int</strong> i = 1; i &lt;= 10; i++) {</code>
<code>			System.<strong><em>out</em></strong>.println(i);</code>
<code>			<strong>try</strong> {</code>
<code>				Thread.<em>sleep</em>(1000);</code>
<code>			} <strong>catch</strong> (InterruptedException e) {</code>
<code>				e.printStackTrace();</code>
<p>
<code>			}</code>
<p>
<code>		}</code>
<p>
<code>	}</code>
<p>
<code>	<strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {</code>
<code>		SleepDemo ob1 = <strong>new</strong> SleepDemo();</code>
<code>		SleepDemo ob2 = <strong>new</strong> SleepDemo();</code>
<code>		ob1.start();</code>
<p>
<code>		ob2.start();	}</code>
<p>
<code>}</code>
   </td>
   <td>
   </td>
   <td>Output
<p>
<code>1</code>
<p>
<code>1</code>
<p>
<code>2</code>
<p>
<code>2</code>
<p>
<code>3</code>
<p>
<code>3</code>
<p>
<code>4</code>
<p>
<code>4</code>
<p>
<code>5</code>
<p>
<code>5</code>
<p>
<code>6</code>
<p>
<code>6</code>
<p>
<code>7</code>
<p>
<code>7</code>
<p>
<code>8</code>
<p>
<code>8</code>
<p>
<code>9</code>
<p>
<code>9</code>
<p>
<code>10</code>
<p>
<code>10</code>
   </td>
  </tr>
</table>


**Example 3: What happens if we start same Thread(ob) Twice?**


```
public class ThreadDemo extends Thread {
	@Override
	public void run() {
		System.out.println("Iam Running");
	}
	public static void main(String[] args) {
		ThreadDemo ob = new ThreadDemo();
		ob.start();
		ob.start();
	}
}
Exception in thread "main" java.lang.IllegalThreadStateException
	at java.lang.Thread.start(Thread.java:705)
	at threads.ThreadDemo.main(ThreadDemo.java:11)
Iam Running
```


**What happens if we call run() method instead of start()**

If we start **run()** method directly JVM treats it as a normal method & it does have characteristics like concurrent execution. In **Example 2** if you see both threads are executing parallel. Here below example we are calling **run()** method directly. See the output


<table>
  <tr>
   <td><strong><code>public class SleepDemo extends Thread {</code></strong>
<code>	<strong>public</strong> <strong>void</strong> run() {</code>
<code>		<strong>for</strong> (<strong>int</strong> i = 1; i &lt;= 10; i++) {</code>
<code>			System.<strong><em>out</em></strong>.println(i);</code>
<code>			<strong>try</strong> {</code>
<code>				Thread.<em>sleep</em>(1000);</code>
<code>			} <strong>catch</strong> (InterruptedException e) {</code>
<code>				e.printStackTrace();</code>
<p>
<code>			}</code>
<p>
<code>		}</code>
<p>
<code>	}</code>
<p>
<code>	<strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {</code>
<code>		SleepDemo ob1 = <strong>new</strong> SleepDemo();</code>
<code>		SleepDemo ob2 = <strong>new</strong> SleepDemo();</code>
<code>		ob1.run();</code>
<p>
<code>		ob2.run();</code>
<p>
<code>	}</code>
<p>
<code>}</code>
   </td>
   <td>
   </td>
   <td>Output
<p>
<code>1</code>
<p>
<code>2</code>
<p>
<code>3</code>
<p>
<code>4</code>
<p>
<code>5</code>
<p>
<code>6</code>
<p>
<code>7</code>
<p>
<code>8</code>
<p>
<code>9</code>
<p>
<code>10</code>
<p>
<code>1</code>
<p>
<code>2</code>
<p>
<code>3</code>
<p>
<code>4</code>
<p>
<code>5</code>
<p>
<code>6</code>
<p>
<code>7</code>
<p>
<code>8</code>
<p>
<code>9</code>
<p>
<code>10</code>
   </td>
  </tr>
</table>


**Remember: only one exception InterruptedException**

Each thread is associated with an instance of the class [Thread](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html). There are two basic strategies for using Thread objects to create a concurrent application.



* To directly control thread creation and management, simply instantiate **Thread** each time the application needs to initiate an asynchronous task.
* To abstract thread management from the rest of your application, pass the application's tasks to an **_executor_**.


## Interrupting a Thread

An _interrupt_ is an indication to a thread that it should stop what it is doing and do something else. It's up to the programmer to decide exactly how a thread responds to an interrupt, but it is very common for the thread to terminate

If any thread is in sleeping or waiting state (i.e. sleep() or wait()), calling the interrupt() method on the thread, breaks out the sleeping or waiting state throwing InterruptedException.



* **public void interrupt()  - **Inturpting a Thread
* **public static boolean interrupted()	**

    It is a Static method, tests whether the CURRENTLY running thread is interrupted or not

* **public boolean isInterrupted()**

    It is a instance method and tests whether the thread instance on which the method is invoked is interrupted or not


**If the thread is not in the sleeping or waiting state, calling the interrupt() method performs normal behaviour and doesn't interrupt the thread but sets the interrupt flag to true**

**Thread is Interrupted & Stops working**


```
public class InterruptNormal extends Thread {
	public void run() {
		try {
			Thread.sleep(1000);
			System.out.println("task");
		} catch (InterruptedException e) {
			throw new RuntimeException("Thread interrupted..." + e);
		}
		System.out.println("Thread is Running ...");
	}
	public static void main(String args[]) {
		InterruptNormal t1 = new InterruptNormal();
		t1.start();
		try {
			t1.interrupt();
		} catch (Exception e) {
			System.out.println("Exception handled " + e);
		}
	}
}
Exception in thread "Thread-0" java.lang.RuntimeException: Thread interrupted...java.lang.InterruptedException: sleep interrupted
	at threads.InterruptNormal.run(InterruptNormal.java:9)
```


above Example your are re throwing IntereuptException. So thraed is Inturrpeed & also stops its execution

**Thread is Interrupted & doesn’t Stops working**


```
public class InterruptHandled extends Thread {
	public void run() {
		try {
			Thread.sleep(3000);
			System.out.println(" *** Sleep is Still Running ****");
		} catch (InterruptedException e) {
			System.out.println("Thread interrupted..." + e);
		}
		System.out.println("Thread is Running ...");
	}
	public static void main(String args[]) {
		InterruptHandled t1 = new InterruptHandled();
		t1.start();
		try {
			t1.interrupt();
		} catch (Exception e) {
			System.out.println("Exception handled " + e);
		}
	}
}
Thread interrupted...java.lang.InterruptedException: sleep interrupted
Thread is Running ...
```


above Example Exception is handled. It is only interruped sleeping thraed.reaming are excuting as normal

**If thread is not in sleeping or waiting state, calling the interrupt() method sets the interrupted flag to true that can be used to stop the thread by the java programmer later.**


```
public class InterruptHandled extends Thread {
	public void run() {		 
		System.out.println(" *** No Sleep is Here ****");		 
		System.out.println("Thread is Running ...");
	}

	public static void main(String args[]) {
		InterruptHandled t1 = new InterruptHandled();
		t1.start();
		try {
			t1.interrupt();
		} catch (Exception e) {
			System.out.println("Exception handled " + e);
		}
	}
}
*** No Sleep is Here ****
Thread is Running ...
```


The interrupt mechanism is implemented using an internal flag known as the _interrupt status_. Invoking Thread.interrupt sets this flag. When a thread checks for an interrupt by invoking the static method **Thread.interrupted**, interrupt status is cleared. The non-static isInterruptedmethod, which is used by one thread to query the interrupt status of another, does not change the interrupt status flag.

By convention, any method that exits by throwing an InterruptedException clears interrupt status when it does so. However, it's always possible that interrupt status will immediately be set again, by another thread invoking interrupt.


## Joining a Thread (join () method)

**Thread internal working**



<p id="gdcalert44" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image43.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert45">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image43.jpg "image_tooltip")



    

<p id="gdcalert45" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image44.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert46">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image44.png "image_tooltip")


In above after completion of thread execution result are given to one by one / All at once using **join() method to Thread Group name**

This method is used for making the **fore ground threads to join together**, so that JVM can call the garbage collector only one time for collecting all of them instead of collecting individually.

**We have two join() methods**



1. **public void join()throws InterruptedException :_Waits for this thread to die_**.

    It will wait until Thread logic completion & after that it will joins the Thread & Gives to Garbage collector 


**Join() Example**


<table>
  <tr>
   <td><strong><code>package threads;</code></strong>
<strong><code>public class JoinExample extends Thread {</code></strong>
<code>	@Override</code>
<p>
<code>	<strong>public</strong> <strong>void</strong> run() {</code>
<code>		<strong>for</strong> (<strong>int</strong> i = 1; i &lt;= 10; i++) {</code>
<code>			<strong>try</strong> {</code>
<code>				Thread.<em>sleep</em>(500);</code>
<code>			} <strong>catch</strong> (InterruptedException e) {</code>
<code>				// <strong>TODO</strong> Auto-generated catch block</code>
<code>				e.printStackTrace();</code>
<p>
<code>			}</code>
<p>
<code>			System.<strong><em>out</em></strong>.println(i);</code>
<code>		}</code>
<p>
<code>	}</code>
<p>
<code>	<strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {</code>
<code>		JoinExample t1 = <strong>new</strong> JoinExample();</code>
<code>		JoinExample t2 = <strong>new</strong> JoinExample();</code>
<code>		JoinExample t3 = <strong>new</strong> JoinExample();</code>
<code>		t1.start();</code>
<p>
<code>		<strong>try</strong> {</code>
<code>			t1.join();</code>
<p>
<code>		} <strong>catch</strong> (InterruptedException e) {</code>
<code>			// <strong>TODO</strong> Auto-generated catch block</code>
<code>			e.printStackTrace();</code>
<p>
<code>		}</code>
<p>
<code>		t2.start();</code>
<p>
<code>		t3.start();</code>
<p>
<code>	}</code>
<p>
<strong><code>}</code></strong>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>


In above t2, t3 threads waits for t1 thread to die. After completion of t1 thread execution t12, t3 are started.



2. **public void join(long milliseconds)throws InterruptedException :** **_Waits at most milliseconds for this thread to die._** That means it waits for thread to die in give milliseconds. If it won’t die in give time treated as normal thread & executes parallel with other threads if any.

<table>
  <tr>
   <td>
<strong><code>package threads;</code></strong>
<strong><code>public class JoinExample extends Thread {</code></strong>
<code>	@Override</code>
<p>
<code>	<strong>public</strong> <strong>void</strong> run() {</code>
<code>		<strong>for</strong> (<strong>int</strong> i = 1; i &lt;= 10; i++) {</code>
<code>			<strong>try</strong> {</code>
<code>				Thread.<em>sleep</em>(500);</code>
<code>			} <strong>catch</strong> (InterruptedException e) {</code>
<code>			// <strong>TODO</strong> Auto-generated catch block</code>
<code>				e.printStackTrace();</code>
<p>
<code>			}</code>
<p>
<code>			System.<strong><em>out</em></strong>.println(i);</code>
<code>		}</code>
<p>
<code>	}</code>
<p>
<code>	<strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {</code>
<code>		JoinExample t1 = <strong>new</strong> JoinExample();</code>
<code>		JoinExample t2 = <strong>new</strong> JoinExample();</code>
<code>		JoinExample t3 = <strong>new</strong> JoinExample();</code>
<code>		t1.start();</code>
<p>
<code>		<strong>try</strong> {</code>
<code>			t1.join(2500);</code>
<p>
<code>		} <strong>catch</strong> (InterruptedException e) {</code>
<code>			// <strong>TODO</strong> Auto-generated catch block</code>
<code>			e.printStackTrace();</code>
<p>
<code>		}</code>
<p>
<code>		t2.start();</code>
<p>
<code>		t3.start();</code>
<p>
<code>	}</code>
<p>
<strong><code>}</code></strong>
   </td>
   <td>
   </td>
   <td>
   </td>
  </tr>
</table>


If you see in above example t2, t3 threads are waiting for t1 thread to die in 2500 milliseconds. But in given time t1 did not die. So, t2, t3 threads start their execution parallel with t1 thread  


## Thread Priority

Each thread has a priority. Priorities are represented by a number between 1 and 10. In most cases, **thread scheduler schedules the threads according to their priority** (known as preemptive scheduling). **But it is not guaranteed because it depends on JVM specification** that which scheduling it chooses.



1. **public static int MIN_PRIORITY 	//1**
2. **public static int NORM_PRIORITY	//5  (default)**
3. **public static int MAX_PRIORITY	//10**

**Example**


```
public class ThreadPriority extends Thread{
	@Override
	public void run() {
	Thread th= Thread.currentThread();	
	System.out.println("Name :"+th.getName() +"\t Priortity:"+th.getPriority());
	}
	public static void main(String[] args) {
		ThreadPriority t1 = new ThreadPriority();
		ThreadPriority t2 = new ThreadPriority();
		ThreadPriority t3 = new ThreadPriority();


		t1.setPriority(MIN_PRIORITY);
		t2.setPriority(NORM_PRIORITY);
		t3.setPriority(MAX_PRIORITY);


		t1.start();
		t2.start();
		t3.start(); 
	}
}
Name :Thread-2	 Priortity:10
Name :Thread-1	 Priortity:5
Name :Thread-0	 Priortity:1
```


Even though t1 starts first, it has **<code><em>MIN_PRIORITY</em></code></strong> so, it executes last that to depends on JVM Specification 


## Daemon Thread

**Daemon thread** is a thread that provides services to the user thread. There are many java daemon threads running automatically **e.g. gc, finalizer etc.** JVM terminates these thread automatically**.**

We can see all daemon threads using **JConsole** (C:\ProgramFiles\Java\jdk1.8.0_45\bin\jconsole.exe) 

<p id="gdcalert46" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image45.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert47">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image45.png "image_tooltip")




* It provides services to user threads for background supporting tasks. It has no role in life than to serve user threads.
* Its life depends on user threads.
* It is a low priority thread.

We have two methods to dealing the Demon Threads

**1.public void setDaemon(boolean status)	** : set’scurrent thread as daemon thread or user thread.

**2. public boolean isDaemon()**		: is used to check that current is daemon.

**Example**


```
package threads;

public class DemonEx extends Thread {
	@Override
	public void run() {
		Thread th = Thread.currentThread();
		if (th.isDaemon()) {
			System.out.println("DEMON THREAD " + th.getName());
		} else {
			System.out.println("NORMAL THREAD " + th.getName());
		}
	}

	public static void main(String[] args) {
		DemonEx t1 = new DemonEx();
		DemonEx t2 = new DemonEx();

		t1.setDaemon(true);
		t1.start();
		t2.start();
	}
}
DEMON THREAD Thread-0
NORMAL THREAD Thread-1
```


**If you want to make a user thread as Daemon, it must not be started otherwise it will throw IllegalThreadStateException**


```
public static void main(String[] args) {
		DemonEx t1 = new DemonEx();
		DemonEx t2 = new DemonEx();
		t1.start();
		t1.setDaemon(true);		
		t2.start();
	}
Exception in thread "main" java.lang.IllegalThreadStateException
	at java.lang.Thread.setDaemon(Thread.java:1352)
	at threads.DemonEx.main(DemonEx.java:18)
```



## Thread Group

Thread Group is a process of grouping multiple threads in to a single object. We can suspend, interrupt & resume in a single method call.

**Constructors **

**ThreadGroup(String name)	**		creates a thread group with given name.

**ThreadGroup(ThreadGroup parent, Str name)**creates a thread group with given parent group & name.

**int activeCount()	**	returns no. of threads running in current group.

**int activeGroupCount()	**returns a no. of active group in this thread group.

**void destroy()		**	destroys this thread group and all its sub groups.

**String getName()	**	returns the name of this group.

**ThreadGroup getParent()**	returns the parent of this group.

**void interrupt()		**interrupts all threads of this group.

**void list()		**	prints information of this group to standard console.

**Example**


```
class ThreadEx extends Thread {
	@Override
	public void run() {
	Thread th = Thread.currentThread();
System.out.println("Thread Name:"+th.getName()+"Name:"+ th.getThreadGroup());
	}
}
public class ThreadGroupDemo {
	public static void main(String[] args) throws InterruptedException {
		ThreadGroup tg = new ThreadGroup("SmlCodes Group");
		ThreadEx thread = new ThreadEx();
		// adding thraeds to Theard Group
		Thread t1 = new Thread(tg, thread, "Thread-1");
		t1.start();
		Thread t2 = new Thread(tg, thread, "Thread-2");
		t2.start();
		Thread t3 = new Thread(tg, thread, "Thread-3");
		t3.start();
		tg.list();
	}
}
```


**Output**


```
java.lang.ThreadGroup[name=SmlCodes Group,maxpri=10]
Thread Name: Thread-3 	 Thread Group Name: java.lang.ThreadGroup[name=SmlCodes Group,maxpri=10]
Thread Name: Thread-1 	 Thread Group Name: java.lang.ThreadGroup[name=SmlCodes Group,maxpri=10]
Thread Name: Thread-2 	 Thread Group Name: java.lang.ThreadGroup[name=SmlCodes Group,maxpri=10]
    Thread[Thread-1,5,SmlCodes Group]
    Thread[Thread-2,5,SmlCodes Group]
    Thread[Thread-3,5,SmlCodes Group]
```



## Synchronization

Synchronization is a process of allowing only one thread at a time

**<span style="text-decoration:underline;">Lock</span>**: Synchronization is built around an internal entity known as the lock or monitor. Every object has a lock associated with it. By convention, a thread that needs consistent access to an object's fields has to acquire the object's lock before accessing them, and then release the lock when it's done with them.

**Problem without Synchronization**


```
class Counter implements Runnable {
	private int count;
	@Override
	public void run() {
		for (int i = 1; i <= 5; i++) {
			waitCounter (i);
			count++;
		}
	}

	public int getCount() {
		return this.count;
	}
	public void waitCounter(int i) {
	try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
public class ThreadSafety {
	public static void main(String[] args) throws InterruptedException {
		Counter c = new Counter();
		Thread t1 = new Thread(c);
		t1.start();
		Thread t2 = new Thread(c);
		t2.start();
		// wait for threads to finish processing
		t1.join();
		t2.join();
		System.out.println("Processing count=" + c.getCount());
	}
}
Processing count=8
```


In above example for a single thread **Counter** we created two child threads t1,t2 and **count** is a variable common for those two threads. **After completion of thread execution, the counter must be 10**. But **here it is displaying output as 8** because two threads are executing parallel on same method **waitCounter(),** the result may is overlapped two threads are executing same method at same time.

To resolve these types of problems we use synchronization. We can implement synchronization is **3 ways**

**1. Synchronized Instance Methods**

**2. Synchronized Static Methods.**

**3. Synchronized Blocks**


### **<span style="text-decoration:underline;">1. Synchronized Instance methods</span>**: 

If the ordinary instance method is made it as **synchronized,** then the object of the corresponding class will be locked


```
	synchronized void waitCounter(int i) {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
```



### **<span style="text-decoration:underline;">2. Synchronized static method</span>**

 If an ordinary static method is made it as synchronized then the corresponding class will be locked.


```
synchronized static void waitCounter(int i) {
		try {
			Thread.sleep(1000);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
```



### 3. Synchronized block:

When we inherit non-synchronized methods from either base class or interface into the derived class, we cannot make the inherited method as synchronized. Hence, we must use synchronized blocks


```
	public void waitCounter(int i) {
		synchronized (this) {
			try {
				Thread.sleep(1000);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}	
		}		
	}
```


If you use any of above methods the output should be **<code>Processing count=10</code></strong>


## Inter Thread Communication

If a Thread is synchronized only one thread should be access at a time. To access multiple threads on synchronized resource their should be some communication between them. Inter-thread communication or Co-operation is all about allowing synchronized threads to communicate with each other.

**Inter-thread communication** is a mechanism in which **a thread is paused running in its critical section and another thread is allowed to enter (or lock) in the same critical section to be executed**. It is implemented by following **methods of Object class**:



* **void wait()**	- waits the current thread until another thread invokes the notify()
* **void wait (long ms)-** waits the current thread until another thread invokes the notify()/specified amount of time
* **void notify()**	-Wakes up a single thread that is waiting on this object's monitor.
* **void notifyAll()**	-Wakes up all threads that are waiting on this object's monitor.


### 1. What is a Monitor?

In general terms  monitor can be considered as a building which contains a special room. The special room can be occupied by only one customer(thread) at a time. The room usually contains some data and code.


    

<p id="gdcalert47" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image46.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert48">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image46.jpg "image_tooltip")



    A monitor is mechanism to control concurrent access to an object.

Thread 1:


```
public void a()
{
    synchronized(someObject) {
        // do something (1)
    }
}
```


Thread 2:


```
public void b()
{
    synchronized(someObject) {
        // do something else (2)
    }
}
```


This prevents Threads 1 and 2 accessing the monitored (synchronized) section at the same time. One will start, and monitor will prevent the other from accessing the region before the first one finishes.



<p id="gdcalert48" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image47.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert49">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image47.png "image_tooltip")



### 2 Difference between lock and monitor



<p id="gdcalert49" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image48.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert50">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image48.png "image_tooltip")


 Above figure shows the monitor as three rectangles. In the center, a large rectangle contains a single thread, the monitor’s owner. On the left, a small rectangle contains the entry set. On the right, another small rectangle contains the wait set.

Locks help threads to work independently on shared data without interfering with one another, wait-sets help threads to cooperate with one another to work together towards a common goal e.g. all waiting threads will be moved to this wait-set and all will be notified once lock is released. This wait-set helps in building monitors with additional help of lock (mutex).

**Example Inter Thread Communication**


```
class Customer {
	int amount = 10000;

	synchronized void withdraw(int amount) {
		System.out.println("WITHDRAWING \n****************");
		if (this.amount < amount) {
		System.out.println(" LESS BALANCE !!!!");
		try {
	System.out.println("withdraw() is on wait untill deposit() notify ");
				wait();
			} catch (Exception e) {
			}
		}
		this.amount -= amount;
		System.out.println(" ******* WITHDRAW COMPLETED **********");
	}

	synchronized void deposit(int amount) {
		System.out.println("\n\n DEPOSITING \n ****************");
		this.amount += amount;
		System.out.println("DEPOSIT COMPLETED ");
		System.out.println("calling nofity on withdraw()");
		notify();
	}
}

public class InterThreadCom {
	public static void main(String args[]) {
		final Customer c = new Customer();
		new Thread() {
			public void run() {
				c.withdraw(15000);
			}
		}.start();
		new Thread() {
			public void run() {
				c.deposit(10000);
			}
		}.start();
	}
}
WITHDRAWING 
****************
 LESS BALANCE !!!!
withdraw() is on wait untill deposit() notify 

 DEPOSITING 
 ****************
DEPOSIT COMPLETED 
calling nofity on withdraw()
 ******* WITHDRAW COMPLETED **********
```



### 3 Difference between wait and sleep

Let's see the important differences between wait and sleep methods.


<table>
  <tr>
   <td><strong>wait()</strong>
   </td>
   <td><strong>sleep()</strong>
   </td>
  </tr>
  <tr>
   <td>
    wait() method releases the lock
   </td>
   <td>
    sleep() method doesn't release the lock.
   </td>
  </tr>
  <tr>
   <td>
    is the method of Object class
   </td>
   <td>
    is the method of Thread class
   </td>
  </tr>
  <tr>
   <td>
    is the non-static method
   </td>
   <td>
    is the static method
   </td>
  </tr>
  <tr>
   <td>
    should be notified by notify() or notifyAll() methods
   </td>
   <td>
    after the specified amount of time, sleep is completed.
   </td>
  </tr>
</table>


**wait(), notify() and notifyAll() methods are defined in Object class s because they are related to lock and object has a lock**


# 9. java.util.Concurrency 

**java.util.concurrent** package introduced in version 5.0 with following features



* [Lock objects](https://docs.oracle.com/javase/tutorial/essential/concurrency/newlocks.html) support locking idioms that simplify many concurrent applications.
* [Executors](https://docs.oracle.com/javase/tutorial/essential/concurrency/executors.html) define a high-level API for launching and managing threads. Executor implementations provided by java.util.concurrentprovide thread pool management suitable for large-scale applications.
* [Atomic variables](https://docs.oracle.com/javase/tutorial/essential/concurrency/atomicvars.html) have features that minimize synchronization and help avoid memory consistency errors.
* [ThreadLocalRandom](https://docs.oracle.com/javase/tutorial/essential/concurrency/threadlocalrandom.html) (in JDK 7) provides efficient generation of pseudorandom numbers from multiple threads.
* [Concurrent collections](https://docs.oracle.com/javase/tutorial/essential/concurrency/collections.html) make it easier to manage large collections of data, and can greatly reduce the need for synchronization.


## Lock Interface

**java.util.concurrent.locks.Lock **interface is used to as a **thread synchronization mechanism similar to synchronized blocks.**



<p id="gdcalert50" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image49.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert51">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image49.png "image_tooltip")


[https://www.youtube.com/watch?v=ahBC69_iyk4&index=13&t=1s&list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6](https://www.youtube.com/watch?v=ahBC69_iyk4&index=13&t=1s&list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6)

**Scenario**

1.In BookTicket only one thread is allowed to Book Ticket



<p id="gdcalert51" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image50.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert52">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image50.png "image_tooltip")
 

2.Here Thread-1 get the lock, other threads will wait until in waiting Queu, t1 releases the Lock



<p id="gdcalert52" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image51.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert53">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image51.png "image_tooltip")




<p id="gdcalert53" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image52.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert54">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image52.png "image_tooltip")




<p id="gdcalert54" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image53.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert55">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image53.png "image_tooltip")


3.Once Lock got released, remaiing threads will try to get the Lock. Process will continue.



<p id="gdcalert55" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image54.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert56">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image54.png "image_tooltip")


**Methods**

**1.void lock()** – To aquire Lock.if lock is already availabale current thread will get that lock.if lock is not available it waits untill get the lock.it is similar to sysnchronized keyword.

**2.void unlock()** – Releases the lock.if we call on thread which is not having lock it will thorws runtime exception  **IllegalMonitorStateException**

**3.boolean tryLock() **– To quire lock waitout waiting.if it aquires lock returns true, if not false & continues it execution without waiting.in this case thread never goes into waiting state


```
if(l.tryLock())
{//perform safe operations
}else{
	//perform alternative operations 
```


`}` 

**4.boolean tryLock(long time, TimeUnit unit) – **Same as above, but specifying time.TimeUnit is Enum having values as NANOSECONDS,SECONDS,MINITUES,HOURS,DAYS


```
if(l.tryLock(1000,TimeUnit.MINITUES)) //waiting for 1000 minitues
{//perform safe operations
}else{
	//perform alternative operations 
```


`}` 

**4. void lockInterruptibly()** – Aquires lock if available & returns immdefiatly. Not available it will wait.while waiting if thread is interruped then thread wont get the lock.

**Synchronization VS Locks**

There are few differences between the use of synchronized _block_ and using _Lock_ API’s 



* **A _synchronized_ _block_ is fully contained within a method – **we can have _Lock_ API’s  **lock()** and **unlock()** operation in separate methods.

    ```
    Lock lock = ...; 
    lock.lock();
    try {
        // access to the shared resource
    } finally {
        lock.unlock();
    }
    ```


* A s_ynchronized block_ does not support **the fairness**, any thread can acquire the lock ones released, no preference can be specified. We can achieve fairness within the Lock APIs by specifying the **fairness property**. It makes sure that longest waiting thread is given access to lock.
* A thread gets blocked if it can’t get an access to the synchronized _block_. **The _Lock_ API provides _tryLock() _method. The thread acquires lock only if it’s available and not held by any other thread.** This reduces blocking time of thread waiting for the lock.

    ```
    if(l.tryLock())
    {//perform safe operations
    }else{
    	//perform alternative operations 
    } 
    ```


* A thread which is in “waiting” state to acquire the access to **_synchronized block_**, can’t be interrupted. **The _Lock_ API provides a method _lockInterruptibly() _which can be used to interrupt the thread when it is waiting for the lock**


### **<span style="text-decoration:underline;">ReentrantLock</span>**  Interface

it is the **implementation** class of **Lock interface **& direct child class of Object.Reentrant means A thread can aquire same lock multiple times without any issue. 

Internally ReentrantLock increments threads personel count when ever we call lock() & decrements count() value when ever thraed calls unlock(). Lock will realesed when ever count reaches 0

**<span style="text-decoration:underline;">1.lock on a resource more than once</span>**

ReentrantLock allow threads to enter into **lock on a resource more than once**. When the thread first enters into lock, a **hold count** is set to one. Before unlocking the thread can re-enter into lock again and every time hold count is incremented by one. For every unlock request, hold count is decremented by one and when hold count is 0, the resource is unlocked

**<span style="text-decoration:underline;">2.offer a fairness parameter</span>**

after a thread unlocks the resource, the lock would go to the thread which has been waiting for the longest time. This fairness mode is set up by passing true to the constructor of the lock. 

<p id="gdcalert56" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image55.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert57">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image55.png "image_tooltip")


**Methods**

It has all the methods which are thir in Lock interface, additoionally it has following methods.

**getHoldCount():** This method returns the count of the number of locks held on the resource

**isHeldByCurrentThread():** This method returns true if the lock on the resource is held by the current thread.

**Example**


```
package locks;

import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

class ReentrantDemo implements Runnable {

	static int i = 0;
	Lock lock = new ReentrantLock();

	@Override
	public void run() {
		increment();
	}

	public void increment() {
		try {
			if (lock.tryLock(2, TimeUnit.SECONDS)) {

				i++;
		System.out.println(Thread.currentThread().getName() + " Got Lock: incremented, i=" + i);
				Thread.sleep(1000);

			}

			else {
		System.out.println(Thread.currentThread().getName() + " Iam doing Something else");
			}

		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			lock.unlock();
		}
	}

	public static void main(String[] args) {
		// TODO Auto-generated method stub

		ReentrantDemo ob = new ReentrantDemo();

		Thread t1 = new Thread(ob, "One");
		Thread t2 = new Thread(ob, "Two");
		Thread t3 = new Thread(ob, "Three");

		t1.start();
		t2.start();
		t3.start();
	}
}
One Got Lock: incremented, i=1
Three Got Lock: incremented, i=2
Two Got Lock: incremented, i=3
```


**HoldCount Example**


```
package locks;

import java.util.concurrent.locks.ReentrantLock;

public class HoldCount extends Thread {
	static int i = 1;

	ReentrantLock lock = new ReentrantLock();

	@Override
	public void run() {
		lock.lock();
		System.out.println("one");

		lock.lock();
		System.out.println("Two");

		System.out.println("HOLD Count : " + lock.getHoldCount());
		lock.unlock();

		System.out.println("isHeldByCurrentThread : " + lock.isHeldByCurrentThread());

		System.out.println("HOLD Count : " + lock.getHoldCount());
		lock.unlock();

		System.out.println("HOLD Count : " + lock.getHoldCount());

	}

	public static void main(String[] args) {
		HoldCount t = new HoldCount();
		t.setName("BIG-THREAD");
		t.start();
	}

}
one
Two
HOLD Count : 2
isHeldByCurrentThread : true
HOLD Count : 1
HOLD Count : 0
```



## ReadWriteLock interface 

In addition to _Lock _interface_, _we have a **_ReadWriteLock_** interface which maintains a pair of locks, one for read-only operations, and one for the write operation.


### ReentrantReadWriteLock class

**_ReentrantReadWriteLock_** class is implementation of it



* **_Lock readLock() – _**returns the lock that’s used for reading
* **_Lock writeLock()_** – returns the lock that’s used for writing



<p id="gdcalert57" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image56.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert58">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image56.png "image_tooltip")



```
package locks;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;

public class ReadWriteLockDemo implements Runnable {

	ArrayList list = new ArrayList<>();

	ReadWriteLock rwlock = new ReentrantReadWriteLock(true);

	Lock readLock = rwlock.readLock();
	Lock writeLock = rwlock.writeLock();

	public void write() {
		writeLock.lock();
		int ele = 100;
		list.add(ele);
		System.out.println(Thread.currentThread().getName() + " : Write : " + ele);
		try {
			Thread.sleep(5000);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		writeLock.unlock();
	}

	public void read() {
		if (readLock.tryLock()) {
			int index = list.size();
			int ele = (int) list.get(index - 1);
			System.out.println(Thread.currentThread().getName() + " : Read : " + ele);
			readLock.lock();
		} else {
			System.out.println(Thread.currentThread().getName() + ": Write Lock Not avaialble");
		}

	}

	@Override
	public void run() {
		String thname = Thread.currentThread().getName();
		if (thname.contains("write")) {
			write();
		} else {
			read();
		}
	}

	public static void main(String[] args) throws InterruptedException {
		ReadWriteLockDemo ob = new ReadWriteLockDemo();

		new Thread(ob, "write1").start();
		Thread.sleep(2000);
		new Thread(ob, "read1").start();
		Thread.sleep(5000);
		new Thread(ob, "read2").start();

	}

}
write1 : Write : 100
read1: Write Lock Not avaialble
read2 : Read : 100
```




<p id="gdcalert58" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image57.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert59">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image57.png "image_tooltip")



## Conditions

A java.util.concurrent.locks.Condition interface provides a thread ability to suspend its execution, until the given condition is **true**.

**Alternative for wait & notify**

We can Create Condition object by using **ReentrantLock** and **ReentrantReadWriteLock **Which are implementation classes of Lock interface. You can create condition variable by calling **lock.newCondtion()** method \


**Methods**



* **[await()](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html#await--):**The current thread suspends its execution until it is signalled or interrupted.
* **[await(long time, TimeUnit unit)](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html#await-long-java.util.concurrent.TimeUnit-)** :The current thread suspends its execution until it is signalled, interrupted, or the specified amount of time elapses.
* **[awaitNanos(long nanosTimeout)](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html#awaitNanos-long-)** :The current thread suspends its execution until it is signalled, interrupted, or the specified amount of time elapses.
* **[awaitUninterruptibly()](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html#awaitUninterruptibly--)** :The current thread suspends its execution until it is signalled (cannot be interrupted).
* **[await(long time, TimeUnit unit)](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html#awaitUntil-java.util.Date-)** :The current thread suspends its execution until it is signalled, interrupted, or the specified deadline elapses.
* **[signal()](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html#signal--):**This method wakes a single thread which is waiting for a longtime on this condition.
* **[signalAll()](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html#signalAll--):**This method wakes all threads waiting on this condition.

Condition variables are instance of **java.util.concurrent.locks.Condition** class, which provides inter thread communication methods similar to wait, notify and notifyAll e.g. **await()**, **signal()** and **signalAll()**.

if one thread is waiting on a condition by calling **condition.await()** then once that condition changes, second thread can call **condition.signal()** or **condition.signalAll()** method to notify that its time to wake-up.



<p id="gdcalert59" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image58.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert60">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image58.png "image_tooltip")




<p id="gdcalert60" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image59.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert61">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image59.png "image_tooltip")


Locks are used for Sychronization.We will use Lock and Condition variables for solving classic Producer Consumer problem. 

<p id="gdcalert61" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image60.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert62">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image60.png "image_tooltip")


**Example : solving classic Producer Consumer problem.**


```
package locks;

import java.util.LinkedList;
import java.util.Queue;
import java.util.Random;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ProducerConsumerSolutionUsingLock {

	public static void main(String[] arg) {

		// Object on which producer and consumer thread will operate.
		ProducerConsumerImpl sharedObject = new ProducerConsumerImpl();

		// creating producer and consumer threads.
		Productor p = new Productor(sharedObject);
		Consumer c = new Consumer(sharedObject);

		// starting producer and consumer threads.
		p.start();
		c.start();

	}
}

class ProducerConsumerImpl {

	// Productor consumer problem data.
	private static final int CAPACITY = 10;
	private final Queue queue = new LinkedList<>();
	private final Random theRandom = new Random();

	// Lock and condition variables.
	private final Lock aLock = new ReentrantLock();
	private final Condition bufferNotFull = aLock.newCondition();
	private final Condition bufferNotEmpty = aLock.newCondition();

	public void put() throws InterruptedException {
		aLock.lock();
		try {
			while (queue.size() == CAPACITY) {
				System.out.println(Thread.currentThread().getName() + ": Buffer is full, waiting.");
				bufferNotEmpty.await();
			}

			int number = theRandom.nextInt();
			boolean isAdded = queue.offer(number);
			if (isAdded) {
				System.out.printf("%s added %d into queue %n", Thread.currentThread().getName(), number);

				// signal consumer thread that, buffer has element now
				System.out.println(Thread.currentThread().getName() + ": Signalling that buffer is no more empty now.");
				bufferNotFull.signalAll();
			}
		} finally {
			aLock.unlock();
		}
	}

	public void get() throws InterruptedException {

		aLock.lock();
		try {
			while (queue.size() == 0) {
				System.out.println(Thread.currentThread().getName() + ": Buffer is empty, waiting.");
				bufferNotFull.await();
			}

			Integer value = (Integer) queue.poll();
			if (value != null) {
				System.out.printf("%s consumed %d from queue %n ", Thread.currentThread().getName(), value);

				// Signal producer thread that, buffer me be empty now
				System.out.println(Thread.currentThread().getName() + ": Signalling that buffer may be empty now.");
				bufferNotEmpty.signalAll();
			}
		} finally {
			aLock.unlock();
		}
	}
}

class Productor extends Thread {

	ProducerConsumerImpl producerConsumer;

	public Productor(ProducerConsumerImpl sharedObject) {
		super("PRODUCER");
		this.producerConsumer = sharedObject;
	}

	@Override
	public void run() {
		try {
			producerConsumer.put();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

class Consumer extends Thread {

	ProducerConsumerImpl producerConsumer;

	public Consumer(ProducerConsumerImpl sharedObject) {
		super("CONSUMER");
		this.producerConsumer = sharedObject;
	}

	@Override
	public void run() {
		try {
			producerConsumer.get();
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}
```


[https://www.youtube.com/watch?v=N0mMm5PF5Ow&index=11&t=1s&list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6](https://www.youtube.com/watch?v=N0mMm5PF5Ow&index=11&t=1s&list=PLhfHPmPYPPRk6yMrcbfafFGSbE2EPK_A6)


## Synchronization utilities

**<span style="text-decoration:underline;">Semaphore(CountDownSemaphore)</span>**

Semaphore is one of the synchronization aid provided by Java concurrency util in Java 5 along with other synchronization aids like CountDownLatch, CyclicBarrier, Phaser and Exchanger.

The Semaphore **class** present in java.util.concurrentpackage is a counting semaphore in which a semaphore, conceptually, maintains a set of permits.

Semaphore **class** in Java has two methods that make use of permits-



* **acquire()- **Acquires a permit from **this** semaphore, blocking until one is available, or the thread is interrupted. It has another overloaded version **acquire(int permits).**
* **release**()- Releases a permit, returning it to the semaphore. It has another overloaded method release(**int** permits).

 

**<span style="text-decoration:underline;">How Semaphore works in Java</span>**



* Thread that wants to access the shared resource tries to acquire a permit using acquire() method. At that time if the Semaphore's count is greater than zero thread will acquire a permit and Semaphore's count will be decremented by one.
* If Semaphore's count is zero and thread calls acquire() method, then the thread will be blocked until a permit is available.
* When thread is done with the shared resource access, it can call the release() method to release the permit. That results in the Semaphore's count incremented by one.

**<span style="text-decoration:underline;">Java Semaphore constructors</span>**



* **Semaphore(int permits)**
* **Semaphore(int permits, boolean fair)**

** Scenario**

50 thraeds are trying to access a slow service , where only 3 threads are allowed. 

<p id="gdcalert62" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image61.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert63">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image61.png "image_tooltip")


<p id="gdcalert63" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image62.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert64">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image62.png "image_tooltip")


<p id="gdcalert64" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image63.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert65">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image63.png "image_tooltip")


<p id="gdcalert65" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image64.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert66">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image64.png "image_tooltip")




<p id="gdcalert66" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image65.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert67">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image65.png "image_tooltip")


<p id="gdcalert67" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image66.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert68">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image66.png "image_tooltip")


**Java semaphore example**

Let's see one example where Semaphore is used to control shared access. Here we have a shared counter and three threads using the same shared counter and trying to increment and then again decrement the count. So every thread should first increment the count to 1 and then again decrement it to 0.

 


```
import java.util.concurrent.Semaphore;

public class SemaphoreDemo {
 public static void main(String[] args) {


  Semaphore s = new Semaphore(1);
  SharedCounter counter = new SharedCounter(s);
  // Creating three threads
  Thread t1 = new Thread(counter, "Thread-A");
  Thread t2 = new Thread(counter, "Thread-B");
  Thread t3 = new Thread(counter, "Thread-C");
  t1.start();
  t2.start();
  t3.start();
 }
}

class SharedCounter implements Runnable{


    private int c = 0;
    private Semaphore s;
    SharedCounter(Semaphore s){
     this.s = s;
    }
    // incrementing the value
    public void increment() {
        try {
         // used sleep for context switching
            Thread.sleep(10);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
        c++;
    }
    // decrementing the value
    public void decrement() {    
        c--;
    }

    public int getValue() {
        return c;
    }


    @Override
    public void run() {
     try {
         // acquire method to get one permit
         s.acquire();
         this.increment();
         System.out.println("Value for Thread After increment - " + Thread.currentThread().getName() + " " + this.getValue());
         this.decrement();
         System.out.println("Value for Thread at last " + Thread.currentThread().getName() + " " + this.getValue());
         // releasing permit
         s.release();
     }
        catch (InterruptedException e) {
   // TODO Auto-generated catch block
   e.printStackTrace();
  }
    }
}
Output
Value for Thread After increment - Thread-A 1
Value for Thread at last Thread-A 0
Value for Thread After increment - Thread-B 1
Value for Thread at last Thread-B 0
Value for Thread After increment - Thread-C 1
Value for Thread at last Thread-C 0
```


**<span style="text-decoration:underline;">Binary Semaphore(Mutex)</span>**

A semaphore initialized to one, and which is used such that it only has at most one permit available, can serve as a mutual exclusion lock. This is more commonly known as a binary semaphore, because it only has two states: one permit available, or zero permits available. 

When used in **this** way, the binary semaphore has the property (unlike many Lock implementations), that the "lock" can be released by a thread other than the owner (as semaphores have no notion of ownership). This can be useful in some specialized contexts, such as deadlock recovery.

Mutex – Only one thread to access a resource at once. Example, when a client is accessing a file, no one **else** should have access the same file at the same time.

Mutex is the Semaphore with an access count of 1. Consider a situation of using lockers in the bank. Usually the rule is that only one <span style="text-decoration:underline;">person is allowed to enter the locker room.</span>


```
public class SemaphoreTest {

	// max 1 people
	static Semaphore semaphore = new Semaphore(1);

	static class MyLockerThread extends Thread {

		String name = "";

		MyLockerThread(String name) {
			this.name = name;
		}

		public void run() {

			try {

				System.out.println(name + " : acquiring lock...");
				System.out.println(name + " : available Semaphore permits now: " 
								+ semaphore.availablePermits());

				semaphore.acquire();
				System.out.println(name + " : got the permit!");

				try {

					for (int i = 1; i <= 5; i++) {
		System.out.println(name + " : is performing operation " + i 
								+ ", available Semaphore permits : "
								+ semaphore.availablePermits());
						// sleep 1 second
						Thread.sleep(1000);
					}

				} finally {
					// calling release() after a successful acquire()
					System.out.println(name + " : releasing lock...");
					semaphore.release();
System.out.println(name + " : available Semaphore permits now: " 
								+ semaphore.availablePermits());
				}

			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}

	}

	public static void main(String[] args) {

	System.out.println("Total available Semaphore permits : " + semaphore.availablePermits());

		MyLockerThread t1 = new MyLockerThread("A");
		t1.start();

		MyLockerThread t2 = new MyLockerThread("B");
		t2.start();

		MyLockerThread t3 = new MyLockerThread("C");
		t3.start();

		MyLockerThread t4 = new MyLockerThread("D");
		t4.start();

		MyLockerThread t5 = new MyLockerThread("E");
		t5.start();

		MyLockerThread t6 = new MyLockerThread("F");
		t6.start();

	}
}
```


**<span style="text-decoration:underline;">CountDownLatch</span>**

CountdownLatch is a synchronization mechanisum that allows one or more threads to wait until a set of operations being performed in other threads completes<span style="text-decoration:underline;">.</span>

<span style="text-decoration:underline;">Methods</span>



* **await()	**
* **countDown() **

**Scenario**



<p id="gdcalert68" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image67.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert69">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image67.png "image_tooltip")




<p id="gdcalert69" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image68.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert70">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image68.png "image_tooltip")



```
public class CountDownLatchDemo {
	public static void main(String args[]) {
		final CountDownLatch latch = new CountDownLatch(3);
		Thread cacheService = new Thread(new Service("CacheService", 1000, latch));
		Thread alertService = new Thread(new Service("AlertService", 1000, latch));
		Thread validationService = new Thread(new Service("ValidationService", 1000, latch));

		cacheService.start(); // separate thread will initialize CacheService
		alertService.start(); // another thread for AlertService initialization
		validationService.start();

		// application should not start processing any thread until all service is up
		// and ready to do there job.
		// Countdown latch is idle choice here, main thread will start with count 3
		// and wait until count reaches zero. each thread once up and read will do
		// a count down. this will ensure that main thread is not started processing
		// until all services is up.

		// count is 3 since we have 3 Threads (Services)

		try {
			latch.await(); // main thread is waiting on CountDownLatch to finish
			System.out.println("All services are up, Application is starting now");
		} catch (InterruptedException ie) {
			ie.printStackTrace();
		}

	}

}
/**
 * Service class which will be executed by Thread using CountDownLatch * synchronizer. */
class Service implements Runnable {
	private final String name;
	private final int timeToStart;
	private final CountDownLatch latch;

	public Service(String name, int timeToStart, CountDownLatch latch) {
		this.name = name;
		this.timeToStart = timeToStart;
		this.latch = latch;
	}

	@Override
	public void run() {
		try {
			Thread.sleep(timeToStart);
		} catch (InterruptedException ex) {


		}
		System.out.println(name + " is Up");
		latch.countDown(); // reduce count of CountDownLatch by 1
	}
}
```


**<span style="text-decoration:underline;">CyclicBrarrier</span>**

CyclicBrarrier is a synchronization mechanisum that allows a set of threads to all wait **for** each other to reach a common barrier point.

First a **new** instance of a CyclicBarriers is created specifying the number of threads that the barriers should wait upon.


```
CyclicBarrier newBarrier = new CyclicBarrier(numberOfThreads);
```


<span style="text-decoration:underline;">Methods</span>



* **await()	**

Each and every thread does some computation and after completing it’s execution, calls await() methods as shown:


```
public void run()
{
    // thread does the computation
    newBarrier.await();
}
```


Once the number of threads that called await() equals numberOfThreads, the barrier then gives a way **for** the waiting threads. The CyclicBarrier can also be initialized with some action that is performed once all the threads have reached the barrier. This action can combine/utilize the result of computation of individual thread waiting in the barrier.


```
Runnable action = ... 
//action to be performed when all threads reach the barrier;
CyclicBarrier newBarrier = new CyclicBarrier(numberOfThreads, action);
```


**Scenario**



<p id="gdcalert70" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image69.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert71">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image69.png "image_tooltip")




<p id="gdcalert71" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image70.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert72">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image70.png "image_tooltip")



```
public class CyclicBarrierExample {


    private static class Task implements Runnable {

        private CyclicBarrier barrier;

        public Task(CyclicBarrier barrier) {
            this.barrier = barrier;
        }

        @Override
        public void run() {
            try {
                System.out.println(Thread.currentThread().getName() + " is waiting on barrier");
                barrier.await();
                System.out.println(Thread.currentThread().getName() + " has crossed the barrier");
            } catch (InterruptedException ex) {


            } catch (Exception ex) {


            }
        }
    }

    public static void main(String args[]) {

        //creating CyclicBarrier with 3 parties i.e. 3 Threads needs to call await()
        final CyclicBarrier cb = new CyclicBarrier(3, new Runnable(){
            @Override
            public void run(){
                //This task will be executed once all thread reaches barrier
                System.out.println("All parties are arrived at barrier, lets play");
            }
        });

        //starting each of thread
        Thread t1 = new Thread(new Task(cb), "Thread 1");
        Thread t2 = new Thread(new Task(cb), "Thread 2");
        Thread t3 = new Thread(new Task(cb), "Thread 3");

        t1.start();
        t2.start();
        t3.start();


    }
}
```


**<span style="text-decoration:underline;">Phaser</span>**

Phaser is like a collection of advantages of CountDownLatch and CyclicBarrierClasses

The CountDownLatch is :



* Created with a fixed number of threads
* Cannot be reset
* Allows threads to wait(CountDownLatch#await()) or continue with its execution(CountDownLatch#countDown()).

On the other hand, the CyclicBarrier :



* Can be reset.
* Does not a provide a method for the threads to advance. The threads have to wait till all the threads arrive.
* Created with fixed number of threads.

Now, the Phaser has following properties :



* Number of threads need not be known at Phaser creation time. They can be added dynamically.
* Can be reset and hence is, reusable.
* Allows threads to wait(Phaser#arriveAndAwaitAdvance()) or continue with its execution(Phaser#arrive()).
* Supports multiple Phases(, hence the name phaser).

We will try to understand how the Phaser Class can be used with an example. In this example, we are creating a three threads, which will wait for the arrival all the threads being created. Once all the threads have arrived(marked by arriveAndAwaitAdvance() method) the Phaser allows them through the barrier.

<span style="text-decoration:underline;">Methods</span>



* **awaitAdvance()**
* **arrive()	**

**Scenario**



<p id="gdcalert72" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image71.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert73">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image71.png "image_tooltip")
 

<p id="gdcalert73" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image72.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert74">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image72.png "image_tooltip")




<p id="gdcalert74" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image73.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert75">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image73.png "image_tooltip")



```
public class PhaserExample {
	public static void main(String[] args) throws InterruptedException {
		Phaser phaser = new Phaser();
		phaser.register();// register self... phaser waiting for 1 party (thread)
		int phasecount = phaser.getPhase();
		System.out.println("Phasecount is " + phasecount);
		new PhaserExample().testPhaser(phaser, 2000);// phaser waiting for 2 parties
		new PhaserExample().testPhaser(phaser, 4000);// phaser waiting for 3 parties
		new PhaserExample().testPhaser(phaser, 6000);// phaser waiting for 4 parties
		// now that all threads are initiated, we will de-register main thread
		// so that the barrier condition of 3 thread arrival is meet.
		phaser.arriveAndDeregister();
		Thread.sleep(10000);
		phasecount = phaser.getPhase();
		System.out.println("Phasecount is " + phasecount);

	}

	private void testPhaser(final Phaser phaser, final int sleepTime) {
		phaser.register();
		new Thread() {
			@Override
			public void run() {
				try {
				System.out.println(Thread.currentThread().getName() + " arrived");
				phaser.arriveAndAwaitAdvance();// threads register arrival to the phaser.
					Thread.sleep(sleepTime);
				}

				catch (InterruptedException e) {
					e.printStackTrace();
				}
			System.out.println(Thread.currentThread().getName() + " after passing barrier");
			}
		}.start();
	}
}
```


**<span style="text-decoration:underline;">Exchanger</span>**

The Exchanger Class provides a sort of rendezvous point for two threads, where the threads can exchange their respective Objects with the other thread.

Whenever a thread arrives at the exchange point, it must wait for the other thread to arrive. When the other pairing thread arrives the two threads proceed to exchange their objects.

The Exchanger Class also provides an overloaded version of the parameterless exchange() method, exchange(V x, long timeout, TimeUnit unit). When the exchange method with time-out is used, the waiting thread waits for the period passed as the argument(long timeout). If the corresponding pairing thread does not arrive at the exchange point in that time, the waiting Thread throws a java.util.concurrent.TimeoutException


```
public class ExchangerExample {

	Exchanger exchanger = new Exchanger();

	private class Producer implements Runnable {
		private String queue;

		@Override
		public void run() {
			try {
				// create tasks & fill the queue exchange the full queue for a
				// empty queue with Consumer
				queue = (String) exchanger.exchange("Ready Queue");
				System.out.println(Thread.currentThread().getName() + " now has " + queue);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private class Consumer implements Runnable {

		private String queue;

		@Override
		public void run() {
			try {
				// do procesing & empty the queue exchange the empty queue for a
				// full queue with Producer
				queue = (String) exchanger.exchange("Empty Queue");
				System.out.println(Thread.currentThread().getName() + " now has " + queue);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
	}

	private void start() {
		new Thread(new Producer(), "Producer").start();
		new Thread(new Consumer(), "Consumer").start();
	}

	public static void main(String[] args) {
		new ExchangerExample().start();
	}
}
```


In the above example, we create an Exchanger Object of the type String. The Producer thread produces a “filled queue”and exchanges it with the Consumer thread **for** an “empty queue”.(The filled and empty queue mentioned here are just dummy string object, **for** the sake of brevity.). Similarly, we can proceed to exchange any type of object between two threads, merely by changing the type parameter of Exchanger instance


# 10. Executor Framework	(ThreadPools)

Normally we will create & execute Threads in following way. 

<p id="gdcalert75" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image74.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert76">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image74.png "image_tooltip")


If we want to run 10 threads, we will do in following way 

<p id="gdcalert76" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image75.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert77">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image75.png "image_tooltip")


It we want to run 1000 Threads, then it will become more expensive (more OS Thareds, more Heap). Java will create 1000 OS level Threads to process this. 

<p id="gdcalert77" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image76.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert78">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image76.png "image_tooltip")


We can avoid above situation by create only 10 OS level Threads & submit 1000 jobs to them. 

<p id="gdcalert78" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image77.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert79">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image77.png "image_tooltip")


The code for above example will become 

<p id="gdcalert79" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image78.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert80">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image78.png "image_tooltip")


<p id="gdcalert80" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image79.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert81">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image79.png "image_tooltip")
 

<p id="gdcalert81" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image80.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert82">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image80.png "image_tooltip")


The IdealPool size will be no.of CPU cores your system have. 

<p id="gdcalert82" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image81.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert83">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image81.png "image_tooltip")



## Types of ThreadPools

We have following types of ThreadPools


    **1.SingleThread Pool**


    **2.FixedThreadPool **


    **3.CachedThreadPool **


    **4.ScheduledThreadPool**


    **5.Fork/Join pool**

**1.SingleThread Pool**

A thread pool with only one thread with an unbounded queue, which only executes one task at a time.


```
    static ExecutorService	newSingleThreadExecutor()
```




<p id="gdcalert83" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image82.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert84">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image82.png "image_tooltip")


**2.FixedThreadPool **

A thread pool with a fixed number of threads which share an unbounded queue; if all threads are active when a new task is submitted, they will wait in queue until a thread becomes available


```
    static ExecutorService	newFixedThreadPool(int nThreads)
```




<p id="gdcalert84" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image83.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert85">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image83.png "image_tooltip")


**3.CachedThreadPool **

Creates a thread pool that creates new threads as needed, but will reuse previously constructed threads when they are available


```
static ExecutorService	newCachedThreadPool()
static ExecutorService	newCachedThreadPool(ThreadFactory threadFactory)
```




<p id="gdcalert85" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image84.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert86">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image84.png "image_tooltip")




* It doesn’t any Queue like FixedThraedPool, instaed it has synchronous Queue which holds one task at a time.
* On Submiting Task, it will search for any Thread is free in current threadpool, if not It will create another thread to do the job.
* It will kill the useless threads like, if Threads idle for more than 60 sec.,



<p id="gdcalert86" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image85.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert87">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image85.png "image_tooltip")


**4.ScheduledThreadPool **

creates an executor that can schedule tasks to execute after a given delay, or to execute periodically.


```
static ScheduledExecutorService	newSingleThreadScheduledExecutor()
static ScheduledExecutorService	newScheduledThreadPool(int corePoolSize)
```


It will store the all the tasks which are submitted in Delay Queue

<p id="gdcalert87" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image86.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert88">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image86.png "image_tooltip")




<p id="gdcalert88" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image87.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert89">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image87.png "image_tooltip")


**5.Fork/Join pool:**

 It is a special thread pool that uses the Fork/Join framework to take advantages of multiple processors to perform heavy work faster by breaking the work into smaller pieces recursively. 

<p id="gdcalert89" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image88.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert90">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image88.png "image_tooltip")



### ExecutorService API

In the java.util.concurrent package we have following interfaces to work with Thread pools



* **Executors **— Utility class for getting ExceutorService Objects.
* **Executor **— Used to submit a new task.
* **ExecutorService** — A subinterface of Executor that adds methods to manage lifecycle of threads used to run the submitted tasks and methods to produce a Future to get a result from an asynchronous computation.
* **ScheduledExecutorService** — A subinterface of ExecutorService, to execute commands periodically or after a given delay


#### 1.Executors Utility class

Factory and utility methods for [Executor](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html), [ExecutorService](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html), [ScheduledExecutorService](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html), [ThreadFactory](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadFactory.html), and [Callable](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html) classes defined in this package. This class supports the following kinds of methods:



* Methods that create and return an [ExecutorService](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html) set up with commonly useful configuration settings.
* Methods that create and return a [ScheduledExecutorService](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html) set up with commonly useful configuration settings.
* Methods that create and return a "wrapped" ExecutorService, that disables reconfiguration by making implementation-specific methods inaccessible.
* Methods that create and return a [ThreadFactory](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadFactory.html) that sets newly created threads to a known state.
* Methods that create and return a [Callable](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html) out of other closure-like forms, so they can be used in execution methods requiring Callable.


#### 2.Executor Interface

The [Executor](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html) interface provides a single method, execute


```
void execute(Runnable command)
```


It designed to be a drop-in replacement for a common thread-creation idiom(creation & starting). 


#### 3.ExecutorService Interface



* The [ExecutorService](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html) interface implements executor interface with additional submit() method. 
* Like execute, submit accepts Runnable objects, but also accepts [Callable](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Callable.html) objects, which allow the task to return a value. 
* The submit method returns a [Future](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html) object, which is used to retrieve the Callable return value and to manage the status of both Callable and Runnable tasks.
* ExecutorService also provides methods for submitting large collections of Callable objects. Finally, ExecutorService provides a number of methods for managing the shutdown of the executor. To support immediate shutdown, tasks should handle [interrupts](https://docs.oracle.com/javase/tutorial/essential/concurrency/interrupt.html) correctly.


```
Methods
Future submit(Callable<T> task); 

List<Future<T>> invokeAll(Collection<Callable<T> tasks)      
List<Future<T>> invokeAll(Collection<Callable<T>> tasks,long timeout, TimeUnit unit)

T invokeAny(Collection<Callable<T> tasks)      
T invokeAny(Collection<Callable<T>> tasks,long timeout, TimeUnit unit)

void shutdown();
List shutdownNow();

boolean isShutdown();
boolean isTerminated();
boolean awaitTermination(long timeout, TimeUnit unit)
```



##### <span style="text-decoration:underline;">Callable</span> Interface

The Callable interface is similar to Runnable, contaings call() method which returns a Value & throws CheckedException.


```
public interface Callable<V> {
    V call() throws Exception;
}
```



##### Feature Interface

When ever we use sumbit() method, the result will stored in Feature Object. We have following methods to process the results from Feature Object. 



* **V  get():**get() returns an actual result of the Callable task’s execution or null in the case of Runnable task. Calling the get() method while the task is still running will cause execution to block until the task is properly executed and the result is available.

    ```
    Future<String> future = executorService.submit(callableTask);
    String result = null;
    try {
        result = future.get();
    } catch (InterruptedException | ExecutionException e) {
        e.printStackTrace();
    }
    ```


* **V get(long timeout, TimeUnit unit):**We can avoid blocking, by specicifing time limit to get the result.

    ```
    String result = future.get(200, TimeUnit.MILLISECONDS);
    ```



    If the execution period is longer than specified (in this case 200 milliseconds), a TimeoutExceptionwill be thrown.

* And also we can use cancel() methods if get() taking more time.

    ```
    boolean canceled = future.cancel(true);
    boolean isCancelled = future.isCancelled();
    ```


* **boolean isDone():**used to check if the assigned task is already processed or not.

**Example**


```
class IntCall implements Callable<Integer> {

	@Override
	public Integer call() throws Exception {
		int value = (int) (Math.random() * 50 + 1);
		System.out.println("Generated : " + value);
		return value;
	}
}

public class ExcecutorServiceDemo {

	public static void main(String[] args) throws InterruptedException, ExecutionException {

		// submit(Callable<T> task)
		ExecutorService service = Executors.newSingleThreadExecutor();
		Future future = service.submit(new IntCall());
		System.out.println("Future : " + future.get());

		System.out.println("=================== invokeAll ================= ");
//invokeAll(Collection<Callable<T> tasks)
		List<Callable<Integer>> list = new ArrayList();
		list.add(new IntCall());
		list.add(new IntCall());
		list.add(new IntCall());

		List<Future<Integer>> futures = service.invokeAll(list);
		for (Future<Integer> f : futures) {
			System.out.println(f.get());
		}

		System.out.println("=================== invokeAll ================= ");
		Integer any = service.invokeAny(list);
		System.out.println("==== invokeAny ==== " + any);

		// In general, the ExecutorService will not be automatically destroyed when
		// there is not task to process.
		service.shutdown();

		System.out.println("isShutdown : " + service.isShutdown());
		System.out.println("isTerminated : " + service.isTerminated());
		System.out.println("shutdownNow : " + service.shutdownNow());
	}

}

Generated : 19
Future : 19
=================== invokeAll ================= 
Generated : 26
Generated : 41
Generated : 42
26
41
42
=================== invokeAll ================= 
Generated : 6
Generated : 22
==== invokeAny ==== 6
isTerminated : false
shutdownNow : []
```



#### 4.ScheduledExecutorService Interface



* The [ScheduledExecutorService](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ScheduledExecutorService.html) interface is child interface ExecutorService .
* It executes a Runnable or Callable task after a specified delay. In addition, the interface defines scheduleAtFixedRate and scheduleWithFixedDelay, which executes specified tasks repeatedly, at defined intervals.
* The ScheduledExecutorService runs tasks after some predefined delay and/or periodically.

**<span style="text-decoration:underline;">1.schedule()</span>**

There are two **schedule()** methods that allow you to execute Runnable or Callable tasks, which will start after the delay


```
    ScheduledFuture schedule (Runnable command, long delay, TimeUnit unit)
    ScheduledFuture schedule (Callable callable, long delay, TimeUnit unit)
```


**<span style="text-decoration:underline;">2.scheduleAtFixedRate()</span>** method lets execute a task periodically after a fixed delay


```
    scheduleAtFixedRate(Runnable r, long initialDelay, long period, TimeUnit u)
```


The following block of code will execute a task after an initial delay of 100 milliseconds, and after that, it will execute the same task every 450 milliseconds.


```
    Future<String> resultFuture = service
      .scheduleAtFixedRate(runnableTask, 100, 450, TimeUnit.MILLISECONDS);
```


If the processor needs more time to execute an assigned task than the period parameter of the scheduleAtFixedRate() method, the ScheduledExecutorService will wait until the current task is completed before starting the next.

**<span style="text-decoration:underline;">3.scheduleWithFixedDelay() </span>**If it is necessary to have a fixed length delay between iterations of the task, scheduleWithFixedDelay() should be used. For example, the following code will guarantee a 150-millisecond pause between the end of the current execution and the start of another one.


```
ScheduledFuture scheduleWithFixedDelay (Runnable command, long initialDelay, long delay, TimeUnit unit)
```


below scheduleWithFixedDelay, scheduleAtFixedRate methods are applicable only for Runnabler typoes butr not Callable Types


```
service.scheduleWithFixedDelay(task, 100, 150, TimeUnit.MILLISECONDS);

ScheduledExecutorService executor = ...;
Runnable command1 = ...;
Runnable command2 = ...;
Runnable command3 = ...;

// Will start command1 after 50 seconds
executor.schedule(command1, 50L, TimeUnit.SECONDS);

// Will start command 2 after 20 seconds, 25 seconds, 30 seconds ...
executor.scheduleAtFixedRate(command2, 20L, 5L, TimeUnit.SECONDS);

// Will start command 3 after 10 seconds and if command3 takes 2 seconds to be
// executed also after 17, 24, 31, 38 seconds...
executor.scheduleWithFixedDelay(command3, 10L, 5L, TimeUnit.SECONDS);
```


**Example**


```
class IntCal implements Callable<Integer> {

	@Override
	public Integer call() throws Exception {
		int value = (int) (Math.random() * 50 + 1);
		System.out.println("Generated : " + value);
		return value;
	}
}

class MyRun implements Runnable{
	@Override
	public void run() {
		System.out.println("Run End @ : "+new Date());


	}
}

public class ScheduledExecutorServiceDemo {

	public static void main(String[] args) throws InterruptedException, ExecutionException {


 ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();


 System.out.println("========= schedule : Start : "+new Date()); 
 Future f1 = service.schedule(new IntCal(), 5, TimeUnit.SECONDS);
 System.out.println("========= schedule get():"+f1.get()+": End : ");  



 System.out.println("========= scheduleAtFixedRate : Start : "+new Date());
  service.scheduleAtFixedRate(new MyRun(), 2, 2, TimeUnit.SECONDS);



 System.out.println("=========  scheduleWithFixedDelay : Start : "+new Date()); 
 service.scheduleWithFixedDelay(new MyRun(), 2, 2, TimeUnit.SECONDS); 		
	}
}

========= schedule : Start : Wed Dec 26 18:16:15 IST 2018
Generated : 15
========= schedule get():15: End : 
========= scheduleAtFixedRate : Start : Wed Dec 26 18:16:21 IST 2018
=========  scheduleWithFixedDelay : Start : Wed Dec 26 18:16:21 IST 2018
Run End @ : Wed Dec 26 18:16:23 IST 2018
Run End @ : Wed Dec 26 18:16:23 IST 2018
Run End @ : Wed Dec 26 18:16:25 IST 2018
Run End @ : Wed Dec 26 18:16:25 IST 2018
Run End @ : Wed Dec 26 18:16:27 IST 2018
Run End @ : Wed Dec 26 18:16:27 IST 2018
```



## Fork/Join

The fork/join framework is an implementation of the ExecutorService interface that helps you take advantage of multiple processors.

 It is designed for work that can be broken into smaller pieces recursively. The goal is to use all the available processing power to enhance the performance of your application 

<p id="gdcalert90" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image89.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert91">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image89.png "image_tooltip")


Here Each of the Thread has it’s own Queue(DeQue – Double ended Queue). 

<p id="gdcalert91" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image90.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert92">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image90.png "image_tooltip")


When on submitting task, the task is didvided into no. of sub-tasks (3 subtasks for example), each sub-task will store in one of the location in DeQue like below 

<p id="gdcalert92" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image91.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert93">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image91.png "image_tooltip")


If a Thread doesn’t have any tasks to execute, it will steale the tasks from other threads from backside of Queue. 

<p id="gdcalert93" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image92.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert94">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image92.png "image_tooltip")




<p id="gdcalert94" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image93.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert95">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image93.png "image_tooltip")




<p id="gdcalert95" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image94.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert96">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image94.png "image_tooltip")


 

The core classes supporting the Fork-Join mechanism are ForkJoinPool and ForkJoinTask

**<span style="text-decoration:underline;">ForkJoinPool</span>**

The ForkJoinPool is basically a specialized implementation of ExecutorService implementing the work-stealing algorithm we talked about above. We create an instance of ForkJoinPool by providing the target parallelism level i.e. the number of processors as shown below:


```
ForkJoinPool pool = new ForkJoinPool(numberOfProcessors);

Where numberOfProcessors = Runtime.getRunTime().availableProcessors();
```


If you use a no-argument constructor, by default, it creates a pool of size that equals the number of available processors obtained using above technique.

There are three different ways of submitting a task to the ForkJoinPool.

**1.execute()** method //Desired asynchronous execution; call its fork method to split the work between multiple threads.

**2.invoke() **method: //Await to obtain the result; call the invoke method on the pool.

**3.submit()** method: //Returns a Future object that you can use for checking status and obtaining the result on its completion.

**<span style="text-decoration:underline;">ForkJoinTask</span>**

This is an abstract class for creating tasks that run within a `ForkJoinPool`. 

The `Recursiveaction` and `RecursiveTask` are the only two direct, known subclasses of `ForkJoinTask`. The only difference between these two classes is that the `RecursiveAction` does not return a value while `RecursiveTask` does have a return value and returns an object of specified type.

In both cases, you would need to implement the compute method in your subclass that performs the main computation desired by the task.

The `ForkJoinTask` class provides several methods for checking the execution status of a task. The isDone() method returns true if a task completes in any way. The isCompletedNormally() method returns true if a task completes without cancellation or encountering an exception, and isCancelled()returns true if the task was cancelled. Lastly, isCompletedabnormally() returns true if the task was either cancelled or encountered an exception.

**Example**


```
package locks;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ForkJoinPool;
import java.util.concurrent.RecursiveTask;

public class ForkJoinDemo {

	public static void main(final String[] arguments) throws InterruptedException, ExecutionException {

		int nThreads = Runtime.getRuntime().availableProcessors();
		System.out.println("No.of Threads : "+nThreads);

		int[] numbers = new int[1000];

		for (int i = 0; i < numbers.length; i++) {
			numbers[i] = i;
		}

		ForkJoinPool forkJoinPool = new ForkJoinPool(nThreads);
		Long result = forkJoinPool.invoke(new Sum(numbers, 0, numbers.length));
		System.out.println("Sum of 1000 num : "+result);
	}

	static class Sum extends RecursiveTask<Long> {
		int low;
		int high;
		int[] array;

		Sum(int[] array, int low, int high) {
			this.array = array;
			this.low = low;
			this.high = high;
		}

		protected Long compute() {

			if (high - low <= 10) {
				long sum = 0;

				for (int i = low; i < high; ++i)
					sum += array[i];
				return sum;
			} else {
				int mid = low + (high - low) / 2;
				Sum left = new Sum(array, low, mid);
				Sum right = new Sum(array, mid, high);
				left.fork();
				long rightResult = right.compute();
				long leftResult = left.join();
				return leftResult + rightResult;
			}
		}
	}
}
No.of Threads : 2
Sum of 1000 num : 499500
```



## Custom ThreadPool

If you the Source code of ExceutorService, few have below method with parameters. So lets understand that.



<p id="gdcalert96" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image95.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert97">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image95.png "image_tooltip")
 

<p id="gdcalert97" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image96.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert98">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image96.png "image_tooltip")




<p id="gdcalert98" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image97.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert99">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image97.png "image_tooltip")




<p id="gdcalert99" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image98.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert100">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image98.png "image_tooltip")




<p id="gdcalert100" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image99.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert101">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image99.png "image_tooltip")




<p id="gdcalert101" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image100.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert102">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image100.png "image_tooltip")




<p id="gdcalert102" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image101.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert103">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image101.png "image_tooltip")


By Defining above parameters properly we can create our own ThreadPoolExecutor.



<p id="gdcalert103" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image102.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert104">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image102.png "image_tooltip")



## Atomic Variables

**<span style="text-decoration:underline;">Volatile Example</span>**



<p id="gdcalert104" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image103.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert105">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image103.png "image_tooltip")




<p id="gdcalert105" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image104.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert106">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image104.png "image_tooltip")


<p id="gdcalert106" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image105.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert107">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image105.png "image_tooltip")


If writerThread() is executed by one thread & readerThread() is ececuted by another thread the ‘x’ value is different for two threds because they are reading value from their LocalCache. Here the chages of X value is not **visible** globally(Field Visibility), because they are changing in **LocalCache.**

**To avoid this we need to use ‘volatile’ keyword for fields. **

The Java **volatile** keyword is used to mark a Java variable as "being stored in main memory". More precisely that means, that every read of a volatile variable will be read from the computer's main memory(Shared Memory), and not from the CPU cache, and that every write to a volatile variable will be written to main memory, and not just to the CPU cache.



<p id="gdcalert107" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image106.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert108">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image106.png "image_tooltip")




* In the above diagram two threads t1, t2 are trying to change the value of flag. 
* If Thread1 changes value flag=false, then it will flush(push) the changes form LocalCache to SharedCache and it will refresh the all Thread LocalCaches with updated value.
* If Thared 2 is tryind to read, it will get updated value.
* Volatile solves the visisbly problem, where Only one operation is perform

**<span style="text-decoration:underline;">Amtomic Problem</span>**

 Atomic - forming a single irreducible unit or component in a larger system.

Incremet(++) is an Compound Operation(multiple).AtomicVaribles makes compound operations as Atomic(Single)



<p id="gdcalert108" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image107.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert109">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image107.png "image_tooltip")


<p id="gdcalert109" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image108.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert110">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image108.png "image_tooltip")


We can solve this problem using Synchronization



<p id="gdcalert110" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image109.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert111">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image109.png "image_tooltip")


Another Way using Atomic Variables



<p id="gdcalert111" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image110.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert112">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image110.png "image_tooltip")




<p id="gdcalert112" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image111.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert113">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image111.png "image_tooltip")


**<span style="text-decoration:underline;">Atomic Varibles</span>**

The [java.util.concurrent.atomic](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/atomic/package-summary.html) package defines classes that support atomic operations on single variables. All classes have **get and set methods **that work like reads and writes on volatile variables.

We have following Atomic classes



* AtomicInteger
* AtomicLong
* AtomicBoolean
* AtomicReference
* AtomicIntegerArray
* AtomicLongArray
* AtomicReferenceArray

**Common methods **



* **incrementAndGet()**: Atomically increments by one the current value.
* **decrementAndGet()**: Atomically decrements by one the current value.
* **addAndGet(int delta)**: Atomically adds the given value to the current value.
* **compareAndSet(int expect, int update):** Atomically sets the value to the given updated value if the current value == the expected value.
* **getAndAdd(int delta): **Atomically adds the given value to the current value.
* **set(int newValue):** Sets to the given value.


## Terms

**Liveness:**

A liveness failure occurs when an activity gets into a state such that it is permanently unable to make forward progress. For example, if thread A is waiting  for a resource that  thread B holds  exclusively, and B never releases  it, A  will wait forever.

**Race Conditions**

A race condition occurs when the correctness of a computation depends on the relative timing or interleaving of multiple threads by the runtime; in other words, when getting the right answer relies on lucky timing.


## Threads Interview Questions

Multiple parts of the same program running concurrently. In this case, we go a step further and divide the same program into multiple parts/threads and run those threads concurrently.



* **Process:**A Process is a program in execution. It has its own address space, a call stack, and link to any resources such as open files.A computer system normally has multiple processes running at a time. The operating system keeps track of all these processes and facilitates their execution by sharing the processing time of the CPU among them.
* **Thread:**A thread is a path of execution within a process. Every process has at least one thread - called the main thread. The main thread can create additional threads within the process.Threads within a process share the process’s resources including memory and open files. However, every thread has its own call stack.

In previous days, we creates a Thread & Calls start() method manually to run the tasks.


```
class A implements Runnable{
	public void run() {
			System.out.println("Thread Call");	
	}
}

public class ThreadDemo {
	public static void main(String[] args) {
		Thread t1 = new Thread(new A());
		t1.start();
	}
}
```


The Concurrency API introduces the concept of an ExecutorService as a higher level replacement for working with threads directly.So we no need to Start the Thread manually.

**Executor** - A simple interface that contains a method called **execute()** to launch a task specified by a Runnable object.

**ExecutorService** - A sub-interface of Executor that adds functionality to manage the lifecycle of the tasks. It also provides a **submit()** method whose overloaded versions can accept a Runnable as well as a Callable object. 


```
//Creates a single thread ExecutorService
ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();

//Creates an ExecutorService that use a pool of 10 threads
ExecutorService fixedExecutorService = Executors.newFixedThreadPool(10);

//Creates a thread pool that creates new threads as needed,unlimited but will reuse previously                                   constructed threads when they are available
ExecutorService cached = Executors.newCachedThreadPool();
```


[Executors](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executors.html) class that contains factory methods for creating different kinds of executor services.


```
Runnable runnable = ()->{ }
Callable<String> call = ()🡪 {}
ExecutorService executorService = ... // Build an executorService

// execute Runnable job
executorService.submit(runnable);

// submit Runnable job
executorService.submit(runnable);

// submit Accepts also a Callable
Future<String> resultFromMyCommand2 = executorService.submit(call);   

// Will wait for runnable and call termination
executorService.shutdown();  

Runnable myCommand3 = ...;
// Will throw a RejectedExecutionException because no new task can be submitted after shutdown
executorService.submit(myCommand3);

class A implements Runnable {
	@Override
	public void run() {		 
			System.out.println("running...");
	}
}

public class ExcecutorDemo {
	public static void main(String[] args) {
		// TODO Auto-generated method stub
		System.out.println("=========1.newSingleThreadExecutor =============");
		ExecutorService service = Executors.newSingleThreadExecutor();
		service.execute(new A());

		System.out.println("=========2.newFixedThreadPool =============");
		ExecutorService fixedthreadpool = Executors.newFixedThreadPool(3);
		fixedthreadpool.execute(new A());
		fixedthreadpool.execute(new A());
		fixedthreadpool.execute(new A());
		// after completion of these 3 next will be executed
		fixedthreadpool.execute(new A());
		fixedthreadpool.execute(new A());

		System.out.println("=========3.newCachedThreadPool =============");
		//It creates no.of threads as Needed, by reusing previos threds
		ExecutorService cached = Executors.newCachedThreadPool();
		cached.execute(new A());
		cached.execute(new A());
		cached.execute(new A());
	}
}
```


 Executors have not stopped automatically, they keep listening for new tasks. An ExecutorService provides two methods **shutdown()** waits for currently running tasks to finish while **shutdownNow()** interrupts all running tasks and shut the executor down immediately.

**<span style="text-decoration:underline;">Callable and Future</span>**

Callable are functional interfaces just like Runnable, I has call() method returns Future&lt;> Object.


```
class Call implements Callable<String> {
	@Override
	public String call() throws Exception {
		return "Hello";
	}
}

public class CallableDemo {
	public static void main(String[] args) throws InterruptedException, ExecutionException {
		ExecutorService service = Executors.newCachedThreadPool();
		Future<String> ob = service.submit(new Call());
		System.out.println(ob.get());
	}
}
```


**<span style="text-decoration:underline;">invokeAll(). invokeAny()</span>**


```
List<Callable<String>> callables = Arrays.asList(
							() -> "task1", 
							() -> "task2", 
							() -> "task3"
                                                  );

ExecutorService service = Executors.newFixedThreadPool(2);

//Invokes all Tasks
List<Future<String>> l = service.invokeAll(callables);
for (Future f : l) {
	          System.out.println(f.get());
}

//Invokes one task from Group of tasks
String  s = service.invokeAny(callables);
System.out.println(s);
task1
task2
task3
task1
```


**ScheduledExecutorService** - A sub-interface of **ExecutorService**. It adds functionality to schedule the execution of the tasks.  In order to periodically run common tasks multiple times, we can utilize scheduled thread pools.


```
// Creates a single thread ScheduledExecutorService
ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();

// Creates a ScheduledExecutorService that use a pool of 5 threads
ScheduledExecutorService service = Executors.newScheduledThreadPool(5);
```


A ScheduledExecutorService is capable of scheduling tasks to run either periodically or once after a certain amount of time has elapsed.


```
// Will start after 50 seconds
	 schedule(callable, delay, unit);
executor.schedule(runnable, 50, TimeUnit.SECONDS); 

// Will start after 20 seconds, 25 seconds, 30 seconds ...
	 schedule(callable, initialdelay, period, unit);
executor.scheduleAtFixedRate(runnable, 20, 5, TimeUnit.SECONDS);

 public class ScheduledThreads {

	static Runnable r1 = () -> {
		System.out.println("One");
	};
	static Runnable r2 = () -> {
		System.out.println("Two");
	};

	public static void main(String[] args) {
		ScheduledExecutorService service = Executors.newSingleThreadScheduledExecutor();


		service.schedule(r1, 5, TimeUnit.SECONDS);


		service.scheduleAtFixedRate(r2, 5, 5, TimeUnit.SECONDS);
	}
}
One
Two
Two
Two
Two
Two
```


**<span style="text-decoration:underline;">Locks</span>**

Instead of using implicit locking via the synchronized keyword the Concurrency API supports various explicit locks specified by the **Lock** interface. Multiple lock implementations are available in the standard JDK which will be demonstrated in the following sections.

**ReentrantLock;**

The class ReentrantLock is a mutual exclusion lock with the same basic behavior as the implicit monitors accessed via the synchronized keyword but with extended capabilities.


```
ReentrantLock lock = new ReentrantLock();
	 int count = 0;

	void increment() {
	    lock.lock();
	    try {
	        count++;
	    } finally {
	        lock.unlock();
	    }
	}
```


**ReadWriteLock**



* _ReentrantReadWriteLock_ class implements the _ReadWriteLock_ interface.
* Let’s see rules for acquiring the _ReadLock _or_ WriteLock _by a thread:
* **Read Lock** – if no thread acquired the write lock or requested for it then multiple threads can acquire the read lock
* **Write Lock** – if no threads are reading or writing then only one thread can acquire the write lock


```
ExecutorService executor = Executors.newFixedThreadPool(2);
Map<String, String> map = new HashMap<>();
ReadWriteLock lock = new ReentrantReadWriteLock();

executor.submit(() -> {
    lock.writeLock().lock();
    try {
        sleep(1);
        map.put("foo", "bar");
    } finally {
        lock.writeLock().unlock();
    }
});

Runnable readTask = () -> {
    lock.readLock().lock();
    try {
        System.out.println(map.get("foo"));
        sleep(1);
    } finally {
        lock.readLock().unlock();
    }
};

executor.submit(readTask);
executor.submit(readTask);
```


**StampedLock**

Same as ReadWriteLock, but it return a stamp represented by a **long** value. Each Stamp is a unique value, that stamp value comapired at unlockWrote()


```
ExecutorService executor = Executors.newFixedThreadPool(2);
Map<String, String> map = new HashMap<>();
StampedLock lock = new StampedLock();

executor.submit(() -> {
    long stamp = lock.writeLock();
    try {
        sleep(1);
        map.put("foo", "bar");
    } finally {
        lock.unlockWrite(stamp);
    }
});

Runnable readTask = () -> {
    long stamp = lock.readLock();
    try {
        System.out.println(map.get("foo"));
        sleep(1);
    } finally {
        lock.unlockRead(stamp);
    }
};

executor.submit(readTask);
executor.submit(readTask);

stop(executor);
```


**<span style="text-decoration:underline;">What happens if we starts same Thread(ob) Twice?</span>**


```
public class ThreadDemo extends Thread {
    @Override
    public void run() {
        System.out.println("Iam Running");
    }
    public static void main(String[] args) {
        ThreadDemo ob = new ThreadDemo();
        ob.start();
        ob.start();
    }
}
Exception in thread "main" java.lang.IllegalThreadStateException
at java.lang.Thread.start(Thread.java:705)
at threads.ThreadDemo.main(ThreadDemo.java:11)
Iam Running
```


**<span style="text-decoration:underline;">What guarantee volatile variable provides?</span>**

volatile provides the guarantee, changes made in one thread is visible to others.

**[What is busy spin?](https://netjs.blogspot.com/2016/06/busy-spinning-in-multi-threading.html)**

Busy spinning or busy wait in a multi-threaded environment is a technique where other threads loop continuously waiting for a thread to complete its task and signal them to start.


```
while(spinningFlag){
 System.out.println("Waiting busy spinning");
}
```


**<span style="text-decoration:underline;">What is Thread Dump? How do you take thread dump in Java?</span>** \
Process has multiple Threads. **Thread dump** is a summary of the state of all **threads** of the process



* ‘**jstack’** is an effective command line tool to capture thread dumps
* **Java VisualVM** is a GUI tool that provides detailed information about the applications 

<p id="gdcalert113" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image112.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert114">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image112.png "image_tooltip")


**<span style="text-decoration:underline;">Why Swing is not thread-safe in Java?</span>**

User can’t click two buttons at a time right ? Since GUI screens are mostly updated in response of user action e.g. when user click a button, and since events are handled in the same Event dispatcher thread, it's easy to update GUI on that thread.

**<span style="text-decoration:underline;">What is a ThreadLocal variable in Java?</span>**

Thread-local variables are variables restricted to a thread, it’s like thread's own copy which is not shared between multiple threads. Java provides a **ThreadLocal** class to support thread-local variables, It extends Object class.



* Basically it is an another way to achieve thread safety apart from writing immutable classes.
* Since Object is no more shared there is no requirement of Synchronization which can improve scalability and performance of application.
* ThreadLocal provides thread restriction which is extension of local variable. ThreadLocal are visible only in single thread. No two thread can see each others thread local variable.
* These variable are generally **private static** field in classes and maintain its state inside thread.
* **void set(Object value), Object get(), void remove() **methods are available** **


```
public class ThreadLocalExample {
	public static class MyRunnable implements Runnable {
		private ThreadLocal<Integer> threadLocal = new ThreadLocal<Integer>();
		public void run() {
			threadLocal.set((int) (Math.random() * 100D));
			System.out.println(threadLocal.get());
		}
	}

	public static void main(String[] args) throws InterruptedException {
		MyRunnable sharedRunnableInstance = new MyRunnable();
		Thread thread1 = new Thread(sharedRunnableInstance);
		Thread thread2 = new Thread(sharedRunnableInstance);
		thread1.start();
		thread2.start();

		thread1.join(); // wait for thread 1 to terminate
		thread2.join(); // wait for thread 2 to terminate
	}
}
-----------
36
16
```


This example creates a single MyRunnable instance which is passed to two different threads. Both threads execute the run() method, and thus sets different values on the ThreadLocal instance. If the access to the set() call had been synchronized, and it had not been a ThreadLocal object, the second thread would have overridden the value set by the first thread \


**<span style="text-decoration:underline;">Write code for thread-safe Singleton in Java?</span>**

When we say thread-safe, which means Singleton should remain singleton even if initialization occurs in the case of multiple threads. 


```
public class DoubleCheckedLockingSingleton {
	private volatile DoubleCheckedLockingSingleton INSTANCE;

	private DoubleCheckedLockingSingleton() {
	}

	public DoubleCheckedLockingSingleton getInstance(){
        if(INSTANCE == null){
           synchronized(DoubleCheckedLockingSingleton.class){
               //double checking Singleton instance
               if(INSTANCE == null){
                   INSTANCE = new DoubleCheckedLockingSingleton();
               }
           }
        }
        return INSTANCE;
    }
}
```


**<span style="text-decoration:underline;">When to use Runnable vs Thread in Java? (Think Inheritance)</span>** \
it's better to implement Runnable then extends Thread if you **also want to extend another class \
**

**<span style="text-decoration:underline;">Difference between Runnable and Callable in Java?  </span>**

Callable was added on JDK 1.5. Main difference between these two is that Callable's **call()** method can return value and throw Exception, which was not possible with Runnable's run() method. Callable return **Future** object, which can hold the result of computation.


```
public class CallableDemo {
   public static void main(String[] args) throws Exception {
	   ExecutorService service =  Executors.newSingleThreadExecutor();
	   SumTask sumTask = new SumTask(20);
	   Future<Integer> future = service.submit(sumTask);
	   Integer result = future.get();
	   System.out.println(result);
   }
}
class SumTask implements Callable<Integer> {
	private int num = 0;
        public SumTask(int num){
   	        this.num = num;
        }
	@Override
	public Integer call() throws Exception {
		int result = 0;
		for(int i=1;i<=num;i++){
			result+=i;
		}
		return result;
	}
} 
```


**<span style="text-decoration:underline;">How to stop a thread in Java?</span>**

There was some control methods in JDK 1.0 e.g**. stop(), suspend() and resume()** which are deprecated. To manually stop, programmers either take advantage of volatile boolean variable and check in every iteration if run method has loops or **interrupt** threads to abruptly cancel tasks. \


**<span style="text-decoration:underline;">Why wait, notify and notifyAll are not inside thread class?</span>** \
 Java provides lock at object level not at thread level. Every object has lock, which is acquired by thread. Now if thread needs to wait for certain lock it make sense to call wait() on that object rather than on that thread. Had wait() method declared on Thread class, it was not clear that for which lock thread was waiting. In short, since wait, notify and notifyAll operate at lock level, it make sense to defined it on object class because lock belongs to object.

**<span style="text-decoration:underline;">What is the difference between livelock and deadlock in Java?</span>** \
A real-world example of livelock occurs when two people meet in a narrow corridor, and each tries to be polite by moving aside to let the other pass, but they end up swaying from side to side without making any progress because they both repeatedly move the same way at the same time. In short, the main difference between livelock and deadlock is that in former state of process change but no progress is made.

**<span style="text-decoration:underline;">How do you check if a Thread holds a lock or not?</span>** \
There is a method called **holdsLock()** on java.lang.Thread, it returns true if and only if the current thread holds the monitor lock on the specified object.  


```
		Thread t = Thread.currentThread();
		System.out.println(Thread.holdsLock(t));
```


**What is Semaphore in Java?** \
Semaphore in Java is a new kind of synchronizer. It's a counting semaphore. Conceptually, a semaphore maintains a set of permits. Each **acquire() **blocks if necessary until a permit is available, and then takes it. Each **release()** adds a permit, potentially releasing a blocking acquirer. However, no actual permit objects are used; the Semaphore just keeps a count of the number available and acts accordingly. Semaphore is used to protect an expensive resource which is available in fixed number e.g. database connection in the pool.

**<span style="text-decoration:underline;">What is the difference between the submit() and execute() method thread pool in Java?</span>**



* **execute(Runnable command)** is defined in Executor interface and executes given task in future, but more importantly, it does not return anything. 
* **submit()** is an overloaded method, it can take either **Runnable or Callable** task and can return Future object which can hold the pending result of computation. This method is defined on ExecutorService interface, which extends Executor interface, and every other thread pool class e.g. ThreadPoolExecutor or ScheduledThreadPoolExecutor gets these methods. 

**<span style="text-decoration:underline;">Which method of Swing API are thread-safe in Java?</span>** \
I know about **repaint(),** and revalidate() being thread-safe but there are other methods on different swing components e.g. **setText() method of JTextComponent, insert() and append()** method of JTextArea class.

 \
**<span style="text-decoration:underline;">What is the difference between the volatile and atomic variable in Java?</span>** \
For example count++ operation will not become atomic just by declaring count variable as volatile. On the other hand AtomicInteger class provides atomic method to perform such compound operation atomically e.g. getAndIncrement() is atomic replacement of increment operator. It can be used to atomically increment current value by one. Similarly, you have atomic version for other data type and reference variable as well.

**<span style="text-decoration:underline;">What happens if a thread throws an Exception inside synchronized block?</span>** \
To answer this question, no matter how you exist synchronized block, either normally by finishing execution or abruptly by throwing exception, thread releases the lock it acquired while entering that synchronized block. \


**<span style="text-decoration:underline;">How do you ensure that N thread can access N resources without deadlock</span>**

Key point here is order, if you acquire resources in a particular order and release resources in reverse order you can prevent deadlock. 

**<span style="text-decoration:underline;">What is busy spin, and why should you use it?</span>**

Busy spinning is a waiting strategy in which one thread loop continuously  to check certain condition and waiting for other thread to change this condition to break the loop without releasing CPU so that waiting thread can proceeds its work further

**<span style="text-decoration:underline;">What’s the difference between Callable and Runnable?</span>**

Both of these are interfaces used to carry out task to be executed by a thread. The main difference between the two interfaces is that 



* Callable can **return a value**, while Runnable cannot. 
* Callable can throw a checked exception, while Runnable cannot. 
* Runnable has been around since Java 1.0, while Callable was introduced as part of Java 1.5.

The _Callable_ interface is a generic interface containing a single _call()_ method – which returns a generic value _V_:


```
public interface Callable<V> {
    V call() throws Exception;
}
class CallableExample implements Callable
{


    public Object call() throws Exception
    {
        Random generator = new Random();
        Integer randomNumber = generator.nextInt(5); 
        Thread.sleep(randomNumber * 1000);


        return randomNumber;
    }
}
```


**<span style="text-decoration:underline;">What is false sharing in the context of multi-threading? </span>**

 false sharing is one of the well-known performance issues on multi-core systems, where each process has its local cache. 



<p id="gdcalert114" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image113.gif). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert115">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image113.gif "image_tooltip")


False sharing is very hard to detect because the thread may be accessing completely different global variables that happen to be relatively close together in memory. Like many concurrency issues, the primary way to avoid false sharing is careful code review and aligning your data structure with the size of a cache line

**<span style="text-decoration:underline;">Object level and Class level locks in Java</span>**

**Object level lock : **Every object in java has a unique lock. Whenever we are using synchronized keyword, then only lock concept will come in the picture. If a thread wants to execute synchronized method on the given object. First, it has to get lock of that object. Once thread got the lock then it is allowed to execute any synchronized method on that object. Once method execution completes automatically thread releases the lock. Acquiring and release lock internally is taken care by JVM and programmer is not responsible for these activities. Lets have a look on the below program to understand the object level lock:


```
class Geek implements Runnable {
    public void run()
    {
        Lock();
    }
    public void Lock()
    {
        System.out.println(Thread.currentThread().getName());
        synchronized(this)
        {
            System.out.println("in block "
                + Thread.currentThread().getName());
            System.out.println("in block " + 
                Thread.currentThread().getName() + " end");
        }
    }
 
    public static void main(String[] args)
    {
        Geek g = new Geek();
        Thread t1 = new Thread(g);
        Thread t2 = new Thread(g);
        Geek g1 = new Geek();
        Thread t3 = new Thread(g1);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();
    }
}
```



```
Run on IDE
Output:
t1
in block t1
in block t1 end
t2
in block t2
in block t2 end
t3
in block t3
in block t3 end
```


**Class level lock : **Every class in java has a unique lock which is nothing but class level lock. If a thread wants to execute a static synchronized method, then thread requires class level lock. Once a thread got the class level lock, then it is allowed to execute any static synchronized method of that class. Once method execution completes automatically thread releases the lock. Lets look on the below program for better understanding:


```
// Java program to illustrate class level lock
class Geek implements Runnable {
    public void run()
    {
        Lock();
    }
 
    public void Lock()
    {
        System.out.println(Thread.currentThread().getName());
        synchronized(Geek.class)
        {
            System.out.println("in block "
                + Thread.currentThread().getName());
            System.out.println("in block "
                + Thread.currentThread().getName() + " end");
        }
    }
 
    public static void main(String[] args)
    {
        Geek g1 = new Geek();
        Thread t1 = new Thread(g1);
        Thread t2 = new Thread(g1);
        Geek g2 = new Geek();
        Thread t3 = new Thread(g2);
        t1.setName("t1");
        t2.setName("t2");
        t3.setName("t3");
        t1.start();
        t2.start();
        t3.start();
    }
}
```


**<span style="text-decoration:underline;">Producer-Consumer solution using threads in Java</span>**



* The producer’s job is to generate data, put it into the buffer, and start again.
* same time, the consumer is consuming the data (i.e. removing it from the buffer), one piece at a time.
* producer won’t try to add data into the buffer if it’s full & consumer won’t try to remove data from an empty buffer


```
class Producer extends Thread {

	List buffer;
	int maxsize;

	public Producer(List buffer, int maxsize) {
		this.buffer = buffer;
		this.maxsize = maxsize;
	}

	@Override
	public void run() {
	int i = 1;
	  while (true) {
	     synchronized (buffer) {
		try {
			if (buffer.size() == maxsize) {
			System.out.println("Maximum Size Reached, wait until consume");
			buffer.wait();
			} else {
			buffer.add(i++);
			System.out.println(i + " : Produced, notify wating COnsumer Thread");
			buffer.notifyAll();

			}
		} catch (InterruptedException e) {
					// TODO Auto-generated catch block
			e.printStackTrace();
		}
		}

		}

	}

}

class Consumer extends Thread {

	List buffer;
	int maxsize;

	public Consumer(List buffer, int maxsize) {
		this.buffer = buffer;
		this.maxsize = maxsize;
	}

	@Override
	public void run() {

	while (true) {
		try {
		synchronized (buffer) {
		if (buffer.isEmpty()) {
			System.out.println("Consumer : Buffer Empty, wait untill produce");
			buffer.wait();
			} else {
			Object ob = buffer.remove(0);
		System.out.println(ob + " : Removed, notify Producer waiting for Removing for maxsize");
 		buffer.notifyAll();
			}
		}
		} catch (Exception e) {
 				// TODO: handle exception
		}

	}

   }

}

public class ProducerConsumer {

	public static void main(String[] args) {

		List buffer = new LinkedList<>();
		Producer producer = new Producer(buffer, 10);
		Consumer consumer = new Consumer(buffer, 10);
		producer.start();
		consumer.start();

	}

}
28054 : Produced, notify wating COnsumer Thread
28055 : Produced, notify wating COnsumer Thread
28056 : Produced, notify wating COnsumer Thread
28057 : Produced, notify wating COnsumer Thread
28058 : Produced, notify wating COnsumer Thread
28059 : Produced, notify wating COnsumer Thread
28060 : Produced, notify wating COnsumer Thread
Maximum Size Reached, wait until consume
28050 : Removed, notify Producer waiting for Removing for maxsize
28051 : Removed, notify Producer waiting for Removing for maxsize
28052 : Removed, notify Producer waiting for Removing for maxsize
28053 : Removed, notify Producer waiting for Removing for maxsize
28054 : Removed, notify Producer waiting for Removing for maxsize
28055 : Removed, notify Producer waiting for Removing for maxsize
28056 : Removed, notify Producer waiting for Removing for maxsize
28057 : Removed, notify Producer waiting for Removing for maxsize
28058 : Removed, notify Producer waiting for Removing for maxsize
28059 : Removed, notify Producer waiting for Removing for maxsize
Consumer : Buffer Empty, wait untill produce
```


**<span style="text-decoration:underline;">Thread. yield () </span>**

**yield() method: **Theoretically, **to ‘yield’ means to let go, to give up, to surrender**. A yielding thread tells the virtual machine that it’s willing to let other threads be scheduled in its place. 

This indicates that it’s not doing something too critical. Note that _it’s only a hint_, though, and not guaranteed to have any effect at all.



* Yield is a Static method and Native too.
* Yield tells the currently executing thread to give a chance to the threads that have equal priority in the [Thread Pool](https://howtodoinjava.com/java-5/java-executor-framework-tutorial-and-best-practices/).
* There is no guarantee that Yield will make the currently executing thread to runnable state immediately.
* It can only make a thread from Running State to Runnable State, not in wait or blocked state.

**<span style="text-decoration:underline;">What do you understand about Thread Priority?</span>**

Every thread has a priority, usually higher priority thread gets precedence in execution but it depends on Thread Scheduler implementation that is OS dependent. We can specify the priority of thread but it doesn’t guarantee that higher priority thread will get executed before lower priority thread.

**<span style="text-decoration:underline;">How can we make sure main() is the last thread to finish in Java Program?</span>**

We can use Thread join() method to make sure all the threads created by the program is dead before finishing the main function.

**<span style="text-decoration:underline;">Why wait(), notify() and notifyAll() methods have to be called from synchronized method or block?</span>**

When a Thread calls wait() on any Object, it must have the monitor on the Object that it will leave and goes in wait state until any other thread call notify() on this Object. Similarly when a thread calls notify() on any Object, it leaves the monitor on the Object and other waiting threads can get the monitor on the Object. Since all these methods require Thread to have the Object monitor, that can be achieved only by synchronization, they need to be called from synchronized method or block.

**<span style="text-decoration:underline;">How can we achieve thread safety in Java?</span>**

There are several ways to achieve thread safety in java – **synchronization, atomic concurrent classes, implementing concurrent Lock interface, using volatile keyword**, using immutable classes and Thread safe classes. 

**<span style="text-decoration:underline;">What is volatile keyword in Java</span>**

When we use volatile keyword with a variable, all the threads read it’s value directly from the memory and don’t cache it. This makes sure that the value read is the same as in the memory.

**<span style="text-decoration:underline;">What is ThreadLocal?</span>**

Java ThreadLocal is used to create thread-local variables. We know that all threads of an Object share it’s variables, so if the variable is not thread safe, we can use synchronization but if we want to avoid synchronization, we can use ThreadLocal variables. \
Every thread has it’s own ThreadLocal variable and they can use it’s get() and set() methods to get the default value or change it’s value local to Thread. ThreadLocal instances are typically private static fields in classes that wish to associate state with a thread

**<span style="text-decoration:underline;">What is Java Thread Dump, How can we get Java Thread dump of a Program?</span>**

Thread dump is list of all the threads active in the JVM, thread dumps are very helpful in analyzing bottlenecks in the application and analyzing deadlock situations. There are many ways using which we can generate Thread dump – Using Profiler, Kill -3 command, jstack tool etc. I prefer jstack tool to generate thread dump of a program because it’s easy to use and comes with JDK installation

**<span style="text-decoration:underline;">What is atomic operation? What are atomic classes in Java Concurrency API?</span>**

Atomic operations are performed in a single unit of task .int++ is not an atomic operation. So by the time one threads read it’s value and increment it by one, other thread has read the older value leading to wrong result.

To solve this issue, we will have to make sure that increment operation on count is atomic, we can do that using Synchronization but Java 5 java.util.concurrent.atomic provides wrapper classes for int and long that can be used to achieve this atomically without usage of Synchronization

**<span style="text-decoration:underline;">What is BlockingQueue? implement Producer-Consumer using Blocking Queue?</span>**



* java.util.concurrent.BlockingQueue is a Queue that supports operations that wait for the queue to become non-empty when retrieving and removing an element, and wait for space to become available in the queue when adding an element.
* BlockingQueue doesn’t accept null values and throw NullPointerException if you try to store null value in the queue.
* BlockingQueue implementations are thread-safe. All queuing methods are atomic in nature and use internal locks or other forms of concurrency control.
* BlockingQueue interface is part of [java collections framework](https://www.journaldev.com/1260/collections-in-java-tutorial) and it’s primarily used for implementing producer consumer problem. \
Check this post for [producer-consumer problem implementation using BlockingQueue](https://www.journaldev.com/1034/java-blockingqueue-example).

**<span style="text-decoration:underline;">What is Executors Class?</span>**

Executors class provide utility methods for Executor, ExecutorService, ScheduledExecutorService, ThreadFactory, and Callable classes.

Executors class can be used to easily create Thread Pool in java, also this is the only class supporting execution of Callable implementations.

**<span style="text-decoration:underline;">What happens when an Exception occurs in a thread?</span>**  \
**Thread.UncaughtExceptionHandler** is an interface, defined as nested interface for handlers invoked when a Thread abruptly terminates due to an uncaught exception. 

When a thread is about to terminate due to an uncaught exception the Java Virtual Machine will query the thread for its UncaughtExceptionHandler using Thread.getUncaughtExceptionHandler() and will invoke the handler's uncaughtException() method, passing the thread and the exception as arguments. \


**<span style="text-decoration:underline;">Why wait, notify and notifyAll are not inside thread class?</span>**  \
One reason which is obvious is that Java provides lock at object level not at thread level.

 \
**<span style="text-decoration:underline;">How do you check if a Thread holds a lock or not?</span>** \
Boolean Thread._holdsLock_(Obj)


# 11. Stream API

Java lambda expressions are new in Java 8. **Java lambda expressions are Java's first step into functional programming.**

Java lambda expressions are commonly used to implement simple event listeners / callbacks, or in functional programming with the [Java Streams API](http://tutorials.jenkov.com/java-collections/streams.html)


## Functional Interfaces


```
Runnable r = new Runnable(){
			@Override
			public void run() {
				System.out.println("My Runnable");
			}};
```


If you look at the above code, the actual part that is of use is the code inside run() method. Rest all of the code is because of the way java programs are structured.

Java 8 Functional Interfaces and Lambda Expressions help us in writing smaller and cleaner code by removing a lot of **boiler-plate** code.



* **An interface with exactly one abstract method is called Functional Interface**. 
* **@FunctionalInterface annotation **is added so that we can mark an interface as functional interface.
* If the interface is annotated with `@FunctionalInterface` annotation and we try to have more than one abstract method, **it throws compiler error**.
* The major benefit of java 8 functional interfaces is that we can use **lambda expressions** to instantiate them and avoid using bulky anonymous class implementation

Java 8 has defined a lot of functional interfaces in java.util.function package. Some of the useful java 8 functional interfaces are Predicate, Function, Consumer, Supplier, 

**java.util.function Package:**

The java.util.function package in Java 8 contains many builtin functional interfaces like-

**1.Predicate**: The Predicate interface has an abstract method **test()** which gives a **Boolean** value as a result for the specified argument. Its prototype is


```
public Predicate
{
   public boolean test(T  t);
 }
```


**2.Function**: The Function interface has an abstract method **apply** which takes argument of type T and **returns** **a result of type** R. Its prototype is


```
public interface Function 
{
   public R apply(T t);
}
```


**3.Consumer Interface:** is [a functional interface](https://www.baeldung.com/java-8-functional-interfaces) (an interface with a single abstract method). It accepts an input and returns no result.


```
@FunctionalInterface
public interface Consumer {
    void accept(T t);
}
```


And it contains default method **andThen**(Consumer&lt;? super T> after)

**4.Supplier Interfac**: In all scenarios where there is no input to an operation and it is expected to return an output the in-built functional interface **Supplier&lt;T>** can be used without the need to define a new functional interface every time.


```
@FunctionalInterface
public interface Supplier<T> {
    T get();
}
```


**5.BinaryOperator**: The BinaryOperator interface has an abstract method **apply** which takes two argument and returns a result of same type. Its prototype is


```
public interface BinaryOperator 
{
     public T apply(T x, T y);
}       
```



## Lambdas

Lambda’s are used to provide the **implementation of Functional interface, Less coding**.

Lambda Expressions syntax is **(argument) -> (body)**. Now let’s see how we can write above anonymous Runnable using lambda expression.


```
Runnable r1 = () -> System.out.println("My Runnable");

```



* The body of a lambda expression can contain zero, one or more statements.
* When there is a single statement curly brackets are not mandatory and the return type of the anonymous function is the same as that of the body expression.
* When there are more than one statements, then these must be enclosed in curly brackets (a code block) and the return type of the anonymous function is the same as the type of the value returned within the code block, or void if nothing is returned

**1.Zero parameter:**


```
    () -> System.out.println("Zero parameter lambda");
```


**2.One parameter:–**


```
    (p) -> System.out.println("One parameter: " + p);
```



    It is not mandatory to use parentheses, if the type of that variable can be inferred from the context

**3.Multiple parameters :**


```
    (p1, p2) -> System.out.println("Multiple parameters: " + p1 + ", " + p2);
```


**Java Lambda Expression Example: Foreach Loop**

Java provides a new method forEach() to iterate the elements. It is defined in Iterable and Stream interface. It is a default method defined in the Iterable interface. Collection classes which extends Iterable interface can use forEach loop to iterate elements.

default**<code> </code></strong>void<strong><code> forEach(Consumer&lt;</code></strong>super<strong><code> T>action) </code></strong>

_“performs the given action for each element of the Iterable until all elements have been processed or the action throws an exception.”_


```
public class LambdaExpressionExample7{  
    public static void main(String[] args) {            
        List<String> list=new ArrayList<String>();  
        list.add("ankit");  
        list.add("mayank");  
        list.add("irfan");  
        list.add("jai");            
        list.forEach(  
            (n)->System.out.println(n)  
        );  
    }  
} 
```


This code will print every element of the list. You can even replace lambda expression with [method reference](http://javarevisited.blogspot.com/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html) because we are passing the lambda parameter as it is to the System.out.println() method as   \
 **<code>list.forEach(System.out::println);</code></strong>



* forEach() is a terminal operation, which means once calling forEach() method on stream, you cannot call another method. It will result in a runtime exception.
* When you call `forEach()` on parallel stream, the [order of iteration](http://java67.blogspot.com/2014/05/3-examples-to-loop-map-in-java-foreach.html) is not guaranteed, but you can ensure that ordering by calling `forEachOrdered()` method.
* There are two forEach() method in Java 8, one defined inside `Iterable` and other inside `java.util.stream.Stream` class. If purpose of forEach() is just iteration then you can directly call it e.g.` list.forEach()` or `set.forEach()` but if you want to perform some operations e.g. filter or map then better first get the stream and then perform that operation and finally call forEach() method.
* Use of forEach() results in readable and cleaner code.

**Java Lambda Expression Example: Comparator**


```
Collections.sort(list,(p1,p2)->{  
    return p1.name.compareTo(p2.name);  
    });  
    for(Product p:list){  
        System.out.println(p.id+" "+p.name+" "+p.price); 
    }  
```



## Streams

A stream represents a sequence of elements and supports different kind of operations to perform computations upon those elements.

Stream operations are either intermediate or terminal. 



* **Intermediate** operations return a **stream** so we can chain multiple intermediate operations without using semicolons. 
* **Terminal** operations are either void or return a non-stream result

**How Stream Work**



<p id="gdcalert115" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image114.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert116">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image114.png "image_tooltip")




<p id="gdcalert116" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image115.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert117">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image115.png "image_tooltip")




<p id="gdcalert117" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image116.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert118">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image116.png "image_tooltip")



```
List<String> myList =  Arrays.asList("a1", "a2", "b1", "c2", "c1");

myList
    .stream()
    .filter(s -> s.startsWith("c"))
    .map(String::toUpperCase)
    .sorted()
    .forEach(System.out::println);
```


In the above example `filter`, `map` and `sorted` are intermediate operations whereas `forEach` is a terminal operation.

Streams can be created from various data sources, especially collections. Lists and Sets support new methods **stream()** and **parallelStream()** to either create a sequential or a parallel stream.

**Parallel streams** **are capable of operating on multiple threads** 

**<span style="text-decoration:underline;">The features of Java stream are </span>**



* A stream is not a data structure instead it takes input from the Collections, Arrays or I/O channels.
* **Streams don’t change the original data structure**, they only provide the result as per the pipelined methods.
* Each intermediate operation is lazily executed and returns a stream as a result, hence various intermediate operations can be pipelined. Terminal operations mark the end of the stream and return the result.

**<span style="text-decoration:underline;">1.Obtaining a Stream</span>**


```
		//1.Stream of Collection
		Collection<String> collection = Arrays.asList("a", "b", "c");
		Stream<String> streamOfCollection = collection.stream();

		//2.Stream of Arrays
		Stream<String> streamOfArray = Stream.of("a", "b", "c");
```


**Stream Operations : Intermediate**


<table>
  <tr>
   <td><strong>Operation</strong>
   </td>
   <td>Contents
   </td>
  </tr>
  <tr>
   <td><strong>filter(Predicate&lt;T>)</strong>
   </td>
   <td>The elements of the stream matching the predicate
   </td>
  </tr>
  <tr>
   <td><strong>map(Function&lt;T, U>)</strong>
   </td>
   <td>The result of applying the provided function to the elements of the stream
   </td>
  </tr>
  <tr>
   <td><strong>flatMap(Function&lt;T, Stream&lt;U>></strong>
   </td>
   <td>The elements of the streams resulting from applying the provided stream-bearing function to the elements of the stream
   </td>
  </tr>
  <tr>
   <td><strong>distinct()</strong>
   </td>
   <td>The elements of the stream, with duplicates removed
   </td>
  </tr>
  <tr>
   <td><strong>sorted()</strong>
   </td>
   <td>The elements of the stream, sorted in natural order
   </td>
  </tr>
  <tr>
   <td><strong>Sorted(Comparator&lt;T>)</strong>
   </td>
   <td>The elements of the stream, sorted by the provided comparator
   </td>
  </tr>
  <tr>
   <td><strong>limit(long)</strong>
   </td>
   <td>The elements of the stream, truncated to the provided length
   </td>
  </tr>
  <tr>
   <td><strong>skip(long)</strong>
   </td>
   <td>The elements of the stream, discarding the first N elements
   </td>
  </tr>
  <tr>
   <td><strong>takeWhile(Predicate&lt;T>)</strong>
   </td>
   <td>(Java 9 only) The elements of the stream, truncated at the first element for which the provided predicate is not true
   </td>
  </tr>
  <tr>
   <td><strong>dropWhile(Predicate&lt;T>)</strong>
   </td>
   <td>(Java 9 only) The elements of the stream, discarding the initial segment of elements for which the provided predicate is true
   </td>
  </tr>
</table>


**Terminal Operations**


<table>
  <tr>
   <td><strong>forEach(Consumer&lt;T> action)</strong>
   </td>
   <td>Apply the provided action to each element of the stream.
   </td>
  </tr>
  <tr>
   <td><strong>toArray()</strong>
   </td>
   <td>Create an array from the elements of the stream.
   </td>
  </tr>
  <tr>
   <td><strong>reduce(...)</strong>
   </td>
   <td>Aggregate the elements of the stream into a summary value.
   </td>
  </tr>
  <tr>
   <td><strong>collect(...)</strong>
   </td>
   <td>Aggregate the elements of the stream into a summary result container.
   </td>
  </tr>
  <tr>
   <td><strong>min(Comparator&lt;T>)</strong>
   </td>
   <td>Return the minimal element of the stream according to the comparator.
   </td>
  </tr>
  <tr>
   <td><strong>max(Comparator&lt;T>)</strong>
   </td>
   <td>Return the maximal element of the stream according to the comparator.
   </td>
  </tr>
  <tr>
   <td><strong>count()</strong>
   </td>
   <td>Return the size of the stream.
   </td>
  </tr>
  <tr>
   <td><strong>{any,all,none}Match(Predicate&lt;T>)</strong>
   </td>
   <td>Return whether any/all/none of the elements of the stream match the provided predicate.
   </td>
  </tr>
  <tr>
   <td><strong>findFirst()</strong>
   </td>
   <td>Return the first element of the stream, if present.
   </td>
  </tr>
  <tr>
   <td><strong>findAny()</strong>
   </td>
   <td>Return any element of the stream, if present.
   </td>
  </tr>
</table>


**Finally most commonly used Operations**

**Intermediate Operations:**


    **map: **The map method is used to map the items in the collection to other objects according to the Predicate passed as argument. \
`List number = Arrays.asList(2,3,4,5); \
List square = number.stream().map(x->x*x).collect(Collectors.toList());`


    **filter:** The filter method is used to select elements as per the Predicate passed as argument. \
`List names = Arrays.asList("Reflection","Collection","Stream"); \
List result = names.stream().filter(s->s.startsWith("S")).collect(Collectors.toList());`


    **sorted:** The sorted method is used to sort the stream. \
`List names = Arrays.asList("Reflection","Collection","Stream"); \
List result = names.stream().sorted().collect(Collectors.toList());`

**Terminal Operations:**


    **collect:** The collect method is used to return the result of the intermediate operations performed on the stream. \
`List number = Arrays.asList(2,3,4,5,3); \
Set square = number.stream().map(x->x*x).collect(Collectors.toSet());`


    **forEach:** The forEach method is used to iterate through every element of the stream. \
`List number = Arrays.asList(2,3,4,5); \
number.stream().map(x->x*x).forEach(y->System.out.println(y));`


    **reduce:** The reduce method is used to reduce the elements of a stream to a single value. \
The reduce method takes a BinaryOperator as a parameter.


```
    List number = Arrays.asList(2,3,4,5);
int even = number.stream().filter(x->x%2==0).reduce(0,(ans,i)-> ans+i);
```


**Example**


```
class Product{  
    int id;  
    String name;  
    float price;  
    public Product(int id, String name, float price) {  
        this.id = id;  
        this.name = name;  
        this.price = price;  
    }  
}  

public class Strams {
	public static void main(String[] args) {


		List<Product> productsList = new ArrayList<Product>();  
        //Adding Products  
        productsList.add(new Product(1,"HP Laptop",25000f));  
        productsList.add(new Product(2,"Dell Laptop",30000f));  
        productsList.add(new Product(3,"Lenevo Laptop",28000f));  
        productsList.add(new Product(4,"Sony Laptop",28000f));  
        productsList.add(new Product(5,"Apple Laptop",90000f));  


        List<Float> productPriceList2 =productsList.stream()  
                      .filter(p -> p.price > 30000)// filtering data  
                      .map(p->p.price)        // fetching price  
                      .collect(Collectors.toList()); // collecting as list  
        System.out.println(productPriceList2);  //[90000.0]





        // This is more compact approach for filtering data  
        productsList.stream()  
                    .filter(product -> product.price == 30000)  
                    .forEach(product -> System.out.println(product.name));  //  Dell Laptop


        // count number of products based on the filter  
        long count = productsList.stream()  
                    .filter(product->product.price<30000)  
                    .count();  
        System.out.println(count);  //3


        // Converting product List into Set  
        Set<Float> productPriceList =    productsList.stream()  
            .filter(product->product.price < 30000)   // filter product on the base of price  
            .map(product->product.price)  //get the price
            .collect(Collectors.toSet());   // collect it as Set(remove duplicate elements)  
        System.out.println(productPriceList);  //[25000.0, 28000.0]		


	}
}
```


**References**



* [https://www.pearsonfrank.com/blog/java-interview-questions/](https://www.pearsonfrank.com/blog/java-interview-questions/)
* [https://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html](https://javarevisited.blogspot.com/2015/10/133-java-interview-questions-answers-from-last-5-years.html)
* [http://www.java67.com/2012/09/top-10-tricky-java-interview-questions-answers.html](http://www.java67.com/2012/09/top-10-tricky-java-interview-questions-answers.html)
* [https://howtodoinjava.com/java-interview-questions/](https://howtodoinjava.com/java-interview-questions/)
* [https://www.janbasktraining.com/blog/core-java-interview-questions-answers/](https://www.janbasktraining.com/blog/core-java-interview-questions-answers/)
* [https://snowdream.github.io/115-Java-Interview-Questions-and-Answers/115-Java-Interview-Questions-and-Answers/en/exception.html](https://snowdream.github.io/115-Java-Interview-Questions-and-Answers/115-Java-Interview-Questions-and-Answers/en/exception.html)
* [https://javapapers.com/java/java-concurrent-collections/](https://javapapers.com/java/java-concurrent-collections/)

**[https://deepakvadgama.com/blog/](https://deepakvadgama.com/blog/)**


# 12.Features by Version


## Java5 (2005)

**<span style="text-decoration:underline;">Annotations</span>**

Java **Annotation** is a tag that represents the _metadata_ i.e. attached with class, interface, methods or fields to indicate some additional information which can be used by java compiler and JVM.

Annotations have a number of uses, among them:



* **Information for the compiler** — Annotations can be used by the compiler to detect errors or suppress warnings.
* **Compile-time and deployment-time processing** — Software tools can process annotation information to generate code, XML files, and so forth.
* **Runtime processing** — Some annotations are available to be examined at runtime

The annotation can include **_elements_**, which can be named or unnamed, and there are values for those elements:


```
@Author(
   name = "Benjamin Franklin",
   date = "3/27/2003"
)
class MyClass() { ... }
```


If there **is just one element** named value, then the name can be omitted, as in:


```
@SuppressWarnings("unchecked")
void myMethod() { ... }
```


If the annotation has no elements, then the parentheses can be omitted


```
 example  : @Override 
```


It is also possible to use multiple annotations on the same declaration:


```
@Author(name = "Jane Doe")
@EBook
class MyClass { ... }
```


If the annotations have the same type, then this is called a repeating annotation Repeating annotations are supported as of the Java SE 8 release.


```
@Author(name = "Jane Doe")
@Author(name = "John Smith")
class MyClass { ... }
```


**Java Custom annotations** or Java User-defined annotations are easy to create and use. The **_@interface_** element is used to declare an annotation. 



* Method should **not have any throws clauses**
* Method should **return something**
* Method **should not have any parameter**.
* It **may assign a default value to the method.**


```
@interface MyAnnotation{  
int value() default 0;  
}  
```


**Example**

Suppose Every class in a given Project should contain author info. Writing Author info in each every class is deficult like below


```
public class GenrateWorkSheet extends DataList {

   // Author: John Doe
   // Date: 3/17/2002
   // Current revision: 6
   // Last modified: 4/12/2004
   // By: Jane Doe
   // Reviewers: Alice, Bill, Cindy

   // class code goes here

}
```


By Using Annotation we can provide above information.for doing this we need to create an annotation & all properties should define using methods. 


```
@interface ClassPreamble {
   String author();
   String date();
   int currentRevision() default 1;
   String lastModified() default "N/A";
   String lastModifiedBy() default "N/A";
   // Note use of array
   String[] reviewers();
}
```


Once annotation reday, you can write that annotation top of the each class with values


```
@ClassPreamble (
   author = "John Doe",
   date = "3/17/2002",
   currentRevision = 6,
   lastModified = "4/12/2004",
   lastModifiedBy = "Jane Doe",
   // Note array notation
   reviewers = {"Alice", "Bob", "Cindy"}
)
public class Generation3List extends Generation2List {
// class code goes here

}
```


**<span style="text-decoration:underline;">Autoboxing</span>**

The automatic conversion of primitive data types into its equivalent Wrapper type is known as boxing and opposite operation is known as unboxing.

Upto JDK 1.4, all the data structures of Java stores only objects and when retrieved returns objects. Autoboxing permits to store data types directly in DS and retrieve back data types.

**<span style="text-decoration:underline;">Generics</span>**

**Type-safety :** We can hold only a single type of objects in generics. It doesn’t allow to store other objects.

**<span style="text-decoration:underline;">Covariant Return Type (Java 5)</span>**

Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type. 

**<span style="text-decoration:underline;">Enhanced for loop</span>**

The for-each loop introduced in Java5. It is mainly used to traverse array or collection elements.


```
int arr[]={12,13,14,44};  


   for(int i:arr){  
     System.out.println(i);  
   }  
```


**<span style="text-decoration:underline;">Varargs</span>**

The varrags allows the method to accept zero or muliple arguments. If we don't know how many argument we will have to pass in the method, varargs is the better approach.



* There can be only one variable argument in the method.
* Variable argument (varargs) must be the last argument.

**<span style="text-decoration:underline;">Enums</span>**

**Enum in java** is a data type that contains fixed set of constants.

It can be used for days of the week (SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY and SATURDAY) , directions (NORTH, SOUTH, EAST and WEST) etc. The java enum constants are static and final implicitly.

**<span style="text-decoration:underline;">Static imports</span>**

The static import feature of Java 5 facilitate the java programmer to access any static member of a class directly. There is no need to qualify it by the class name.

**<span style="text-decoration:underline;">C-lang printf()</span>**

**printf()** is an extra method added to **PrintStream** class from JDK 1.5 version. **printf()** is used to print at command-prompt


```
public class PrintfDemo
{
  public static void main(String args[])
  {
    boolean hot = false;
    char alphabet = 'A';
    int rate = 5;
    float temperature = 12.3456789f;

    System.out.printf("The boolean hot: %b", hot);      // place holder b for boolean
    System.out.printf("\nThe char alphabet: %c", alphabet);                // c for char                
    System.out.printf("\nThe int rate: %d", rate);                         // d for int
    System.out.printf("\nThe float marks is %f", temperature);             // f for float
    System.out.printf("\n value prefixed with 4 zeros: %04d", rate);// filling with zeros
    System.out.printf("\float temp %.3f", temperature); // precision to three decimal values
    System.out.printf("\nThe float temperature in exponential form: %e", temperature);
    System.out.printf("\n%s, %s and also %s belong to java.lang package", "System","String","Math");
    System.out.printf("\ntemperature is %4.2f", temperature); // width is 4 and precision to 2 decimal points
  }
}
```




<p id="gdcalert118" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image117.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert119">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


![alt_text](images/image117.png "image_tooltip")


Java6 not many fetaures


## Java 7(2011)

**<span style="text-decoration:underline;">Underscores in Numeric Literals (Java 7)</span>**

Java allows you to use underscore in numeric literals.



* You cannot use underscore at the beginning or end of a number.
* You cannot use underscore adjacent to a decimal point in a floating point literal.(  10._0)
* You cannot use underscore prior to an F or L suffix (**long** a = 10_100_00_L;)

**<span style="text-decoration:underline;">String in switch statement (Java 7)</span>**


```
public class StringInSwitchStatementExample {  
    public static void main(String[] args) {  
        String game = "Cricket";  
        switch(game){  
        case "Hockey":  
            System.out.println("Let's play Hockey");  
            break;  
        case "Cricket":  
            System.out.println("Let's play Cricket");  
            break;  
        case "Football":  
            System.out.println("Let's play Football");  
        }  
    }  
}  
```


**<span style="text-decoration:underline;">The try-with-resources (Java 7)</span>**

the try-with-resources statement is a try statement that declares one or more resources. The resource is as an object that must be closed after finishing the program. The try-with-resources statement ensures that each resource is closed at the end of the statement execution.

You can pass any object that implements java.lang.AutoCloseable, which includes all objects which implement java.io.Closeable

**<span style="text-decoration:underline;">Caching Multiple Exceptions by single catch (Java 7)</span>**

Java allows you to catch multiple type exceptions in a single catch block. It was introduced in Java 7 and helps to optimize code.You can use vertical bar (|) to separate multiple exceptions in catch block.

**<span style="text-decoration:underline;">Diamond operator &lt;>, removes right side of generics</span>**

you can replace the type arguments with an empty set of type parameters (&lt;>). This pair of angle brackets is informally called the diamond.

The following approach is used in Java 6 and prior version.


```
Ex. List<Integer> list  = new List<Integer>();  
```


Now, you can use the following new approach introduced in Java 7.


```
Ex. List<Integer> list = new List<>(); // Here, we just used diamond  
```



## Java8(2014)

**<span style="text-decoration:underline;">Functional Interfaces (Java 8)</span>**

An Interface that contains exactly one abstract method is known as functional interface. It can have any number of default, static methods but can contain only one abstract method. It can also declare methods of object class


```
@FunctionalInterface  
interface sayable{  
    void say(String msg);  
}  
```


**<span style="text-decoration:underline;">Lambda Expressions (Java 8)</span>**

The Lambda expression is used to provide the implementation of an interface which has functional interface

**<span style="text-decoration:underline;">Stream (Java 8)</span>**

Another major change introduced **Java 8 Streams API**, which provides a mechanism for processing a set of data in various ways that can include filtering, transformation, or any other way that may be useful to an application.

Streams API in Java 8 supports a different type of iteration where you simply define the set of items to be processed, the operation(s) to be performed on each item, and where the output of those operations is to be stored.

**<span style="text-decoration:underline;">Default Methods & Static methods Interface (Java 8)</span>**

Java 8 allows you to add non-abstract methods in interfaces. These methods must be declared default methods.Default methods enable you to add new functionality to the interfaces of your libraries and ensure binary compatibility with code written for older versions of those interfaces.


```
public interface Moveable {
    default void move(){
        System.out.println("I am moving");
    }
}
static void isNull(String str) {
 System.out.println("Interface Null Check"); 
}
```


If class willingly wants to customize the behavior of move() method then it can provide it’s own custom implementation and override the method.in this case we must remove **default **keyword.

**Static methods :** Java interface static method is similar to default method except that we can’t override them in the implementation classes. 

**<span style="text-decoration:underline;">Java 8 Date/Time API (Java 8)</span>**

`Date` class has even become obsolete. The new classes intended to replace Date class are `LocalDate`, `LocalTime` and `LocalDateTime`.



* The `LocalDate` class represents a date. There is no representation of a time or time-zone.
* The `LocalTime` class represents a time. There is no representation of a date or time-zone.
* The `LocalDateTime` class represents a date-time. There is no representation of a time-zone


```
LocalDate localDate = LocalDate.now();
LocalTime localTime = LocalTime.of(12, 20);
LocalDateTime localDateTime = LocalDateTime.now();
OffsetDateTime offsetDateTime = OffsetDateTime.now();
ZonedDateTime zonedDateTime = ZonedDateTime.now(ZoneId.of("Europe/Paris"));
```


`Duration` class is a whole new concept brought first time in java language. It represents the time difference between two time stamps.


```
Duration duration = Duration.ofMillis(5000);
duration = Duration.ofSeconds(60);
duration = Duration.ofMinutes(10);
```


`Duration` deals with small unit of time such as milliseconds, seconds, minutes and hour. They are more suitable for interacting with application code. To interact with human, you need to get bigger durations which are presented with `Period` class.


```
Period period = Period.ofDays(6);
period = Period.ofMonths(6);
period = Period.between(LocalDate.now(), LocalDate.now().plusDays(60));
```



## Java9 (2017)

**<span style="text-decoration:underline;">JShell: The Java Shell (REPL)</span>**

It is an interactive Java Shell tool, it allows us to execute Java code from the shell and shows output immediately. JShell is a REPL (Read Evaluate Print Loop) tool and run from the command line.

**<span style="text-decoration:underline;">Module System (Project Jigsaw)</span>**

In earlier versions of Java, there was no concept of module to create modular Java applications, that why size of application increased and difficult to move around. Even JDK itself was too heavy in size, in Java 8, **rt.jar** file size is around 64MB.

To deal with situation, **Java 9 restructured JDK into set of modules** so that we can use only required module for our project

Create a file **module-info.java**, inside this file, declare a module by using **module** identifier and provide module name same as the directory name that contains it. In our case, our directory name is com.javatpoint.

**<span style="text-decoration:underline;">Interface Private Methods</span>**

In Java 9, we can create private methods inside an interface. Interface allows us to declare private methods that help to **share **common code between **non-abstract** methods / Default methods.


```
interface Sayable{  
    default void say() {  
        saySomething();  
    }  
    // Private method inside interface  
    private void saySomething() {  
        System.out.println("Hello... I'm private method");  
    }  
}  
public class PrivateInterface implements Sayable {  
    public static void main(String[] args) {  
        Sayable s = new PrivateInterface();  
        s.say();  
    }  
}
```


**<span style="text-decoration:underline;">Multi-Release JAR Files</span>**

Previously, you had to package all classes into a jar file and drop in the classpath of the another application, which wish to use it.

Using multi-release feature, now a jar can contains different versions of a class – compatible to different JDK releases. The information regarding different versions of a class, and in which JDK version which class shall be picked up by class loaded, is stored in **MANIFEST.MF** file.


##  Java10 (mar-2018) (Java SE 10.0.2	 july-18)

**<span style="text-decoration:underline;">Local Variable Type Inference</span>**

Java has now `var` style declarations. It allows you to declare a local variable without specifying its type. The type of variable will be inferred from type of actual object created. It claims to be the only real feature for developers in JDK 10


```
var str = "Hello world";
```


Garbage-Collector Interface improvements 


# References

Flow Control : 100 page in handwrite / 64 in Note 

Declartions : 124 hand / 40 in notes

OOPS : 190 hand / 

OOPS : 190 hand / 96 notes

Java.lnag.io : Hand 302, Notes -146

[https://srikarbandla.wordpress.com/2015/07/31/static-control-flow/](https://srikarbandla.wordpress.com/2015/07/31/static-control-flow/)


# I. OLD


## Transient - Final - String


```
class Employee implements Serializable
{
   private String           firstName;
   private String           lastName;
   private transient String confidentialInfo;


   //Setters and Getters
}
```


Now let’s serialize an instance of Employee class.


```
try
{
   ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("empInfo.ser"));
   Employee emp = new Employee();
   emp.setFirstName("Lokesh");
   emp.setLastName("Gupta");
   emp.setConfidentialInfo("password");
   //Serialize the object
   oos.writeObject(emp);
   oos.close();
} catch (Exception e)
{
   System.out.println(e);
}
```


Program Output.


```
Lokesh
Gupta
null

public final transient String confidentialInfo = "password";
//final field 2
public final transient Logger logger = Logger.getLogger("demo");
```


Program output.


```
Lokesh
Gupta
password
null
```


This is strange. We have marked the “confidentialInfo” to transient; and still the field was serialized. For similar declaration, logger was not serialized. Why?

Reason is that whenever any final field/reference is evaluated as “constant expression“, it is serialized by JVM ignoring the presence of transient keyword.

In above example, value “password” is a constant expression and instance of logger “demo” is reference. So by rule, confidentialInfo was persisted where as logger was not.

Are you thinking, what if I remove “transient” from both fields? Well, then fields implementing Serializable references will persist otherwise not. So, if you remove transient in above code, String (which implements Serializable) will be persisted; where as Logger (which does NOT implements Serializable) will not be persisted AND “java.io.NotSerializableException” will be thrown.
